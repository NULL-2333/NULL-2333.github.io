{"meta":{"title":"Yiming","subtitle":"","description":"","author":"Yiming","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About","date":"2023-03-21T16:14:33.517Z","updated":"2020-09-19T02:42:01.143Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/","excerpt":"","text":"Education University of Southern California, Los Angeles, CA Aug. 2019 - Expected May. 2021 Master of Science in Computer Science - GPA: 4.0/4.0 Coursework: Analysis of Algorithms; Foundation of Artificial Intelligence; Web Technology; Mobile Games; Southeast University, Nanjing, Jiangsu, China Aug. 2015 - Expected Jun. 2019 Bachelor of Engineering in Computer Science - GPA: 3.77/4.0 Coursework: Fundamentals of Data Structure; Fundamentals of Algorithm Design; Operating Systems; Computer Network; Work Experience iOS Developer Intern, ByteDance Ltd., China Jun. 2020 - Present Take part in various projects about trust and security to enhance user experience and enable products conforms to local rules in different regions. Improve experience of reporting and optimized code of products for cooperated developers understanding easily. Skills: iOS, Objective-C Software Engineer Intern, Xiaomi Technology Ltd., China Oct. 2018 - Mar. 2019 Implement test tools with Python to detect invalid code optimization and applied Jinja2 to dynamically generate different static web pages. Collaborated with a team to get their requirement generated in different scenarios in their daily work and addressed the problem of missing or improper mergence of code in the practical production process. Using Go to implement a tool to create random fragment files in cellphones and simulate the situation of long-term use of cellphones to examine the performance of defragmentation. Skills: Python, Jinja2, HTML, Go Projects News App (Web &amp; iOS) Mar. 2020 - Apr. 2020 Built a RESTful service backend with Node.js and Express.js to provide APIs of formatted news and construct the frontend web app with native React, React-Bootstrap, React-Router and some other third-party libraries. Provided users with following features: browse news divided into various sections, share news with others via Face- book/Twitter/Email, bookmark news for later reading, add comments to different news and search news with keywords. Reconstructed it into an iOS version application and provided users with corresponding features as before. Skills: RESTful, Node.js, Express.js, React, Bootstrap, iOS, Swift Sokoban Maker Puzzle Game Jan. 2020 - Apr. 2020 Developed an iOS puzzle game with Unity named Sokoban Maker, including built-in levels, level maker, money system and a community for users to share their works of puzzles. Using Unity and C# to build the UI of different game scenes including game playing and level making and implement the backend of community with Go. Supported users to make their own puzzles of sokoban and share with other users in communities model. Skills: Unity, C#, Go, SQL, GCP(Google Cloud Platform) Fast CBCT Projection Algorithm Based on CUDA Parallel Acceleration Mar. 2019 - Jun. 2019 Designed a ray-driven algorithm of projection and a voxel-driven algorithm of back-projection, applied them in the form of C++, and then parallelized these two algorithm with the framework of {\\bf CUDA} on GPUs to accelerate the whole procedure. Employed a method with fixed sampling number when implementing the algorithm of ray-driven projection, which enables the operations of projection on different threads to run synchronously. Relationship Extraction Intelligent Diagnosis System Jan. 2018 - Apr. 2019 Completed a software system focusing on the judgement of the results of relationship extraction and allowing users to compare results between the outcome of different training frameworks on the web. Built a system using Java and MongoDB to evaluate the performance of different kinds of approaches to relationship extraction, store the metadata in database for future calls and reviews and present it on the web page built with Bootstrap. Supported users to upload their personal data to the system through web pages and freely look over different aspects of statistics with different training frameworks, which allowed them to evaluate their own training models. Skills: Java, SQL, MongoDB, Bootstrap, Javascript Racing Data Analysis Software Jul. 2018 - Sept. 2018 Sketched a PC-based software called The Data-Graph Software designed to draw the graph which depicts different sensors for the racing cars and shows the GPS information. The demonstration of The Data-Graph Software can be viewed in https://www.youtube.com/watch?v=af4zLfwI-Bc. Worked directly with users of the system locally in order to provide the information they need for performance driving as well as how it could be displayed and interacted with in a more efficient manner, meant to help coach to transfer the data of different sensors to intuitive graphs easily and made it possible for drivers and coaches to review their data and analyze feasible improvements for both the driver and vehicle. Virtual Campus System Apr. 2017 - Sep. 2017 Developed a virtual campus system using Java and the techniques of multi-threading, features including: user log in, log out and sign up, curriculum services, grade services, educational services, flea market services and etc. based on the structure of MVC (Model-View-Client). Mainly coded the models of library and bank services and the communication between clients and servers. Resume Download Resume_YimingChen.pdf Contact E-mail：yiming.chen.cym@gmail.com GitHub：https://github.com/NULL-2333"},{"title":"Categories","date":"2020-05-04T07:58:02.257Z","updated":"2020-05-04T07:53:38.225Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/","excerpt":"","text":""},{"title":"Links","date":"2023-03-21T16:23:44.217Z","updated":"2023-03-21T16:23:44.209Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-04T07:51:08.688Z","updated":"2020-05-04T07:47:04.527Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/","excerpt":"","text":""},{"title":"Tags","date":"2023-03-21T16:14:27.432Z","updated":"2020-05-04T07:57:58.056Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/","excerpt":"","text":""}],"posts":[{"title":"KVO,KVC与KVV","slug":"KVO-KVC与KVV","date":"2020-08-25T16:53:03.000Z","updated":"2020-09-19T02:07:30.544Z","comments":true,"path":"KVO-KVC与KVV/","link":"","permalink":"http://yoursite.com/KVO-KVC%E4%B8%8EKVV/","excerpt":"","text":"KVO - Key Value Observer 在MVC架构中保持Model和View的统一性 定义依赖属性 依赖属性可以用来表明属性之间的依赖关系，从而使得在set被依赖属性的时候，依赖属性也会收到通知。定义依赖属性有以下两种方式： 为单个属性定义依赖属性 1234+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffecting&lt;#DependentKey#&gt;&#123; return [NSSet setWithObjects:@&quot;&lt;#keyPath#&gt;&quot;, nil];&#125; 为任意属性定义依赖属性 1234567+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;key1&quot;]) &#123; return [NSSet setWithObjects:@&quot;first&quot;, @&quot;last&quot;, nil]; &#125; else if...&#125; 依赖属性的使用 在想要observe的属性上加上observer： 1[_labColor addObserver:observer forKeyPath:@&quot;key&quot; options:someOptions context:someContext]; 此处options主要有以下几种选项： 123456typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; NSKeyValueObservingOptionNew &#x3D; 0x01, NSKeyValueObservingOptionOld &#x3D; 0x02, NSKeyValueObservingOptionInitial &#x3D; 0x04, NSKeyValueObservingOptionPrior &#x3D; 0x08&#125;; NSKeyValueObservingOptionNew表示传递新的赋值，NSKeyValueObservingOptionOld表示传递赋值前的值，NSKeyValueObservingOptionInitial表示在addObserve的时候就会调用一次下述函数，相当于进行一次初始化，NSKeyValueObservingOptionPrior则表示在该属性变更前后会各收到一次notifier，这些不同选项所传递的值都在change中。 注意该observer必须实现如下方法： 12345678- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (context &#x3D;&#x3D; &lt;#context#&gt;) &#123; &lt;#code to be executed upon observing keypath#&gt; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; 手动通知与自动通知 在被observe的对象上实现如下方法可以关闭自动notify： 1234+ (BOOL)automaticallyNotifiesObserversOfLComponent&#123; return NO;&#125; 想要手动发送notifier，可以通过重写相应的属性的set方法，举例如下： 123456789- (void)setLComponent:(double)lComponent&#123; if (_lComponent &#x3D;&#x3D; lComponent) &#123; return; &#125; [self willChangeValueForKey:@&quot;lComponent&quot;]; _lComponent &#x3D; lComponent; [self didChangeValueForKey:@&quot;lComponent&quot;];&#125; 此处我们可以知道，在自动通知的情况下，willChangeValueForKey和didChangeValueForKey会自动调用。 此外，如果需要更加详细的信息，可以重写如下will方法和对应的did方法： 1234- (void)willChangeValueForKey:(NSString *)key;- (void)willChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;&#x2F;&#x2F; 只对mutable版本有效- (void)willChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects; 然后手动调用will和did方法即可（记得关闭自动通知，否则会通知两次）。 对可变集合类的支持 由于在向可变集合类内添加元素的时候，该类对象的地址不一定会发生改变，从而就不一定会产生notifier通知给observer，因此在向可变集合类内添加元素的时候，可以调用如下函数： 123-mutableArrayValueForKey:-mutableSetValueForKey:-mutableOrderedSetValueForKey: 举例： 1234567被observe的类中有这个对象：@property (nonatomic, strong) NSMutableArray *testArray;如果要观察这个对象，添加observer的方法如下：self.mutableArrayTest &#x3D; [[MutableArrayTest alloc] init];[self.mutableArrayTest addObserver:self forKeyPath:@&quot;testArray&quot; options:someOptions context:nil];在更改testArray中的对象时，调用：[[self.mutableArrayTest mutableArrayValueForKey:@&quot;testArray&quot;] addObject:@&quot;111&quot;]; KVC - Key Value Coding 设置属性，简化UI 可以直接通过如下方法修改对象中的属性值： 1- (void)setValue:(id)value forKey:(NSString *)key; 使用这个方法就可以直接通过属性名在MVC中的Model层修改属性直接对应的UI。 也可以使用如下方法实现批量的设置： 1- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *,id&gt; *)keyedValues; Key Path 以下两个函数可以通过类似属性的方式读写对象内部的属性： 12- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (id)valueForKeyPath:(NSString *)keyPath; 举例如下： 1234&#x2F;&#x2F; 修改当前类下labColor对象下的obj对象的testString属性值为@&quot;WWWWWW&quot;[self setValue:@&quot;WWWWWW&quot; forKeyPath:@&quot;labColor.obj.testString&quot;];&#x2F;&#x2F; 获取_labColor对象下obj对象的testString属性的值NSLog(@&quot;%@&quot;, [_labColor valueForKeyPath:@&quot;obj.testString&quot;]); 不定义property但是可以设置属性 可以通过实现-和-set这两个函数来动态定义key属性，然后在访问和修改这个属性的时候则可以使用valueForKey和setValue:forKey方法。 如果想要使用setValue:forKey方法给key属性设置nil，则会抛出异常，可以通过重写以下方法来处理： 1- (void)setNilValueForKey:(NSString *)key; 动态添加属性还有一种方法，就是重写以下方法，所有之前未定义过的key都会走这个方法兜底： 12- (id)valueForUndefinedKey:(NSString *)key;- (void)setValue:(id)value forUndefinedKey:(NSString *)key； 集合操作 参考https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html 对于集合类，可以通过在valueForKeyPath方法中设置不同的key实现，key的一般格式如下： 如果对象本来就是集合类，则left key path可以省略。 举例： 12&#x2F;&#x2F; 返回self.labColor.testArr这个数组内的对象的amount属性的平均值[self valueForKeyPath:@&quot;labColor.testArr.@avg.amount&quot;]) 一般有三种collection operator 聚合操作算子 Aggregate Operator @avg, @min, @max, @count, @sum 数组操作算子 Array Operator @distinctUnionOfObjects, @unionOfObjects 嵌套操作算子 Nesting Operator @distinctUnionOfArrays, @unionOfArrays, @distinctUnionOfSets 集合代理 首先举例说明： 如果我们在类中实现了如下方法： 1234567891011- (NSUInteger)countOfContacts&#123; return 10;&#125;- (id)objectInContactsAtIndex:(NSUInteger)idx&#123; if (idx &lt; 5) &#123; return @&quot;first half&quot;; &#125; else &#123; return @&quot;last half&quot;; &#125;&#125; 那么我们就可以通过[_labColor valueForKey:@“contacts”]来得到如下数组： 123456789101112(&quot;first half&quot;,&quot;first half&quot;,&quot;first half&quot;,&quot;first half&quot;,&quot;first half&quot;,&quot;last half&quot;,&quot;last half&quot;,&quot;last half&quot;,&quot;last half&quot;,&quot;last half&quot;) 相当于动态的在该类中添加了一个集合对象（实际上这个对象的类型是NSKeyValueArray，其内部包含一个NSArray对象）。 类似的，我们也可以通过这种方式实现NSSet和NSOrderedSet： 同时也可以在上面这些方法的基础上再实现额外的添加和删除方法实现对应的mutable版本的集合类： KVV - Key Value Validation 可以在调用KVC函数之前判断即将要赋的值是否合法，主要是下面两个函数： 12- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError; 这两个函数会去调用对应的对象中的如下方法： 1- (BOOL)validate&lt;key&gt;:(id *)value error:(out NSError * _Nullable __autoreleasing *)outError; 如果没有重写这个方法，则默认返回YES，表示所有值都合法，可以通过重写这个函数实现KVV。 举例： 12345678910111213141516171819&#x2F;&#x2F; LabColor.m&#x2F;&#x2F; 对于firstName这个属性，@“Japan”是不合法的值- (BOOL)validateFirstName:(id *)value error:(out NSError * _Nullable __autoreleasing *)outError&#123; NSString *firstName &#x3D; *value; if ([firstName isEqualToString:@&quot;japan&quot;]) &#123; return NO; &#125; return YES;&#125;&#x2F;&#x2F; 使用_labColor &#x3D; [[LabColor alloc] init];NSString *value1 &#x3D; @&quot;japan&quot;;NSString *value2 &#x3D; @&quot;japann&quot;;NSError *err;NSLog(@&quot;%d&quot;, [_labColor validateValue:&amp;value1 forKey:@&quot;firstName&quot; error:&amp;err]);&#x2F;&#x2F; 返回NONSLog(@&quot;%d&quot;, [_labColor validateValue:&amp;value2 forKey:@&quot;firstName&quot; error:&amp;err]);&#x2F;&#x2F; 返回YES KVC中的函数调用顺序 取值 valueForKey: 和 valueForKeyPath: 直接get的四个函数方法； 是否实现了NSArray的方法； 是否实现了NSSet方法； accessInstanceVariablesDirectly返回YES并且存在对应的实例变量； 如果上述四步任意一步取得了值则在这一步进行包装； 否则调用valueForUndefinedKey方法抛出异常（可以重写该方法不抛出异常）。 设置值 setValue:forKey: 和 setValue:forKeyPath: 首先查找是否有对应的set方法，如果有则直接调用； accessInstanceVariablesDirectly返回YES并且存在对应的实例变量，则直接设置实例变量即可； 调用setValue:forUndefinedKey:方法，默认是抛出异常，可以重写。 参考 KVC 和 KVO iOS开发—图解KVC","categories":[],"tags":[]},{"title":"Define中的特殊符号","slug":"Define中的特殊符号","date":"2020-08-25T06:24:55.000Z","updated":"2020-08-25T17:25:45.023Z","comments":true,"path":"Define中的特殊符号/","link":"","permalink":"http://yoursite.com/Define%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"#符号 用于转换成字符串，即相当于在#后面的内容两端加上双引号，如果原本就有双引号则会自动进行转义 举例： 1234#define MAKE(x) #xNSLog(@&quot;%@&quot;, @(MAKE(12))); &#x2F;&#x2F; 打印结果：12NSLog(@&quot;%@&quot;, @(MAKE(www))); &#x2F;&#x2F; 打印结果：wwwNSLog(@&quot;%@&quot;, @(MAKE(&quot;www&quot;))); &#x2F;&#x2F; 打印结果：&quot;www&quot; ##符号 用于连接tokens，但是只能连接数字 举例： 12#define CONCAT_1(x,y) (x##y)NSLog(@&quot;%@&quot;, @(CONCAT_1(1,2))); &#x2F;&#x2F; 打印结果：12 如果要连接C字符串，则需要用如下的宏定义： 12#define CONCAT_2(x,y) (x y)NSLog(@&quot;%@&quot;, @(CONCAT_2(&quot;ww&quot;,&quot;ee&quot;))); &#x2F;&#x2F; 打印结果：wwee","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"RunLoop","slug":"RunLoop","date":"2020-08-23T17:08:34.000Z","updated":"2020-09-20T16:58:57.283Z","comments":true,"path":"RunLoop/","link":"","permalink":"http://yoursite.com/RunLoop/","excerpt":"","text":"什么是RunLoop RunLoop就是一个永不停止的循环，在这个循环中，系统将一直进行“等待-接收消息-处理-等待”的循环。iOS中的RunLoop保证了系统可以一直运行，而不是执行完成当前任务后就退出。在iOS的主线程中自动运行着一个RunLoop，即main.m文件中的main函数返回的UIApplicationMain对象自动包含的。 其主要起如下作用： 等待用户的输入和发出的事件； 决定事件的处理顺序； 事件发送可以同时进行； 在等待期间几乎不需要占用CPU资源。 RunLoop的实现 OC中的Core Foundation库中有一层对RunLoop的实现：CFRunLoopRef，主要包含RunLoop的结构和一系列底层的C语言API，而后在Foundation库中对CFRunLoopRef有进一步的封装：NSRunLoop。 RunLoop结构 CFRunLoopRef CFRunLoopModeRef 对于任意一个CFRunLoopModeRef对象，其中包含三部分，分别是CFRunLoopSourceRef的Set，CFRunLoopObserverRef的Array和CFRunLoopTimerRef的Array。如果一个mode中这三个对象均为空，则不会进入这个RunLoop，而同一对象反复加入mode也只会起效一次。因此，如果要切换mode，就必须先退出当前mode，然后再进入新的mode，从而做到mode与mode之间的分离。 要往mode上添加或移除对象，可以使用以下函数： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); CommonMode的使用 其中注意CommonModes这个概念，默认1和2这两个mode都具有common属性，设置mode的common属性可以使用以下函数，会将这个mode存进_commonModes数组中： 1CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); 具有common属性的mode在发生变化的时候，会将_commonModeItems中的所有对象自动的添加到所有具有common属性的mode中。将对象添加到_commonModeItems需要将对象绑定或添加到kCFRunLoopCommonModes这个mode上。举例如下： 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 具体操作如下： 12345678910&#x2F;&#x2F; CFRunModeRefCFRunLoopAddTimer(CFRunLoopGetCurrent(), CFRunLoopTimerCreate(kCFAllocatorDefault, 0&lt;开始时间&gt;, 1.f&lt;间隔时间&gt;, 0&lt;flag，默认为0即可&gt;, 1&lt;优先级&gt;, func&lt;回调函数&gt;, NULL&lt;传入的参数，info&gt;), kCFRunLoopCommonModes);void func(CFRunLoopTimerRef timer, void *info)&#123; &#x2F;&#x2F; 具体执行代码&#125;&#x2F;&#x2F; NSRunLoopNSTimer *timer &#x3D; [NSTimer timerWithTimeInterval:1.f repeats:YES block:^(NSTimer * _Nonnull timer) &#123; &#x2F;&#x2F; 具体执行代码&#125;];[[NSRunLoop currentRunLoop] addTimer:timer forMode:**NSRunLoopCommonModes**]; CFRunLoopTimerRef NSTimer是对这个对象的封装 CFRunLoopSourceRef source0：处理如UIEvent，CFSocket这样的事件 source1：Mach port驱动，CFMachport，CFMessagePort CFRunLoopObserverRef Cocoa框架中很多机制比如CAAnimation等都是由RunLoopObserver触发的，observer到当前状态的变化进行可以通知，通知的时机有： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠 kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒 kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出Loop&#125;; RunLoop的内部逻辑 RunLoop的应用 AutoReleasePool App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。 第一个observer监视的是Entry，其优先级最高（数字最小），回调函数会创建autoreleasepool 第二个observer监视的是BeforeWaiting（即将进入休眠）和Exit，BeforeWaiting时候会触发释放旧的自动回收池并建立新的，Exit的时候只会释放旧的pool，其优先级最低，保证其在其他所有事件之后调用。 NSTimer NSTimer和CFRunLoopTimerRef是Toll-Free Bridged（无缝桥接，可以直接使用强转，具体可见Toll-Free Bridging）。为了节省资源，RunLoop并不会十分精确的调用Timer的回调函数。Timer有一个属性tolerance，表示能容忍的最大误差（尽管tolerance可以置0，但是实际上却不一定管用），而在当前周期无法执行的任务会跳过，而不会延后执行。 延迟检测 在一个异步线程上用NSTimer定时向主线程发送请求，如果在一定的时间（规定的卡顿时间）内可以dispatch到主线程，则说明未发生卡顿，否则则说明有卡顿。（注意其实线程切换有损耗） 此外可以使用RunLoop实现 GCD RunLoop底层会用到GCD来实现，如使用dispatch_queue_t来管理mode，而GCD中的函数dispatch_async在第一个参数为主线程（即回归到主线程执行）的时候，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 线程常驻 12345dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#x2F;&#x2F; 具体操作 [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];&#x2F;&#x2F; 如果没有信息要在线程间传递的话可以不用这个port [[NSRunLoop currentRunLoop] run];&#125;); performSelector的afterDelay和onThread 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 事件响应 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 __handleEventQueue() 进行应用内部的分发。 __handleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touche事件都是在这个回调中完成的。 通过添加__IOHIDEventSystemClientQueueCallback和__handleEventQueue这两个方法的Symbolic Breakpoint，观察调用栈可以知道，在点击UIButton触发点击事件的时候，首先会调用基于source1的__IOHIDEventSystemClientQueueCallback方法，然后才会调用基于source0的__handleEventQueue方法，完成一次完整的响应。 手势操作 手势操作则是在上面事件响应的基础上进行的，系统默认会注册一个回调函数为_UIGestureRecognizerUpdateObserver的observer 当上面的 handleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，_UIGestureRecognizerUpdateObserver这个回调都会进行相应处理。 UI更新 系统会注册一个回调函数为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv的observer用于处理UI上的更新，监听BeforeWaiting和Exit事件。 每次操作UI时，系统都会将这个UIView或者CALayer提交到一个全局的容器里面，在下一个runloop的时候统一调用上面那个回调函数执行ui的更新。（高亮处即为上面的那个回调函数） 参考 https://blog.ibireme.com/2015/05/18/runloop/ https://www.jianshu.com/p/417591dcd2db https://github.com/ming1016/study/wiki/CFRunLoop","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://yoursite.com/tags/RunLoop/"}]},{"title":"@selector传参","slug":"selector传参","date":"2020-07-31T11:06:56.000Z","updated":"2020-08-25T16:52:11.249Z","comments":true,"path":"selector传参/","link":"","permalink":"http://yoursite.com/selector%E4%BC%A0%E5%8F%82/","excerpt":"","text":"普通selector函数的传参 performSelector 可以传0， 1， 2个参数，更多的参数可以打包成NSDictionary传递。 123- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; NSInvocation 可以传任意个参数，示例如下： 123456789101112131415161718192021222324- (NSString *) invocationActionWithStr: (NSString *) str andBlock: (NSString * (^) (NSString *)) blk&#123; blk(str); return str;&#125;NSString *str &#x3D; @&quot;Here we go!&quot;;NSString * (^invocationBlk) (NSString *) &#x3D; ^NSString *(NSString *str)&#123; NSLog(@&quot;%@&quot;, str); return str;&#125;;SEL selector &#x3D; @selector(invocationActionWithStr:andBlock:);NSMethodSignature *sign &#x3D; [self methodSignatureForSelector:selector];NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:sign];invocation.selector &#x3D; selector;&#x2F;&#x2F; 参数下标一般从2开始，0号参数为self，1号参数为_cmd[invocation setArgument:&amp;str atIndex:2];[invocation setArgument:&amp;invocationBlk atIndex:3];[invocation invokeWithTarget:self];&#x2F;&#x2F; 获取返回值NSString * __unsafe_unretained returnStr &#x3D; @&quot;Default&quot;;&#x2F;&#x2F; 可以人为修改返回值，甚至可以改变类型&#x2F;&#x2F; [invocation setReturnValue:&amp;returnStr];[invocation getReturnValue:&amp;returnStr];NSLog(@&quot;Return: %@&quot;, returnStr); UIButton的addTarget函数 一般是使用关联对象，有两种方法 定义分类 在分类中定义自己想要的对象实例，然后直接在target中调用sender.objectxxx即可，参见Objective-C与Runtime 动态绑定 即在代码中动态绑定需要的对象，示例如下： 123456789101112- (void) taskAction: (id) sender&#123; NSLog(@&quot;%@&quot;, [objc_getAssociatedObject(sender, @&quot;Btn&quot;) objectForKey:@&quot;first&quot;]);&#125;UIButton *btn &#x3D; [[UIButton alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];[btn setBackgroundColor:[UIColor blackColor]];&#x2F;&#x2F; tag属性只能传递简单的UIUIInteger类型的对象btn.tag &#x3D; 12;NSDictionary *paramDic &#x3D; @&#123;@&quot;first&quot;: self&#125;;objc_setAssociatedObject(btn, @&quot;Btn&quot;, paramDic, OBJC_ASSOCIATION_RETAIN_NONATOMIC);[btn addTarget:self action:@selector(taskAction:) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:btn]; NSTimer的scheduledTimerWithTimeInterval函数 使用userInfo即可，示例如下： 12NSDictionary *paramDic &#x3D; @&#123;@&quot;first&quot;: self&#125;;[NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerAction:) userInfo:paramDic repeats:YES];","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS生命周期","slug":"iOS生命周期","date":"2020-07-29T02:33:18.000Z","updated":"2020-09-19T02:16:33.338Z","comments":true,"path":"iOS生命周期/","link":"","permalink":"http://yoursite.com/iOS%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"iOS生命周期 APP的启动流程 执行main函数 调用UIApplicationMain函数 初始化UIApplication对象并设置UIApplication类的代理 UIApplication对象无限循环直至退出程序 UIApplication的生命周期 App有五种状态： Not running（未运行）：程序未启动 Inactive（未激活）：其他两个状态切换时出现的短暂状态。唯一在此状态停留时间比较长的情况是：当用户锁屏时或者系统提示用户去响应Alert窗口（如来电、信息）时 Active（激活）：在屏幕上显示的正常运行状态，该状态下可以接收用户输入并更新显示 Background（后台）：程序在后台且能执行代码。用户按下Home键不久后进入此状态（先进入了Inactive状态，再进入Background状态），然后会迅速进入挂起状态（Suspended）。有的程序经过特殊的请求后可以长期处于Background状态 Suspended（挂起）：程序在后台不能执行代码。普通程序在进入Background状态不久后就会进入此状态。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存 首次打开APP时（或者无后台情况下打开APP）会调用如下函数： 1- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt; *)launchOptions; 然后调用如下函数： 1- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt; *)launchOptions; 此处有一个简化版的不带options的函数： 1- (void)applicationDidFinishLaunching:(UIApplication *)application; 这个函数现在已经deprecated，如果实现了上面带options的函数则这个函数不会运行，否则会运行这个函数。 然后调用- (void)applicationDidBecomeActive:(UIApplication *)application;进入APP的UI界面，进入活跃状态（active），此时应用进入前台，可以用来恢复UI； 双击Home键（或等价操作），会调用- (void)applicationWillResignActive:(UIApplication *)application;，表示进入非活动（inactive）状态，此时应用准备进入后台（一般是处于多任务模式或者进入后台前的动画的那一段时间），可以用来保存UI； 如果接到电话或者进入Siri等情况下，会调用- (void)applicationWillResignActive:(UIApplication *)application;进入非活动状态； 按下Home键（或等价操作），会先调用- (void)applicationWillResignActive:(UIApplication *)application;，再调用- (void)applicationDidEnterBackground:(UIApplication *)application;，表面应用进入后台，这个阶段可以用来保存数据； 在多任务模式下点击应用，或者直接点击应用图标开启已经在后台的应用，会先调用- (void)applicationWillEnterForeground:(UIApplication *)application;，再调用- (void)applicationDidBecomeActive:(UIApplication *)application;进入活跃状态，applicationWillEnterForeground函数内可以用于恢复用户数据； 手动将APP从后台清除的时候会调用- (void)applicationWillTerminate:(UIApplication *)application;，此时可以保存用户数据； 当发生内存不足的时候，会调用- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application;，如果此时系统强制kill这个APP或者用户直接删除这个App则不会调用- (void)applicationWillTerminate:(UIApplication *)application;。 UIViewController的生命周期 默认的顺序为： + (void)load;，这个函数在引入当前类的时候就会调用（在applicationWillFinishLaunchingWithOptions之前； - (void)viewDidLoad; - (void)viewWillAppear:(BOOL)animated; - (void)viewWillLayoutSubviews;，这个函数在每一次发生bounds变化的时候都会调用，默认实现为空； - (void)viewDidAppear:(BOOL)animated; 至此当前vc对应的view显示出来了； 如果此时直接关闭App，则不会调用disappear系列函数（不管是关后台还是只是进入后台），如果切View，则会有如下顺序： - (void)viewWillDisappear:(BOOL)animated; - (void)viewDidDisappear:(BOOL)animated; initWithNibName:bundle和awakeFromNib函数则是在使用storyboard的时候才会调用。 UI数据的保存与恢复 要保存因为意外关闭的View和ViewController，需要首先在AppDelegate.h中覆写如下两个函数（返回YES即可）： 12345678- (BOOL)application:(UIApplication *)application shouldSaveSecureApplicationState:(NSCoder *)coder&#123; return YES;&#125;- (BOOL)application:(UIApplication *)application shouldRestoreSecureApplicationState:(NSCoder *)coder&#123; return YES;&#125; 然后在要保存的ViewController类或者View类中实现这两个方法： 12- (void)encodeRestorableStateWithCoder:(NSCoder *)coder;- (void)decodeRestorableStateWithCoder:(NSCoder *)coder; 举例如下： 1234567891011-(void)encodeRestorableStateWithCoder:(NSCoder *)coder&#123; [coder encodeObject:UIImagePNGRepresentation(_imageView.image) forKey:@&quot;YourImageKey&quot;]; [super decodeRestorableStateWithCoder:coder];&#125;-(void)decodeRestorableStateWithCoder:(NSCoder *)coder&#123; _imageView.image &#x3D; [UIImage imageWithData:[coder decodeObjectForKey:@&quot;YourImageKey&quot;]]; [super encodeRestorableStateWithCoder:coder];&#125; p.s. 调用顺序，第一张图为整个App运行过程中的顺序，第二张图为保存View和VC的具体过程","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Podfile的使用","slug":"Podfile的使用","date":"2020-07-27T03:24:33.000Z","updated":"2020-08-25T16:22:16.618Z","comments":true,"path":"Podfile的使用/","link":"","permalink":"http://yoursite.com/Podfile%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Podfile用途 用于指定一个或多个XCode工程的依赖 Root Options Podfile文件的整体配置 install! 语法如下： 123install! 'cocoapods', [option] =&gt; value, [option] =&gt; value 支持的option-value以及默认值如下： option default value meaning :clean true 是否清除Pods文件夹内的无关文件 :deduplicate_targets true 是否针对有不同subspec的同一pods库生成不同的pods targets :deterministic_uuids true 是否生成确定的uuid :integrate_targets true 是否将pods自动集成到项目中，即是否生成那个白色的.xcworkspace文件 :lock_pod_sources true 在下载pods库的时候是否锁定Podfile文件 :warn_for_multiple_pod_sources true 对于名字与版本号均相同的pods库是否需要warning :share_schemes_for_development_pods false 是否共享开发pods的xcode工程 :disable_input_output_paths false 是否禁用Cocoapods脚本的输入输出路径 :preserve_pod_file_structure false 是否需要保持pods库的原有结构 :generate_multiple_pod_projects false 是否需要生成多个Pods.xcodeproj文件 :incremental_installation false 是否仅重新生成在上次安装之后有改动的target和相关工程 :skip_pods_project_generation false 是否跳过生成Pods.xcodeproj文件 Dependencies pod 12345678pod &#39;podName&#39; &#x2F;&#x2F;安装最新版本pod &#39;podName&#39;, &#39;&#x3D;1.0&#39;&#x2F;&#x2F;安装1.0版本pod &#39;podName&#39;, &#39;&gt;1.0&#39;&#x2F;&#x2F;安装大于1.0的最新版本pod &#39;podName&#39;, &#39;&gt;&#x3D;1.0&#39;&#x2F;&#x2F;安装大于等于1.0的最新版本pod &#39;podName&#39;, &#39;&lt;1.0&#39;&#x2F;&#x2F;安装小于1.0的最新版本pod &#39;podName&#39;, &#39;&lt;&#x3D;1.0&#39;&#x2F;&#x2F;安装小于等于1.0的最新版本pod &#39;podName&#39;, &#39;~&gt;1.0&#39;&#x2F;&#x2F;安装满足[1.0, 2.0)之间的最新版本pod &#39;podName&#39;, &#39;~&gt;0.1.2&#39;&#x2F;&#x2F;安装满足[0.1.2, 0.2.0)之间的最新版本 :configuration 指定在哪些模式下安装，主要是Debug和Release 12pod &#39;podName&#39;, :configuration &#x3D;&gt; &#39;Release&#39;pod &#39;podName&#39;, :configuration &#x3D;&gt; [&#39;Debug&#39;, &#39;Release&#39;] :modular_headers 表示是否使用模块化的header 1pod &#39;podName&#39;, :modular_headers &#x3D;&gt; true :source 指定搜索的位置 1pod &#39;podName&#39;, :source &#x3D;&gt; &#39;xxxxxx&#39; :subspecs 指定要安装的子部分 12pod &#39;podName&#39;, :subspecs &#x3D;&gt; &#39;xxxxxx&#39;pod &#39;podName&#39;, :subspecs &#x3D;&gt; [&#39;xxxxxx&#39;, &#39;xxxxx&#39;] :path 指定本地地址作为当前pods库的地址 1pod &#39;podName&#39;, :path &#x3D;&gt; &#39;xxxxxx&#39; :git 指定git仓库以及相应的分支，或者tag，或者commit 1pod &#39;podName&#39;, :git &#x3D;&gt; &#39;xxx&#39;, :branch &#x3D;&gt; &#39;xxx&#39;, :tag &#x3D;&gt; &#39;xxx&#39;, commit &#x3D;&gt; &#39;xxx&#39; p.s. branch默认为master target 用于指定不同target的具体的pods库 1234target &#39;targetName&#39; do pod &#39;podName1&#39; pod &#39;podName2&#39;end target的pods库的继承 1234567891011target &#39;ShowsApp&#39; do pod &#39;ShowsKit&#39; target &#39;ShowsTV&#39; do # 会复制一份ShowKit pod &#39;ShowTVAuth&#39; end target &#39;ShowsTest&#39; do # 不会复制一份ShowKit库，而是和ShowAPP这个target共享ShowKit库 **inherit!** **:search_paths** pod &#39;Specta&#39; pod &#39;Expecta&#39; endend script_phrase 会在运行工程的时候运行这个script 1script_phase :name &#x3D;&gt; &#39;HelloWorldScript&#39;, :script &#x3D;&gt; &#39;echo &quot;wwww&quot; &gt; test.txt&#39; abstract_target 和target的不同点在于abstract_target所指定的target实际上不存在，继承关系类似。 1234567891011121314abstract_target &#39;Shows&#39; do pod &#39;ShowsKit&#39; target &#39;ShowsiOS&#39; do pod &#39;ShowWebAuth&#39; end target &#39;ShowsTV&#39; do pod &#39;ShowTVAuth&#39; end target &#39;ShowsTests&#39; do inherit! :search_paths pod &#39;Specta&#39; pod &#39;Expecta&#39; endend inherit! 主要有三种选项： 123inherit! :search_paths &#x2F;&#x2F; 只继承搜索路径inherit! :none &#x2F;&#x2F; 什么都不继承inherit! :complete &#x2F;&#x2F; 什么都继承 Target Configuration platform 1platform [平台名称], [目标版本] 平台名称有，:ios, :osx, :tvos, :watchos project 指定这个podfile对应的project，如果没有显式指定，并且当前目录下只有一个project则使用这个project 1project [工程名称], [build_configuration] 其中build_configuration用于指定构建项目方式的参数，值有:debug和:release两个 举例： 1project &#39;Aweme&#39;, &#39;TikTokDebug&#39; &#x3D;&gt; :debug, &#39;TikTokInhouseDebug&#39; &#x3D;&gt; :debug, &#39;MusicallyInhouseDebug&#39; &#x3D;&gt; :debug, &#39;MusicallyDebug&#39; &#x3D;&gt; :debug 如果未指定值，则默认值为:release inhibit_all_warnings! 添加这一行可以省略所有pods中的warning，也可以对单独的pod进行设置，如下： 1pod &#39;podName&#39;, :inhibit_warnings &#x3D;&gt; false &#x2F;&#x2F; 可以用于exclude from inhibit_all_warnings! use_frameworks! 添加这一行表明应当使用Static Library而不是Frameworks（去掉感叹号则表示相反的意思），有参数用于指定使用静态链接还是动态链接 12use_frameworks! :linkage &#x3D;&gt; :dynamicuse_frameworks! :linkage &#x3D;&gt; :static Workspace Configuration workspace 指定这个podfile对应的workspace，如果没有显式指定，并且当前目录下只有一个workspace则使用这个workspace 1workspace &#39;workspaceName&#39; Source 指定来源，如果指定了新的来源，则必须显式加上Cocoapods的来源，即： 12source &#39;https:&#x2F;&#x2F;github.com&#x2F;artsy&#x2F;Specs.git&#39;source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39; ##Hooks plugins 语法为： 1plugin &#39;pluginName&#39;, [参数对] 举例： 12plugin &#39;cocoapods-keys&#39;, :keyring &#x3D;&gt; &#39;Eidolon&#39;plugin &#39;slather&#39; pre_install和post_install 用于指定安装前后的hook操作，传入的参数为Pod::Installer 举例： 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&#39;GCC_ENABLE_OBJC_GC&#39;] &#x3D; &#39;supported&#39; end endend pod install和pod update的区别 pod install是只会安装新的pods库和卸载旧的pods库，pod update如果不指定对象，则会在pod install的基础上再进行所有库的更新检查（包括降级检查），如果指定库名，则只会对该库进行该操作。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"iOS设计模式","slug":"iOS设计模式","date":"2020-07-26T03:41:36.000Z","updated":"2020-08-25T16:25:19.564Z","comments":true,"path":"iOS设计模式/","link":"","permalink":"http://yoursite.com/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式 123456789101112131415161718192021#import &lt;Foundation&#x2F;Foundation.h&gt;@interface SingletonPattern : NSObject- (instancetype) init NS_UNAVAILABLE;+ (instancetype) alloc NS_UNAVAILABLE;+ (instancetype) shareInstance;@end@implementation SingletonPattern+ (instancetype) shareInstance&#123; static dispatch_once_t onceToken; static SingletonPattern *instance; dispatch_once(&amp;onceToken, ^&#123; instance &#x3D; [[self alloc] init]; &#125;); return instance;&#125;@end&#x2F;&#x2F; 使用SingletonPattern *singletonObject1 &#x3D; [SingletonPattern shareInstance];SingletonPattern *singletonObject2 &#x3D; [SingletonPattern shareInstance];NSLog(@&quot;\\n%@\\n%@&quot;, singletonObject1, singletonObject2); 工厂模式 123456789101112131415#import &lt;Foundation&#x2F;Foundation.h&gt;@interface FactoryPattern : NSObject+ (instancetype) createWithType: (NSString *) className;@end@implementation FactoryPattern+ (instancetype)createWithType:(NSString *)className&#123; Class class &#x3D; NSClassFromString(className); return [[class alloc] init];&#125;@end&#x2F;&#x2F; 使用id factoryObject1 &#x3D; [FactoryPattern createWithType:@&quot;UITableView&quot;];id factoryObject2 &#x3D; [FactoryPattern createWithType:@&quot;UIView&quot;];NSLog(@&quot;%@ %@&quot;, NSStringFromClass([factoryObject1 class]), NSStringFromClass([factoryObject2 class])); 这里的createWithType可以写成任意形式，参数也可以指定为任意的不同类的区分方式 抽象工厂模式 和工厂模式的区别在于多了一层抽象工厂和子工厂的区别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@interface AbstractFactoryPattern : NSObject- (UIView *) createViewWithType: (NSInteger) type;- (UIColor *) createColorWithName: (NSString *) colorName;+ (Class) getConcreteFactory: (NSString *) factoryType;@end@implementation AbstractFactoryPattern- (UIView *)createViewWithType:(NSInteger)type&#123; return nil;&#125;- (UIColor *)createColorWithName:(NSString *)colorName&#123; return nil;&#125;+ (Class) getConcreteFactory: (NSString *) factoryType&#123; if ([factoryType isEqualToString:@&quot;View&quot;]) &#123; return [ConcreteFactory1 class]; &#125; else&#123; return [ConcreteFactory2 class]; &#125;&#125;@end@interface ConcreteFactory1 : AbstractFactoryPattern@end@implementation ConcreteFactory1- (UIView *) createViewWithType: (NSInteger) type&#123; switch (type) &#123; case 1: return [[UITableView alloc] init]; break; case 2: return [[UICollectionView alloc] init]; break; default: return [[UIView alloc] init]; break; &#125; return nil;&#125;@end@interface ConcreteFactory2 : AbstractFactoryPattern@end@implementation ConcreteFactory2- (UIColor *) createColorWithName: (NSString *) colorName&#123; if ([colorName isEqualToString:@&quot;red&quot;]) &#123; return [UIColor redColor]; &#125; else if ([colorName isEqualToString:@&quot;blue&quot;]) &#123; return [UIColor blueColor]; &#125; else&#123; return [UIColor blackColor]; &#125;&#125;@end&#x2F;&#x2F; 使用AbstractFactoryPattern *concreteFactory1 &#x3D; [[[AbstractFactoryPattern getConcreteFactory:@&quot;View&quot;] alloc] init];UIView *viewFromFactory1 &#x3D; [concreteFactory1 createViewWithType:1];AbstractFactoryPattern *concreteFactory2 &#x3D; [[[AbstractFactoryPattern getConcreteFactory:@&quot;Color&quot;] alloc] init];UIColor *colorFromFactory2 &#x3D; [concreteFactory2 createColorWithName:@&quot;red&quot;];NSLog(@&quot;%@ %@&quot;, NSStringFromClass([viewFromFactory1 class]), NSStringFromClass([colorFromFactory2 class])); 原型模式 12345678910111213141516171819202122232425262728293031323334353637@protocol PrototypeCopyProtocol &lt;NSObject&gt;@required- (id)clone;@end@interface PrototypePattern : NSObject &lt;PrototypeCopyProtocol&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *sex;@property (nonatomic, assign)NSInteger age;- (instancetype) initWithName: (NSString *) name andSex: (NSString *) sex andAge: (NSInteger) age;@end@implementation PrototypePattern- (instancetype) initWithName: (NSString *) name andSex: (NSString *) sex andAge: (NSInteger) age&#123; if (self &#x3D; [super init]) &#123; _name &#x3D; name; _sex &#x3D; sex; _age &#x3D; age; &#125; return self;&#125;- (id)clone&#123; PrototypePattern *prototypeObject &#x3D; [[PrototypePattern alloc] init]; prototypeObject.name &#x3D; self.name; prototypeObject.sex &#x3D; self.sex; prototypeObject.age &#x3D; self.age; return prototypeObject;&#125;- (NSString *)description&#123; return [NSString stringWithFormat:@&quot;Name: %@, Sex: %@, Age: %ld&quot;, _name, _sex, (long)_age];&#125;@end&#x2F;&#x2F; 使用PrototypePattern *prototypeObject1 &#x3D; [[PrototypePattern alloc] initWithName:@&quot;Peer&quot; andSex:@&quot;Male&quot; andAge:22];PrototypePattern *prototypeObject2 &#x3D; [prototypeObject1 clone];NSLog(@&quot;%@\\n%@&quot;, prototypeObject1, prototypeObject2); 生成器模式 生成器模式和抽象工厂模式的区别在于生成器模式采用的是分part的方式，一次需要一个director指导者对象来调用生成器对象生成对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@interface BuilderPatternDirector : NSObject@property (nonatomic, strong) AbstractBuilderPattern *builder;- (instancetype) initWithBuilder:(AbstractBuilderPattern *) builder;- (BuilderPatternProduct *) construct;@end@implementation BuilderPatternDirector- (BuilderPatternProduct *)construct&#123; [_builder buildPartA]; [_builder buildPartB]; [_builder buildPartC]; return [_builder getResult];&#125;- (instancetype)initWithBuilder:(AbstractBuilderPattern *)builder&#123; if (self &#x3D; [super init]) &#123; _builder &#x3D; builder; _builder.product &#x3D; [[BuilderPatternProduct alloc] init]; &#125; return self;&#125;@end@interface BuilderPatternProduct : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *sex;@property (nonatomic, assign)NSInteger age;@end@implementation BuilderPatternProduct- (NSString *)description&#123; return [NSString stringWithFormat:@&quot;Name: %@, Sex: %@, Age: %ld&quot;, _name, _sex, (long)_age];&#125;@end@interface AbstractBuilderPattern : NSObject- (void) buildPartA;- (void) buildPartB;- (void) buildPartC;- (BuilderPatternProduct *) getResult;@property (nonatomic, strong) BuilderPatternProduct *product;@end@implementation AbstractBuilderPattern- (void)buildPartA&#123; return;&#125;- (void)buildPartB&#123; return;&#125;- (void)buildPartC&#123; return;&#125;- (BuilderPatternProduct *)getResult&#123; return nil;&#125;@end@interface ConcreteBuilderPattern : AbstractBuilderPattern@end@implementation ConcreteBuilderPattern- (void)buildPartA&#123; self.product.name &#x3D; @&quot;Peer&quot;;&#125;- (void)buildPartB&#123; self.product.sex &#x3D; @&quot;Male&quot;;&#125;- (void)buildPartC&#123; self.product.age &#x3D; 23;&#125;- (BuilderPatternProduct *)getResult&#123; return self.product;&#125;@end&#x2F;&#x2F; 使用ConcreteBuilderPattern *builder &#x3D; [[ConcreteBuilderPattern alloc] init];BuilderPatternDirector *director &#x3D; [[BuilderPatternDirector alloc] initWithBuilder:builder];BuilderPatternProduct *product &#x3D; [director construct];NSLog(@&quot;%@&quot;, product); 代理模式 即对应OC中的protocol和delegate的使用wqdawd 适配器模式 用于对接不同类型的接口 1234567891011121314151617181920212223242526272829303132@interface OriginalClassForAdapterPattern : NSObject- (void) printNSArray: (NSArray *) arr;@end@implementation OriginalClassForAdapterPattern- (void) printNSArray: (NSArray *) arr&#123; NSLog(@&quot;%@&quot;, arr);&#125;@end@interface Adapter : NSObject@property (nonatomic, strong) OriginalClassForAdapterPattern *originalClass;- (void) printArr1: (NSArray *) arr1 andArr2: (NSArray *) arr2;@end@implementation Adapter- (instancetype)init&#123; self &#x3D; [super init]; if (self) &#123; _originalClass &#x3D; [[OriginalClassForAdapterPattern alloc] init]; &#125; return self;&#125;- (void)printArr1:(NSArray *)arr1 andArr2:(NSArray *)arr2&#123; NSArray *arr &#x3D; [arr1 arrayByAddingObjectsFromArray:arr2]; [_originalClass printNSArray:arr];&#125;@end&#x2F;&#x2F; 用法NSArray *arr1 &#x3D; @[@&quot;eeeee&quot;], *arr2 &#x3D; @[@&quot;wwwwww&quot;];Adapter *adapter &#x3D; [[Adapter alloc] init];[adapter printArr1:arr1 andArr2:arr2]; 外观模式 外观模式就相当于对一系列的类做一个上层的封装 桥接模式 桥接模式类似适配器模式，通过将两个类各自抽象出一个抽象类，从而使得耦合都发生在抽象类之间，实现子类的完全解耦。 装饰器模式 即相当于category 观察者模式 即相当于OC中的observer系列使用，主要是双向绑定与耦合的作用，当observe的对象的属性变化时，则可以作出对应的操作。主要是通过实现如下方法： 1- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(void *)context; 注意点在于，有addObserver就一定要记得removeObserver 策略模式 12345678910111213141516171819202122232425262728293031323334@interface AbstractStrategyPattern : NSObject- (void) testWithStrategy: (NSString *) str;@end@implementation AbstractStrategyPattern- (void)testWithStrategy:(NSString *)str&#123; return;&#125;@end@interface ConcreteStrategyPattern1 : AbstractStrategyPattern@end@implementation ConcreteStrategyPattern1- (void)testWithStrategy:(NSString *)str&#123; NSLog(@&quot;Strategy1 - %@&quot;, str);&#125;@end@interface ConcreteStrategyPattern2 : AbstractStrategyPattern@end@implementation ConcreteStrategyPattern2- (void)testWithStrategy:(NSString *)str&#123; NSLog(@&quot;Strategy2 - %@&quot;, str);&#125;@end&#x2F;&#x2F; 使用AbstractStrategyPattern *strategy1 &#x3D; [[ConcreteStrategyPattern1 alloc] init];AbstractStrategyPattern *strategy2 &#x3D; [[ConcreteStrategyPattern2 alloc] init];if ([strategy1 respondsToSelector:@selector(testWithStrategy:)]) &#123; [strategy1 testWithStrategy:@&quot;Strategy&quot;];&#125;if ([strategy2 respondsToSelector:@selector(testWithStrategy:)]) &#123; [strategy2 testWithStrategy:@&quot;Strategy&quot;];&#125; 责任链模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface AbstractNodeInChain : NSObject@property (nonatomic, strong) AbstractNodeInChain *nextNode;- (void) transimitMsgInChain: (NSString *) msg;- (void) printMsg: (NSString *) msg;@end@implementation AbstractNodeInChain- (void)transimitMsgInChain:(NSString *)msg&#123; AbstractNodeInChain *node &#x3D; self; while (![node respondsToSelector:@selector(printMsg:)] &amp;&amp; node !&#x3D; nil)&#123; node &#x3D; [node nextNode]; &#125; if (node !&#x3D; nil) &#123; [node printMsg:msg]; &#125; else&#123; NSLog(@&quot;No node in chain can response.&quot;); &#125;&#125;@end@interface ResponsibilityChainPattern : NSObject- (AbstractNodeInChain *)getNodeChain;- (void) logMsgByChain: (NSString *) msg;@end@interface NodeA : AbstractNodeInChain@end@implementation NodeA@end@interface NodeB : AbstractNodeInChain@end@implementation NodeB@end@interface NodeC : AbstractNodeInChain@end@implementation NodeC- (void)printMsg:(NSString *)msg&#123; NSLog(@&quot;%@ - by NodeC&quot;, msg);&#125;@end@implementation ResponsibilityChainPattern- (AbstractNodeInChain *)getNodeChain&#123; NodeA *nodeA &#x3D; [[NodeA alloc] init]; NodeB *nodeB &#x3D; [[NodeB alloc] init]; NodeC *nodeC &#x3D; [[NodeC alloc] init]; nodeA.nextNode &#x3D; nodeB; nodeB.nextNode &#x3D; nodeC; return nodeA;&#125;- (void)logMsgByChain:(NSString *)msg&#123; AbstractNodeInChain *node &#x3D; [self getNodeChain]; [node transimitMsgInChain:msg];&#125;@end&#x2F;&#x2F; 使用ResponsibilityChainPattern *responsibilityChainPattern &#x3D; [[ResponsibilityChainPattern alloc] init];[responsibilityChainPattern logMsgByChain:@&quot;Here we go!&quot;]; Target-Action模式 即常用的addTarget:action函数 中介者模式 12345678910111213141516171819202122232425262728293031323334353637383940@protocol AbstractMediatorProtocol &lt;NSObject&gt;@optional- (void) showMsg: (NSString *)msg;@end@interface Mediator : NSObject &lt;AbstractMediatorProtocol&gt;@end@implementation Mediator- (void)showMsg:(NSString *)msg&#123; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;Message is: %@&quot;, msg]);&#125;@end@protocol AbstractColleagueProtocol &lt;NSObject&gt;@optional- (void) sendMsg: (NSString *) msg;@end@interface Colleague : NSObject &lt;AbstractColleagueProtocol&gt;@property (nonatomic, strong) Mediator *mediator;@property (nonatomic, strong) NSString *name;- (instancetype) initWithName: (NSString *)name;@end@implementation Colleague- (instancetype)initWithName:(NSString *)name&#123; if (self &#x3D; [super init]) &#123; _name &#x3D; name; _mediator &#x3D; [[Mediator alloc] init]; &#125; return self;&#125;- (void)sendMsg:(NSString *)msg&#123; [self.mediator showMsg:[NSString stringWithFormat:@&quot;[%@]: %@&quot;, self.name, msg]];&#125;@end&#x2F;&#x2F; 使用Colleague *colleague1 &#x3D; [[Colleague alloc] initWithName:@&quot;Jack&quot;];Colleague *colleague2 &#x3D; [[Colleague alloc] initWithName:@&quot;John&quot;];[colleague1 sendMsg:@&quot;Hi, John!&quot;];[colleague2 sendMsg:@&quot;Hello, Jack&quot;];","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"}]},{"title":"Objective-C与Block","slug":"Objective-C与Block","date":"2020-07-23T02:31:53.000Z","updated":"2020-08-25T16:36:23.150Z","comments":true,"path":"Objective-C与Block/","link":"","permalink":"http://yoursite.com/Objective-C%E4%B8%8EBlock/","excerpt":"","text":"Block的定义与声明 定义 1^returnType (args) &#123; functionBody; &#125;; 如果returnType为void则可以省略： 1^(args) &#123; functionBody; &#125;; 如果无参数列表args，可以写成void，可以省略，也可以连括号一起省略： 123^returnType (void) &#123; functionmBody; &#125;^returnType () &#123; functionmBody; &#125;^returnType &#123; functionmBody; &#125; 如果返回类型为void且没有参数，则可以省略成： 12^ &#123; functionmBody; &#125;^void (void) &#123; functionmBody; &#125; 声明 1returnType (^blockName) ( argTypes ); 如果argTypes为空（即没有参数），只能用(void)代替，不能进一步省略。 如果作为函数参数，则声明略有不同，如下： 1(returnType (^) ( argTypes )) blockName 举例： 1- (void) callback: (int (^)(void))blk; Block的用法 Typedef别名 即使用typedef 声明即可，声明中的blockName即为这个block的别名，举例： 12typedef int (^blk) (void);blk b &#x3D; ^int ()&#123; return 1; &#125;; &#x2F;&#x2F; 此处b才是这个block的真实名字 赋值操作 赋值操作即为声明=定义; 调用 类似函数的调用即可，举例： 123typedef int (^blk) (void);blk b &#x3D; ^int ()&#123; return 1; &#125;;b(); 变量的两种引用形式 不需要改变值 不需要改变值的变量直接使用即可，进行的是值传递，即在定义block之前的值会被传进去。 需要改变值 需要用__block修饰该变量，如果涉及到self，则需要将self转换成weakSelf避免循环引用，即： 1__weak __typeof(self)weakSelf &#x3D; self; 之后对self的操作都使用weakSelf来操作，如果持有该block的对象被释放，则该weakSelf也会置nil。 p.s. 只有会产生循环引用的情况才需要转换成weakSelf。 而在一个block中，weakSelf随时都可能因为引用它的对象的销毁而置空，因此可以使用再次转为strongSelf的方式，即： 1__strong __typeof(self) strongSelf &#x3D; weakSelf; 这样就可以防止在block的运行过程中的weakSelf的意外置nil。 Block的用途 枚举 12- (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block;- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block; 具体对NSArray中的每一个对象的操作均在block中进行。注意这里的(NSEnumerationOptions)opts 有两个选项： NSEnumerationReverse，逆序访问 NSEnumerationConcurrent，同步访问，不保证顺序，但速度较快 UIView动画 参见iOS动画总结-Block动画 中的第一部分，UIView的两种Block动画实现方式。 排序 123- (void)sortUsingComparator:(NSComparator NS_NOESCAPE)cmptr;[arrs sortUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123;&#125;]; 这个比较函数的Block，返回类型NSComparisonResult有三个枚举： NSOrderedAscending - obj1 &lt; obj2 NSOrderedSame - obj1 = obj2 NSOrderedDescending - obj1 &gt; obj2 Completion handler与错误处理 主要是在某些方法中含有Block类型的参数，可以用作completion handler和错误处理。 GCD多线程控制 参见iOS多线程-GCD 中的GCD相关部分","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}]},{"title":"Objective-C格式化输出","slug":"Objective-C格式化输出","date":"2020-07-22T11:36:51.000Z","updated":"2020-08-25T16:37:28.508Z","comments":true,"path":"Objective-C格式化输出/","link":"","permalink":"http://yoursite.com/Objective-C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","excerpt":"","text":"格式化字符 含义 %@ OC对象和CFTypeRef对象 %% % %d, %i int %p void *指针，指针 %c char %f double %ld, %lx NSInteger, cast to long %lu, %lx NSUinteger, cast to unsigned long %f, %g CGFloat %ld, %lx CFIndex %lld, %llx long long %llu, %llx unsigned long long","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]},{"title":"iOS事件响应","slug":"iOS事件响应","date":"2020-07-22T06:42:48.000Z","updated":"2020-09-20T16:52:22.089Z","comments":true,"path":"iOS事件响应/","link":"","permalink":"http://yoursite.com/iOS%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/","excerpt":"","text":"当对某一个View或者VC进行一次操作时候，其实际的传递和响应过程如下： 传递链 a. 从UIWindows开始向下传递，每次都对当前响应者调用hitTest函数，当hitTest函数返回nil的时候则会继续向subView层调用，否则传递链结束，传递到hitTest返回的控件； b. hitTest函数内部会调用pointInside函数，判断当前点击的point是否在当前正在判断的subView内，如果不在（或者该subView的alpha过小，被隐藏等等）则直接返回nil，否则继续调用该控件的所有subView的hitTest，直至没有subView； c. 此时即可确定当前传递到的控件是哪一个，即由该控件来对该操作进行响应。 响应链 a. 设传递链获取到的控件为A，那么则由A开始向A的父对象进行响应，如果当前对象可以响应这个操作（即实现了touchesBegin等四个函数或者motionBegan等三个函数或者远程控制器函数），则响应链结束，并由该对象响应这个操作，否则递归判断当前对象的父对象是否可以响应该操作，此递归一直调用到UIApplicationDelegate为止，如果UIApplicationDelegate也不能响应，则丢弃该操作； ​ b. 如果传递链获取到的控件A为UIControl对象，则会跳过路上的父节点直接交由UIApplication进行响应。 手势操作链 a. 确定了由哪一个对象响应该操作之后，设该对象为B b. 首先会调用touchesBegin方法，然后判断此时的操作是否满足B上定义的自定义手势（如果没有自定义手势则视为不满足），如果满足则响应该手势，并调用touchesCancel，否则调用touchhesEnded结束touch； ​ c. 在响应手势操作前，如果当前对象遵循了UIGestureRecognizerDelegate，则调用如下函数： 1- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch; ​ 判断是否需要响应该手势，如果不需要返回NO（可以通过判断touch.view来判断当前点击的对象），需要则返回YES。 要在touchesBegin等函数中判断当前是几根指头的操作，需要调用event.allTouches.count并对event.allTouches内的所有UITouch对象调用tapCount属性判断当前UITouch对象点击了几次。此外还可以用timeStamp获得当前操作的时间戳（系统开始时间到操作时间）","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Property的属性值","slug":"Property的属性值","date":"2020-07-21T08:40:45.000Z","updated":"2020-08-25T16:41:40.547Z","comments":true,"path":"Property的属性值/","link":"","permalink":"http://yoursite.com/Property%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/","excerpt":"","text":"主要有以下几对 atomic/nonatomic - 是否原子操作 strong/weak/assign/copy - strong对应OC对象，weak解循环引用，assign对应原生对象，copy对应setter操作时对应copy操作 readwrite/readonly - 是否可读 nullable/nonnull - 是否可为空","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]},{"title":"iOS多线程","slug":"iOS多线程","date":"2020-07-21T06:26:19.000Z","updated":"2020-08-25T16:30:54.091Z","comments":true,"path":"iOS多线程/","link":"","permalink":"http://yoursite.com/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"iOS多线程主要有四种实现方式 Pthread pthread是c语言的底层库对多线程调用的方式，具有跨平台的能力，但是一般在OC的编程中不使用。 NSThread NSThread是对Pthread的一层封装，但是仍旧需要手动对线程进行管理，实际使用过程中可能造成线程的大量创建从而浪费内存。 NSThread的常用方法有： 创建线程 123456&#x2F;&#x2F; 需要显式掉用start函数- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;- (instancetype)initWithBlock:(void (^)(void))block;&#x2F;&#x2F; 不需要显式调用start函数+ (void)detachNewThreadWithBlock:(void (^)(void))block;+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 启动线程 1[thread start]; 获取线程 12[NSThread mainThread];[NSThread currentThread]; 退出与取消线程 12[thread exit];[thread cancel]; 判断当前线程是否为主线程 1[thread isMainThread]; 睡眠 1+ (void)sleepForTimeInterval:(NSTimeInterval)ti; GCD - Grand Central Dispatch GCD会自动利用CPU的多核，并自动管理线程的生命周期，主要用法如下： 创建队列 12dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr); 第一个参数表示该队列的名字，用于标识队列，第二个参数用于设置队列的属性，常见属性有： DISPATCH_QUEUE_SERIAL - 队列内的所有操作串行进行； DISPATCH_QUEUE_SERIAL_INACTIVE - 队列内操作串行，初始为不活跃状态，需dispatch_activate激活； DISPATCH_QUEUE_CONCURRENT - 队列内操作串行； DISPATCH_QUEUE_CONCURRENT_INACTIVE - 队列内操作串行，但是使用时需要激活； 获取内置队列 获取主线程所在队列 1dispatch_queue_main_t dispatch_get_main_queue(void); 获取其他内置队列 1dispatch_queue_global_t dispatch_get_global_queue(long identifier, unsigned long flags); 第一个参数表示队列的优先级，一般使用DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_HIGH，DISPATCH_QUEUE_PRIORITY_DEFAULT，DISPATCH_QUEUE_PRIORITY_LOW，DISPATCH_QUEUE_PRIORITY_BACKGROUND 第二个参数为预留参数，设为0即可。 同步 1void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 举例： 12345dispatch_queue_t queue_sync &#x3D; dispatch_queue_create(&quot;SyncQueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_sync(queue_sync, ^&#123; sleep(2); NSLog(@&quot;Sync&quot;);&#125;); 注意当这段代码是在主线程内执行的时候，这里的queue不能是主线程所在的队列，如果是主线程的话，可能会造成死锁，因此一般不使用这个方法。 异步 1void dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 举例： 1234dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;1&quot;);&#125;); 延迟操作 1void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 举例： 1234dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC));dispatch_after(time, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;wait&quot;);&#125;); 组操作 主要是可以使用dispatch_group_notify在完成一组任务之后进行一定的操作。 举例 123456789101112131415161718dispatch_group_t group &#x3D; dispatch_group_create();dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;groupQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_async(group, queue, ^&#123; sleep(2); NSLog(@&quot;1&quot;);&#125;);dispatch_group_async(group, queue, ^&#123; sleep(2); NSLog(@&quot;2&quot;);&#125;);dispatch_group_async(group, queue, ^&#123; sleep(3); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;3&quot;);&#125;);dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;eee&quot;);&#125;); 栅栏 1void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block); 举例： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; [self useGCDGroup]; NSLog(@&quot;ViewDidLoad&quot;);&#125;- (void) useGCDGroup&#123; dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;groupQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;1&quot;); &#125;); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;2&quot;); &#125;); dispatch_barrier_sync(queue, ^&#123; NSLog(@&quot;barrier&quot;); &#125;); dispatch_async(queue, ^&#123; sleep(4); NSLog(@&quot;3&quot;); &#125;); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;4&quot;); &#125;);&#125; barrier所对应的任务之前的任务都完成之后才会进行barrier的任务，然后才会进行barrier之后的任务。上述例子的输出结果为： 12345612barrrierViewDidLoad43 其中1和2，3和4均有可能互换。 单例 用于保证block内代码只执行一次。 举例 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;dispatch&quot;);&#125;); 信号量 1234567typedef NSObject&lt;OS_dispatch_semaphore&gt; *dispatch_semaphore_t;&#x2F;&#x2F; 声明信号量dispatch_semaphore_t dispatch_semaphore_create(long value);&#x2F;&#x2F; 信号量 - 1， 相当于持有信号量long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);&#x2F;&#x2F; 信号量 + 1， 相当于释放信号量long dispatch_semaphore_signal(dispatch_semaphore_t dsema); 一般dispatch_semaphore_wait和dispatch_semaphore_signal成对使用，创建信号量时的参数即代表资源的持有量，如有多少个可用线程等。 举例： 123456789101112131415161718192021222324252627282930dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;useSemphore&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __block NSString *result &#x3D; @&quot;&quot;; dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(2); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;task 1 begins %@&quot;, [NSThread currentThread]); sleep(2); result &#x3D; [result stringByAppendingFormat:@&quot;ssssss&quot;]; NSLog(@&quot;task 1 ends&quot;); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;task 2 begins %@&quot;, [NSThread currentThread]); sleep(2); result &#x3D; [result stringByAppendingFormat:@&quot;eeeeee&quot;]; NSLog(@&quot;task 2 ends&quot;); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;result &#x3D; %@&quot;, result); dispatch_semaphore_signal(semaphore); dispatch_semaphore_signal(semaphore); &#125;); &#125;); NSOperation NSOperation是对GCD的又一层封装，一般有四种使用方式 NSInvocationOperation 12NSInvocationOperation *op &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil];[op start]; NSBlockOperation 1234567NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;];[op addExecutionBlock:^&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;];[op start]; 注意这里在初始化的时候定义的操作是在主线程上进行的，而addExecutionBlock时加的操作不是在主线程上进行的。 自定义NSOperation的子类 通过重写一些方法如main，来实现自定义。 12345678910111213141516@interface Wrapper : NSOperation@end@implementation Wrapper- (void)main&#123; if (!self.isCancelled) &#123; for (int i &#x3D; 0; i &lt; 3; i++) &#123; sleep(2); NSLog(@&quot;1 %@&quot;, [NSThread currentThread]); &#125; &#125;&#125;@end&#x2F;&#x2F; 使用Wrapper *op &#x3D; [[Wrapper alloc] init];[op start]; NSOperationQueue 通过定义多个NSInvocationOperation和NSBlockOperation对象，并将它们放进一个NSOperationQueue类型的对象中，实现整个队列的统筹。同时，可以通过addDependency等方法实现依赖的先后操作顺序。 举例： 1234567891011121314151617181920NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];NSInvocationOperation *op1 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil];NSBlockOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 3; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2 ---%@&quot;, [NSThread currentThread]); &#125;&#125;];[op2 addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 3; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3 ---%@&quot;, [NSThread currentThread]); &#125;&#125;];NSInvocationOperation *op3 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];[op1 addDependency:op3];[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3];queue.maxConcurrentOperationCount &#x3D; 1; &#x2F;&#x2F; 设置最大并发操作数","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Objective-C与Runtime","slug":"Objective-C与Runtime","date":"2020-07-19T03:21:42.000Z","updated":"2020-09-20T16:53:54.028Z","comments":true,"path":"Objective-C与Runtime/","link":"","permalink":"http://yoursite.com/Objective-C%E4%B8%8ERuntime/","excerpt":"","text":"什么是Runtime Runtime的普遍定义 引用Wiki的定义： In computer science, runtime, run time, or execution time is the final phase of a computer program’s life cycle, in which the code is being executed on the computer’s central processing unit (CPU) as machine code. 也就是说，Runtime就是程序经过编译之后在CPU上运行的状态。Runtime Library就是程序处于Runtime的时候所能引用的库，Runtime Error就是程序在运行时所得到的错误，常见的有除数为零错误、作用域错误、数组溢出错误等。 Objective-C中的Runtime C语言中，在编译过程中，编译器就会确定所要调用的函数的位置； 而OC中的函数是动态的，在编译过程中并不能确定要调用函数的位置，因此就需要通过Runtime来动态地创建类和对象以及传递和转发消息。 OC可以通过三种方式和Runtime进行交互： OC源码 FoundationKit中NSObject协议和类中的如下方法 123456789&#x2F;&#x2F; @protocol NSObject- (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &#39;type(of: anObject)&#39; instead&quot;);- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector;&#x2F;&#x2F; @interface NSObject&#x2F;&#x2F; 返回制定方法的实现的地址- (IMP)methodForSelector:(SEL)aSelector; 对Runtime库的直接调用，主要是&lt;objc/Runtime.h&gt;和&lt;objc/message.h&gt;两个头文件的引入 P.S. 如果需要打开Runtime库的代码提示，需要设置如下位置为NO Runtime的用法 通过消息转发实现多继承 消息转发机制 p.s. 此处要通过转发的方式调用函数，就不能通过类似[myObject testFunc]或者[MyObject testFunc]的方式直接调用，这样在编译的时候就会报错，而是需要用如下方式调用： 12[MyObject performSelector:@selector(testFunc1)]; &#x2F;&#x2F; 类方法[myObject performSelector:@selector(testFunc2)]; &#x2F;&#x2F; 对象方法 类方法的转发 设当前类为MyObject，要调用的类方法为testFunc，即 1[MyObject performSelector:@selector(testFunc)]; 首先会去MyObject这个类中找testFunc这个方法，如果有则直接返回对应的SEL即可； 重写+ (BOOL)resolveClassMethod:(SEL)sel方法，该方法返回YES则说明可以为MyObject这个类动态添加一个类方法testFunc，例如： 12345678910+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@&quot;resolveClassMethod, %@&quot;, NSStringFromSelector(sel)); if (sel &#x3D;&#x3D; @selector(testFunc:Name:)) &#123; &#x2F;&#x2F; 如果要在这一步转发，则应当使用class_addMethod &#x2F;&#x2F; return class_addMethod(objc_getMetaClass(&quot;MyObject&quot;), sel, (IMP)testFunc, &quot;v@:&quot;); return NO; &#125; return [super resolveClassMethod:sel];&#125; 注意此处的函数class_addMethod的参数： 1class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 第一个参数cls表示当前对象所属的类，由于这是类方法，因此cls应当为当前类的Meta Class； 第二个参数name为当前转发的选择器； 第三个参数imp为要转发到的方法的实现，该方法必须要有两个默认的参数(id self,SEL _cmd)（这两个参数对于每一个NSObject子类中的方法都是已经隐含了的）； 第四个参数types为返回类型和方法的参数类型的编码，具体可见Type Encodings 重写+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector方法，返回对应selector的signature，示例如下： 12345678+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSMethodSignature* signature &#x3D; [super methodSignatureForSelector:aSelector]; if (!signature) &#123; signature &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return signature;&#125; 重写+ (void)forwardInvocation:(NSInvocation *)anInvocation进行最后一步转发，此处可以随意转发到任意类的类方法，示例如下： 1234567891011+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; if ([MyObject respondsToSelector:@selector(sing)]) &#123; [anInvocation setSelector:@selector(sing)]; &#x2F;&#x2F; 注意此处target依然需要为class对象 [anInvocation invokeWithTarget:[MyObject class]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 重写+ (void)doesNotRecognizeSelector:(SEL)aSelector方法，此方法会在找不到对应的selector的最后调用，其super方法会抛出异常，一般不建议覆盖该方法。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;ViewController.h&quot;#import &lt;objc&#x2F;objc.h&gt;#import &lt;objc&#x2F;runtime.h&gt;#import &lt;objc&#x2F;message.h&gt;@interface OtherObject : NSObject+ (void)speak;@end@implementation OtherObject+ (void)speak &#123; NSLog(@&quot;Speak!!!&quot;);&#125;@end@interface MyObject : NSObject@end@implementation MyObject+ (void) sing&#123; NSLog(@&quot;Sing&quot;);&#125;+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@&quot;resolveClassMethod, %@&quot;, NSStringFromSelector(sel)); if (sel &#x3D;&#x3D; @selector(testFunc:Name:)) &#123; &#x2F;&#x2F; 如果要在这一步转发，则应当使用class_addMethod &#x2F;&#x2F; return class_addMethod(objc_getMetaClass(&quot;MyObject&quot;), sel, (IMP)testFunc, &quot;v@:&quot;); return NO; &#125; return [super resolveClassMethod:sel];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@&quot;forwardingTargetForSelector, %@&quot;, NSStringFromSelector(aSelector)); &#x2F;&#x2F; 如果要在这一步使用OtherObject的类方法（同名）去相应 &#x2F;&#x2F; if([NSStringFromSelector(aSelector) isEqualToString:@&quot;testFunc:Name:&quot;])&#123; &#x2F;&#x2F; return [OtherObject class]; &#x2F;&#x2F; &#125; return [super forwardingTargetForSelector:aSelector];&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@&quot;methodSignatureForSelector, %@&quot;, NSStringFromSelector(aSelector)); NSMethodSignature* signature &#x3D; [super methodSignatureForSelector:aSelector]; if (!signature) &#123; signature &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return signature;&#125;+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;&#x2F;&#x2F; if ([OtherObject respondsToSelector:@selector(speak)]) &#123;&#x2F;&#x2F; NSLog(@&quot;forwardInvocation YES, %@&quot;, anInvocation.target);&#x2F;&#x2F; [anInvocation setSelector:@selector(speak)];&#x2F;&#x2F; [anInvocation invokeWithTarget:[OtherObject class]];&#x2F;&#x2F; &#125; if ([MyObject respondsToSelector:@selector(sing)]) &#123; NSLog(@&quot;forwardInvocation YES, %@&quot;, anInvocation.target); [anInvocation setSelector:@selector(sing)]; [anInvocation invokeWithTarget:[MyObject class]]; &#125; else &#123; NSLog(@&quot;forwardInvocation NO&quot;); [super forwardInvocation:anInvocation]; &#125;&#125;+ (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@&quot;doesNotRecognizeSelector, %@&quot;, NSStringFromSelector(aSelector));&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.title &#x3D; @&quot;RUNTIME&quot;; [MyObject performSelector:@selector(testFunc:Name:)];&#125;@end 对象方法的转发 对象方法的转发所涉及的函数和类方法基本类似，只不过都从类方法变成了对象方法（除了resolveClassMethod变成resolveInstanceMethod） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;ViewController.h&quot;#import &lt;objc&#x2F;objc.h&gt;#import &lt;objc&#x2F;runtime.h&gt;#import &lt;objc&#x2F;message.h&gt;@interface OtherObject : NSObject- (void)speak;@end@implementation OtherObject- (void)speak &#123; NSLog(@&quot;Speak!!!&quot;);&#125;@end@interface MyObject : NSObject@end@implementation MyObject- (void) sing&#123; NSLog(@&quot;Sing&quot;);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@&quot;resolveInstanceMethod, %@&quot;, NSStringFromSelector(sel)); if (sel &#x3D;&#x3D; @selector(testFunc:Name:)) &#123; &#x2F;&#x2F; 如果要在这一步转发，则应当使用class_addMethod &#x2F;&#x2F; return class_addMethod([self class], sel, (IMP)testFunc, &quot;v@:&quot;); return NO; &#125; return [super resolveInstanceMethod:sel];&#125;- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@&quot;forwardingTargetForSelector, %@&quot;, NSStringFromSelector(aSelector)); &#x2F;&#x2F; 如果要在这一步使用OtherObject的对象方法（同名）去相应 &#x2F;&#x2F; if([NSStringFromSelector(aSelector) isEqualToString:@&quot;testFunc:Name:&quot;])&#123; &#x2F;&#x2F; return [[OtherObject alloc] init]; &#x2F;&#x2F; &#125; return [super forwardingTargetForSelector:aSelector];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@&quot;methodSignatureForSelector, %@&quot;, NSStringFromSelector(aSelector)); NSMethodSignature* signature &#x3D; [super methodSignatureForSelector:aSelector]; if (!signature) &#123; signature &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;&#x2F;&#x2F; OtherObject *otherObject &#x3D; [[OtherObject alloc] init];&#x2F;&#x2F; if ([otherObject respondsToSelector:@selector(speak)]) &#123;&#x2F;&#x2F; NSLog(@&quot;forwardInvocation YES, %@&quot;, anInvocation.target);&#x2F;&#x2F; [anInvocation setSelector:@selector(speak)];&#x2F;&#x2F; [anInvocation invokeWithTarget:otherObject];&#x2F;&#x2F; &#125; if ([self respondsToSelector:@selector(sing)]) &#123; NSLog(@&quot;forwardInvocation YES, %@&quot;, anInvocation.target); [anInvocation setSelector:@selector(sing)]; [anInvocation invokeWithTarget:self]; &#125; else &#123; NSLog(@&quot;forwardInvocation NO&quot;); [super forwardInvocation:anInvocation]; &#125;&#125;- (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@&quot;doesNotRecognizeSelector, %@&quot;, NSStringFromSelector(aSelector));&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.title &#x3D; @&quot;RUNTIME&quot;; MyObject *myObject &#x3D; [[MyObject alloc] init]; [myObject performSelector:@selector(testFunc:Name:)];&#125;@end 通过消息转发实现的多继承 假设在forwardingTargetForSelector这一步就将MyObject的testFunc: Name: 转发给OtherObject，则: 12MyObject *myObject &#x3D; [[MyObject alloc] init];[myObject performSelector:@selector(testFunc:Name:) withObject:@(12) withObject:@&quot;Test&quot;]; 上述代码中myObject实际上执行的是OtherObject中的testFunc: Name: 方法。我们可以修改如下函数的代码： 12345678- (id)forwardingTargetForSelector:(SEL)aSelector&#123; return [[OtherObject alloc] init];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; return [OtherObject class];&#125; 这样在调用MyObject的类方法和对象方法的时候，如果在MyObject类中已经有该方法的实现，则会直接调用该方法的实现；如果没有，则会去OtherObject中寻找该方法的实现。这种模式和MyObject继承自OtherObject是一样的，因此相当于可以用消息转发来实现继承的操作，进而可以实现多继承。 但是这种方法和真正的继承还是不一样的，区别在于调用isKindOfClass函数的时候，真正的继承是可以判断出子类是父类的kindClass，但是消息转发实现的则不能。 Method Swizzling 这是一种OC hook机制的实现 关联对象 用法举例说明： 123456789101112131415@interface NSObject (AssociateObject) @property (nonatomic, strong) NSString *associatedObject;@end@implementation NSObject (AssociateObject)@dynamic associatedObject;- (void) setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSString *) associatedObject&#123; return objc_getAssociatedObject(self, @selector(associatedObject));&#125;@end 涉及到的函数 设置关联对象 1OBJC_EXPORT void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy); 获取关联对象 1OBJC_EXPORT id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); 移除关联对象 1OBJC_EXPORT void objc_removeAssociatedObjects(id _Nonnull object); 这三个函数中object对应于该关联对象的实例对象，key是用于区分不同的关联对象，可以使用字符串，或者@selector(associatedObject)作为key，value则是关联对象，policy对应的是关联对象的存取策略，与property的attributes一一对应，如下表： Policy @property OBJC_ASSOCIATION_ASSIGN @property(assign) / @property(unsafe_unretained) OBJC_ASSOCIATION_RETAIN_NONATOMIC @property(nonatomic, strong) OBJC_ASSOCIATION_COPY_NONATOMIC @property(nonatomic, copy) OBJC_ASSOCIATION_RETAIN @property(atomic, strong) OBJC_ASSOCIATION_COPY @property(atomic, copy) P.S. 这里的remove函数是移除所有的关联对象，因此如果要单独删去某一个的话只要用set函数将其置为nil即可。 快速Encode和Decode 1234567891011121314151617181920212223- (instancetype)initWithCoder:(NSCoder *)coder&#123; self &#x3D; [super init]; if (self) &#123; unsigned int cnt &#x3D; 0; Ivar *vars &#x3D; class_copyIvarList([self class], &amp;cnt); for(int i &#x3D; 0; i &lt; cnt; i++)&#123; NSString *key &#x3D; [NSString stringWithUTF8String:ivar_getName(vars[i])]; id value &#x3D; [coder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(nonnull NSCoder *)coder &#123; unsigned int cnt &#x3D; 0; Ivar *vars &#x3D; class_copyIvarList([self class], &amp;cnt); for(int i &#x3D; 0; i &lt; cnt; i++)&#123; NSString *key &#x3D; [NSString stringWithUTF8String:ivar_getName(vars[i])]; id value &#x3D; [self valueForKey:key]; [coder encodeObject:value forKey:key]; &#125;&#125; Tips，现在的类在遵循NSCoding的同时还需要遵循NSSecureCoding，且使用这两个协议的方法如下： 12345678910NSData *data &#x3D; [NSKeyedArchiver archivedDataWithRootObject:stu requiringSecureCoding:YES error:nil];Student *stu2 &#x3D; [NSKeyedUnarchiver unarchivedObjectOfClasses: [NSSet setWithObjects:[Student class], [NSMutableArray class], [NSMutableDictionary class], nil] fromData:data error:nil];&#x2F;&#x2F; 切记存在非常规类型的时候需要用unarchivedObjectofClasses这个方法并定义好NSSet类型的classes","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"Runtime","slug":"Runtime","permalink":"http://yoursite.com/tags/Runtime/"}]},{"title":"Objective-C和Hook","slug":"Objective-C和Hook","date":"2020-07-17T12:49:40.000Z","updated":"2020-08-25T16:51:16.201Z","comments":true,"path":"Objective-C和Hook/","link":"","permalink":"http://yoursite.com/Objective-C%E5%92%8CHook/","excerpt":"","text":"Method Swizzling Method Swizzling，又称动态方法交换，本质上是通过交换SEL和IMP的对应关系，从而实现实现方法的互换。 在OC中，每一个Method类的对象都对应了一个方法。每一个Method的实例对应的都有一个objc_method的结构体： 123456typedef struct objc_method *Method;struct objc_method &#123; SEL _Nonnull method_name char * _Nullable method_types IMP _Nonnull method_imp&#125; 其中method_name表示的就是方法名，method_types表示的是方法类型，而method_imp表示的是方法的地址，因此Method Swizzling就是通过交换method_imp来实现方法的交换。 实现方法 12345678910111213141516171819202122232425262728+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class &#x3D; [self class]; &#x2F;&#x2F; 如果要交换类方法，则使用 &#x2F;&#x2F; Class class &#x3D; object_getClass((id)self); SEL originalSelector &#x3D; @selector(originalFunc); SEL swizzledSelector &#x3D; @selector(swizzledFunc); Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector); Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector); &#x2F;&#x2F; 如果当前类没有原方法的IMP，说明在从父类继承过来的方法实现， &#x2F;&#x2F; 需要在当前类中添加一个originalSelector 方法， &#x2F;&#x2F; 但是用替换方法 swizzledMethod 去实现它 BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; &#x2F;&#x2F; 原方法的IMP 添加成功后，修改替换方法的IMP为原始方法的IMP class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void) swizzledFunc&#123; [self swizzledFunc];&#125; 注意点 方法的交换应该放在load中进行，而不应该放在init中，因为不管你是否初始化对象，OC总是会调用load函数，而且不需要调用[super load]以避免发生多次交换； 需要把交换放在dispatch_once中，这样可以始终保证只交换一次; 在新的函数实现中仍需要调用[self swizzledFunc]，注意这里并不会产生死循环，因为进入到这个方法内部的时候，实际上调用的是originalFunc对应的函数实现，也就是相当于调用了原来函数的实现，然后就可以在这个实现的上下文中添加自己想要的实现代码； 可能产生由于子类未实现父类的函数导致的父类的函数方法被篡改的情况； 注意不要产生命名冲突。 更好的实现方法 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; 这里的id都可以改成对应的类型，或者在函数内部强转&#x2F;&#x2F; args1后面可以拓展任意个数的参数void (*MethodOriginal)(id self, SEL _cmd, id arg1, ...);void MethodSwizzle(id self, SEL _cmd, id arg1, ...) &#123; &#x2F;&#x2F; 自己想要插入的代码 MethodOriginal(self, _cmd, arg1, ...);&#125;BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMP *store)&#123; IMP imp &#x3D; NULL; Method method &#x3D; class_getInstanceMethod(class, original); if (method) &#123; const char *type &#x3D; method_getTypeEncoding(method); imp &#x3D; class_replaceMethod(class, original, replacement, type); if(!imp)&#123; imp &#x3D; method_getImplementation(method); &#125; &#125; &#x2F;&#x2F; 如果imp不存在，则说明当前函数是继承的父类，因此不进行imp的存储 if (imp &amp;&amp; store) *store &#x3D; imp; return (imp !&#x3D; NULL);&#125;+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self swizzle:@selector(viewDidAppear:) with:(IMP)MethodSwizzle store:(IMP *)&amp;MethodOriginal]; &#125;);&#125;+ (BOOL)swizzle: (SEL) original with: (IMP) replacement store: (IMP *) store&#123; return class_swizzleMethodAndStore(self, original, replacement, store);&#125; FishHook FishHook主要用于hook系统的函数，可以用来修改method_exchangeImplementations函数从而防止别人hook我们的函数。 首先要下载并引入fishhook.c和fishhook.c fishhook 编写hook函数，示例如下： 12345678910111213static void (*orig_nslog)(NSString *, ...);void myNSLog(NSString *str, ...)&#123; va_list ap; va_start(ap, str); NSString *result &#x3D; [[NSString alloc] initWithFormat:str arguments:ap]; orig_nslog([result stringByAppendingFormat:@&quot; Hooked!&quot;]); va_end(ap);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; rebind_symbols((struct rebinding[1])&#123;&#123;&quot;NSLog&quot;, myNSLog, (void *)&amp;orig_nslog&#125;&#125;, 1); NSLog(@&quot;WWWWW %d&quot;, 3); &#x2F;&#x2F; 输出结果为WWWWW 3 Hooked!&#125;","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS动画总结","slug":"iOS动画总结","date":"2020-07-15T03:05:11.000Z","updated":"2020-08-25T16:12:15.245Z","comments":true,"path":"iOS动画总结/","link":"","permalink":"http://yoursite.com/iOS%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"UIView层 Block动画 animationWithDuration 一般是通过block的方式来实现，主要有以下几个函数： 1+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations 这个函数是最简单的动画函数，duration定义了动画的时长，animation block定义了动画的内容，一般是设置动画的结束状态的语句，中间的具体动画过程则是又系统自动填充。 1+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion 这个函数是在上一个动画函数的基础上添加了动画结束时候的回调block函数 1+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion 这个动画函数是在上一个动画函数的基础上添加了延迟时长delay和一些动画选项UIViewAnimationOptions。UIViewAnimationOptions主要包含四大类： 一是基础属性相关，以UIViewAnimationOptions为前缀，如是否重复执行，是否反向执行等等； 二是动画的运行平缓度相关，以UIViewAnimationOptionsCurve为前缀，主要是EaseInOut、EaseIn、EaseOut和Layer，用于定义动画如何开始和结束； 三是方向相关，用于定义部分带方向动画，以UIViewAnimationOptionTransition为前缀； 四是帧数相关，用于定义动画的帧数，以UIViewAnimationOptionPreferredFramesPerSecond为前缀。 1+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion 这个动画函数是上一个动画函数的另一种情况，弹簧动画，主要的几个参数如下： (CGFloat)dampingRatio，抑制系数，范围0-1之间，1表示在重点附近完全无摆动，越靠近1则摆动越大； (CGFloat)velocity，相对的初始速度，范围0-1之间，表示属性值在一开始到达终止值的速度，设置为x则表示需要1/x秒可以到达终止值（这并不意味着动画的结束，因为是弹簧动画，物体的属性值还进行往返运动）。 1+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion 关键帧动画，通过定义动画过程中的关键帧，来实现对动画的控制，其主要的两个参数如下： (UIViewKeyframeAnimationOptions)options，主要分为两类： 以UIViewKeyframeAnimationOption为前缀，类似UIViewAnimationOptions中的第一类； 以UIViewKeyframeAnimationOptionCalculationMode为前缀，主要表示的是不同的插值方式； (void (^)(void))animations，用于添加关键帧，有如下函数 1+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations 其中frameStartTime和frameDuration均为0-1之间的值，即为相对于整个duration的值。 transitionFromView 1+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion; 此处显式指定了fromView和toView 1+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion; 此处指定的view为containerView，即所做动画均为对这个containerView所做，动画效果都是以整个containerView作为基础进行的。 Layer层 CATransaction事务类 CATransaction类是Core Animation类中的事务类，在iOS中的图层中，图层的每个改变都是事务的一部分，CATransaction可以对多个layer的属性同时进行修改，同时负责成批的把多个图层树的修改作为一个原子更新到渲染树。 CATransaction类分为隐式事务和显式事务，对隐式动画的修改只能通过CATransaction，而显式动画可以通过CATransaction也可以通过其他方式修改。 隐式事务 所有对layer的属性的修改都会触发隐式动画，固定时长为0.25s，如果需要关闭隐式动画则需要调用如下函数： 1[CATransaction setDisableActions:YES]; 显式事务 一般有如下结构： 12345678910&#x2F;&#x2F; 开始动画[CATransaction begin]; &#x2F;&#x2F; 设定animation timing function[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];&#x2F;&#x2F; 设定动画的duration[CATransaction setAnimationDuration:5.f];&#x2F;&#x2F; 具体要修改的属性值self.shapeLayer.strokeEnd &#x3D; 1.f - self.shapeLayer.strokeEnd;&#x2F;&#x2F; 提交动画[CATransaction commit]; 此处在定义显式动画的同时会覆盖掉隐式动画，因此不需要手动关闭隐式动画。 ⚠️UIView层的动画只能对指定view的rootLayer做动画，即 12345678910CAShapeLayer *shapeLayer &#x3D; [[CAShapeLayer alloc] init];shapeLayer.fillColor &#x3D; [UIColor clearColor].CGColor;shapeLayer.strokeColor &#x3D; [UIColor blueColor].CGColor;shapeLayer.lineWidth &#x3D; 15.f;shapeLayer.strokeEnd &#x3D; 0.f;shapeLayer.path &#x3D; [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:50 startAngle:-M_PI &#x2F; 2 endAngle:M_PI * 1.5f clockwise:YES].CGPath;[self.view.layer addSublayer:shapeLayer];[UIView animateWithDuration:5.f animations:^&#123; shapeLayer.strokeEnd &#x3D; 1.f;&#125;]; 该代码是无效的，其实际产生的效果是这个shapeLayer的隐式动画，也就是一个时长为0.25s的动画，而并非是5s。要实现5s长的动画，就需要采用Layer层的动画，即： 1234567891011[CATransaction setDisableActions:YES]; &#x2F;&#x2F; 取消layer的隐式动画CABasicAnimation *animation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];animation.fromValue &#x3D; @(self.shapeLayer.strokeEnd);animation.toValue &#x3D; @(1.f - self.shapeLayer.strokeEnd);animation.duration &#x3D; 5.f;animation.removedOnCompletion &#x3D; NO;animation.fillMode &#x3D; kCAFillModeForwards;animation.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];[shapeLayer addAnimation:animation forKey:nil];shapeLayer.strokeEnd &#x3D; 1.f - self.shapeLayer.strokeEnd; &#x2F;&#x2F; 由于上面取消了隐式动画，这里的属性值的修改是不会有动画效果的，否则会有动画效果 或者使用CATransaction来实现，即： 12345[CATransaction begin];[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];[CATransaction setAnimationDuration:5.f];shapeLayer.strokeEnd &#x3D; 1.f - self.shapeLayer.strokeEnd;[CATransaction commit]; 这种方式则不需要关闭隐式动画。 CAAnimation类 主要实现类是CAAnimation及其子类，以及一个所有动画类都遵循的协议CAMediaTiming。 Layer层动画的添加方式： 1- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key; 其中key表示了要变化的属性的名字，例如： 1[self.curView.layer addAnimation:animation forKey:nil]; CAMediaTiming 所有动画类都需要实现的协议； CAAnimation 动画基础类，不可直接使用； CAPropertyAnimation 动画基础类，不可直接使用； CABasicAnimation 基础属性动画，对keyPath所制定的属性进行变化，主要有以下几个函数和属性： 12345@property(nullable, strong) id fromValue; &#x2F;&#x2F; 初始值@property(nullable, strong) id toValue; &#x2F;&#x2F; 终止值@property(nullable, strong) id byValue; &#x2F;&#x2F; 变化值@property CFTimeInterval duration; &#x2F;&#x2F; 动画时间+ (instancetype)animationWithKeyPath:(nullable NSString *)path; &#x2F;&#x2F; 构造函数 有两个属性比较关键，可以用于设置动画结束之后是否需要回到初始态： 123&#x2F;&#x2F; 不回到初始状态animation.removedOnCompletion &#x3D; NO;animation.fillMode &#x3D; kCAFillModeForwards; 这里就要涉及到CALayer的两个子layer对象，persentationLayer和modelLayer，前者负责显示出来的位置，后者负责实际的位置。即使我们在这里设置了动画结束之后不会到初始态，我们也只是将presentationLayer的值设置到了终止态，modelLayer的值还是原来的值，也就是此时通过类似layer.backgroundColor这样的get方法获得到的值是不会变的，要改变这个值则还需要显式的调用set方法（或者点调用）。 例如以下代码，实现了边框的宽度从90变到0的效果： 123456789CABasicAnimation *animation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;borderWidth&quot;];animation.fromValue &#x3D; @(90);animation.toValue &#x3D; @(0);animation.duration &#x3D; 5.f;[animation setAutoreverses:YES];animation.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.removedOnCompletion &#x3D; NO;animation.fillMode &#x3D; kCAFillModeForwards;[self.view.layer addAnimation:animation forKey:nil]; 这段动画结束后，虽然显示出来的边框宽度是90，但是实际上self.view.layer.borderWidth获取到的值还是0.f。 CASpringAnimation 弹簧动画，其主要就是在CABasicAnimation的基础上增加了damping和initialVelocity这两个弹簧相关的对象； CAKeyframeAnimation 关键帧动画，通过定义关键帧或者路径来实现动画的控制 关键帧 主要的参数如下 12@property(nullable, copy) NSArray *values; &#x2F;&#x2F; 关键帧的值数组 @property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes; &#x2F;&#x2F; 关键帧的时间 @property(copy) CAAnimationCalculationMode calculationMode; &#x2F;&#x2F; 计算间隔的方式 #####路径 主要的参数如下 12@property(nullable) CGPathRef path; &#x2F;&#x2F; 一个UIBezierPath类型的变量，表示动画运行的path UIBezierPath主要是通过点来确定路径，同时我们可以定义点和点之间的路径类型，主要的几个函数如下： 123456(void)moveToPoint:(CGPoint)point; &#x2F;&#x2F; 设置初始节点的位置(void)addLineToPoint:(CGPoint)point;(void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;(void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;(void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;(void)closePath; &#x2F;&#x2F; path结束，会自动将结束节点和初始节点连起来 例如下面的代码可以实现一个在固定路径上的关键帧动画： 1234567891011CAKeyframeAnimation *animation &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];UIBezierPath *path &#x3D; [[UIBezierPath alloc] init];[path moveToPoint:CGPointMake(self.caKeyframeAnimationView.frame.origin.x + self.caKeyframeAnimationView.frame.size.width &#x2F; 2, self.caKeyframeAnimationView.frame.origin.y + self.caKeyframeAnimationView.frame.size.height &#x2F; 2)];[path addLineToPoint:CGPointMake(self.caKeyframeAnimationView.frame.origin.x + self.caKeyframeAnimationView.frame.size.width &#x2F; 2 + 30, self.caKeyframeAnimationView.frame.origin.y + self.caKeyframeAnimationView.frame.size.height &#x2F; 2)];[path addLineToPoint:CGPointMake(self.caKeyframeAnimationView.frame.origin.x + self.caKeyframeAnimationView.frame.size.width &#x2F; 2 - 30, self.caKeyframeAnimationView.frame.origin.y + self.caKeyframeAnimationView.frame.size.height &#x2F; 2)];[path closePath];animation.path &#x3D; path.CGPath;animation.duration &#x3D; 1.f;animation.removedOnCompletion &#x3D; NO;animation.fillMode &#x3D; kCAFillModeForwards;[self.caKeyframeAnimationView.layer addAnimation:animation forKey:nil]; CAAnimationGroup 组合动画，可以将多个动画组合起来，通过如下设置即可： 12&#x2F;&#x2F; animationArr是一个由CAAnimation的子类构成的数组 animationGroup.animations &#x3D; animationArr; 注意此处该数组内的动画都是并发执行的，所以如果希望串行执行的话就需要通过设置这个动画组内的动画的beginTime和duration来实现。 CATransition 转场动画类 1234567891011CATransition *animation &#x3D; [[CATransition alloc] init];animation.type &#x3D; kCATransitionFade; &#x2F;&#x2F; 设置转场效果animation.subtype &#x3D; kCATransitionFromTop; &#x2F;&#x2F; 设置转场动画的效果animation.duration &#x3D; 5.f;animation.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];&#x2F;&#x2F; 跳转方式1 - 模态跳转[self.view.layer addAnimation:animation forKey:nil];[self presentViewController:VC animated:NO completion:nil]&#x2F;&#x2F; 跳转方式2 - Nav导航跳转[self.navigationController.view.layer addAnimation:animation forKey:nil];[self.navigationController pushViewController:VC animated:NO]; UIViewController的自定义转场动画 设两个UIViewController类分别为FirstViewController和SecondViewController，对应的实例分别为firstVC和secondVC，且显示顺序为firstVC-&gt;secondVC，要实现从firstVC到secondVC的显示动画和secondVC到firstVC的取消动画，需要以下几步： 实现一个遵循UIViewControllerAnimatedTransitioning的动画类AnimationController，并定义当前的TransitionType 123456789typedef NS_ENUM(NSUInteger, TransitionType) &#123; TransitionTypePresent &#x3D; 0, &#x2F;&#x2F; present和dismiss为模态弹出 TransitionTypeDismiss, TransitionTypePush, &#x2F;&#x2F; push和pop为nav弹出 TransitionTypePop&#125;;@interface AnimationController : NSObject &lt;UIViewControllerAnimatedTransitioning&gt; @property (nonatomic, assign) TransitionType type;@end 在AnimationController类中实现如下两个方法： 1234&#x2F;&#x2F; 动画的duration- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; &#x2F;&#x2F; 动画的具体实现- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; duration的实现很简单，直接返回一个float即可； 动画的具体实现的主要流程如下： 首先根据type判断当前的操作具体是什么 对于push或者present，首先定义fromVC和toVC（注意这里在pop和dismiss的时候会产生fromVC和toVC的互换） 12UIViewController *fromVC &#x3D; [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toVC &#x3D; [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; 获取当前界面的截图视图snapshot，作为后续动画的实际操作view 1UIView *snapshot &#x3D; [fromVC.view snapshotViewAfterScreenUpdates:NO]; 获取containerView作为存放整个过程的容器 1UIView *containerView &#x3D; [transitionContext containerView]; 将fromVC设为hidden，并分别将toVC.view和snapshot加入到containerView中 123[fromVC.view setHidden:YES]; [containerView addSubview:toVC.view]; [containerView addSubview:snapshot]; 设定snapshot的初始设置和位置； 写动画 123456789101112NSTimeInterval duration &#x3D; [self transitionDuration:transitionContext]; [UIView animateWithDuration:duration animations:^&#123; &#x2F;&#x2F; 这里也可以是keyframeanimation或者其他类型的block animation（见第一部分） &#125; completion:^(BOOL finished) &#123; &#x2F;&#x2F; 设置transition结果 [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; &#x2F;&#x2F; 如果transition失败，则将snapshot移除（因为下一次present或者push还会创建snapshot），并将fromVC显示出来 if ([transitionContext transitionWasCancelled]) &#123; [snapshot removeFromSuperview]; [fromVC.view setHidden:NO]; &#125; &#125;]; 对于pop或者dismiss，首先定义fromVC和toVC（注意这里在pop和dismiss的时候会产生fromVC和toVC的互换） 12UIViewController *fromVC &#x3D; [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toVC &#x3D; [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; 获取containerView作为存放整个过程的容器 1UIView *containerView &#x3D; [transitionContext containerView]; 获取present和push中的截图视图snapshot，此时snapshot应当为containerView的subviews中的最后一个view 1UIView *snapshot &#x3D; containerView.subviews.lastObject; 在containerView中添加toVC.view 1[containerView addSubview:toVC.view]; 设定snapshot的初始设置和位置； 写动画 12345678910111213NSTimeInterval duration &#x3D; [self transitionDuration:transitionContext]; [UIView animateWithDuration:duration animations:^&#123; &#x2F;&#x2F; 这里也可以是keyframeanimation或者其他类型的block animation（见第一部分） &#125; completion:^(BOOL finished) &#123; &#x2F;&#x2F; 设置transition结果 [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; &#x2F;&#x2F; 如果transition失败，则什么都不做 &#x2F;&#x2F; 如果transition成功，则将toVC设为hidden，并移除snapshot if (!transitionContext.transitionWasCancelled) &#123; [toVC.view setHidden:NO]; [snapshot removeFromSuperview]; &#125; &#125;]; 对于present和dismiss，在FirstViewController中遵循UIViewControllerTransitioningDelegate，并实现animationControllerForPresentedController函数和animationControllerForDismissedController函数，返回转场动画的实例 1234567891011- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source&#123; &#x2F;&#x2F; 此处可以根据presented和presenting来进行判断需要返回哪一个转场动画类 return [[AnimationController alloc] initWithType:TransitionTypePresent];&#125;- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed&#123; SecondViewController *exampleVC &#x3D; (SecondViewController *)dismissed; if (exampleVC &#x3D;&#x3D; nil) return nil; return [[AnimationController alloc] initWithType:TransitionTypeDismiss];&#125; 对于push和pop，则需要在FirstViewController中遵循UINavigationControllerDelegate，并实现如下函数： 12345678910111213141516- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC&#123; if (operation &#x3D;&#x3D; UINavigationControllerOperationPush) &#123; if ([fromVC isKindOfClass:FirstImageViewController.class]) &#123; FirstViewController *fiVC &#x3D; (FirstViewController *)fromVC; return [[AnimationController alloc] initWithType:TransitionTypePush]; &#125; &#125; else if (operation &#x3D;&#x3D; UINavigationControllerOperationPop)&#123; if ([fromVC isKindOfClass:SecondImageViewController.class]) &#123; SecondViewController *siVC &#x3D; (SecondViewController *)fromVC; return [[AnimationController alloc] initWithType:TransitionTypePop]; &#125; &#125; return nil;&#125;","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Breadth First Search","slug":"Breadth-First-Search-2","date":"2020-07-04T07:02:17.000Z","updated":"2020-07-14T00:50:21.037Z","comments":true,"path":"Breadth-First-Search-2/","link":"","permalink":"http://yoursite.com/Breadth-First-Search-2/","excerpt":"","text":"LC675 Cut Off Trees for Golf Event Problem You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map: 0 represents the obstacle can’t be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height. In one step you can walk in any of the four directions top, bottom, left and right also when standing in a point which is a tree you can decide whether or not to cut off the tree. You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation. You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off. Example 1: 1234567Input: [ [1,2,3], [0,0,4], [7,6,5]]Output: 6 Example 2: 1234567Input: [ [1,2,3], [0,0,0], [7,6,5]]Output: -1 Example 3: 12345678Input: [ [2,3,4], [0,0,5], [8,7,6]]Output: 6Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking. Constraints: 1 &lt;= forest.length &lt;= 50 1 &lt;= forest[i].length &lt;= 50 0 &lt;= forest[i][j] &lt;= 10^9 Think 首先获得所有的树，然后排序，从最矮的开始，每次从当前树的位置bfs到后一棵树。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445int cutOffTree(vector&lt;vector&lt;int&gt;&gt;&amp; forest) &#123; int m = forest.size(), n = forest[0].size(); int res = 0, row = 0, col = 0; vector&lt;vector&lt;int&gt;&gt; trees; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (forest[i][j] &gt; 1) trees.push_back(&#123;forest[i][j], i, j&#125;); &#125; &#125; sort(trees.begin(), trees.end()); for(int i = 0; i &lt; trees.size(); i++)&#123; int cnt = helper(forest, row, col, trees[i][1], trees[i][2]); if(cnt == -1) return -1; res += cnt; row = trees[i][1]; col = trees[i][2]; &#125; return res;&#125;int helper(vector&lt;vector&lt;int&gt;&gt;&amp; forest, int row, int col, int treeRow, int treeCol) &#123; if(row == treeRow &amp;&amp; col == treeCol) return 0; int m = forest.size(), n = forest[0].size(); queue&lt;int&gt; q; q.push(row * n + col); vector&lt;vector&lt;int&gt;&gt; visited(m, vector&lt;int&gt;(n)); vector&lt;int&gt; dir&#123;-1, 0, 1, 0, -1&#125;; int cnt = 0; while(!q.empty())&#123; cnt++; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; int r = q.front() / n, c = q.front() % n; q.pop(); for(int j = 0; j &lt; 4; j++)&#123; int x = r + dir[j], y = c + dir[j + 1]; if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visited[x][y] == 1 || forest[x][y] == 0) continue; if(x == treeRow &amp;&amp; y == treeCol) return cnt; visited[x][y] = 1; q.push(x * n + y); &#125; &#125; &#125; return -1;&#125; LC690 Employee Importance Problem You are given a data structure of employee information, which includes the employee’s unique id, their importance value and their direct subordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all their subordinates. Example 1: 1234Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 &#x3D; 11. Note: One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. Think BFS, p.s. 可以不使用visited数组，因为一个人只有一个领导。 Code 123456789101112131415161718192021222324int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; unordered_map&lt;int, Employee*&gt; map; unordered_set&lt;int&gt; visited; for(auto e: employees) map[e-&gt;id] = e; int res = 0; queue&lt;int&gt; q; q.push(id); visited.insert(id); while(!q.empty())&#123; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; Employee *cur = map[q.front()]; q.pop(); res += cur-&gt;importance; for(int next: cur-&gt;subordinates)&#123; if(!visited.count(next))&#123; q.push(next); visited.insert(next); &#125; &#125; &#125; &#125; return res; &#125; LC744 Find Smallest Letter Greater Than Target Problem Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'. Examples: 1234567891011121314151617181920212223242526272829Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;a&quot;Output: &quot;c&quot;Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;c&quot;Output: &quot;f&quot;Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;d&quot;Output: &quot;f&quot;Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;g&quot;Output: &quot;j&quot;Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;j&quot;Output: &quot;c&quot;Input:letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target &#x3D; &quot;k&quot;Output: &quot;c&quot; Note: letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter. Think Upper_bound Code 12345char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; auto it = upper_bound(letters.begin(), letters.end(), target); if(it == letters.end()) return letters[0]; return *it;&#125; LC753 Cracking the Safe Problem There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1. While entering a password, the last n digits entered will automatically be matched against the correct password. For example, assuming the correct password is &quot;345&quot;, if you type &quot;012345&quot;, the box will open because the correct password matches the suffix of the entered password. Return any password of minimum length that is guaranteed to open the box at some point of entering it. Example 1: 123Input: n &#x3D; 1, k &#x3D; 2Output: &quot;01&quot;Note: &quot;10&quot; will be accepted too. Example 2: 123Input: n &#x3D; 2, k &#x3D; 2Output: &quot;00110&quot;Note: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; will be accepted too. Note: n will be in the range [1, 4]. k will be in the range [1, 10]. k^n will be at most 4096. Think 贪心算法，每次修改最后一位数字，注意内层要反向遍历 Code 123456789101112131415161718string crackSafe(int n, int k) &#123; string res = string(n, '0'); unordered_set&lt;string&gt; visited; visited.insert(res); for(int i = 0; i &lt; pow(k, n); i++) &#123; string pre = res.substr(res.size() - n + 1, n - 1); for(int j = k - 1; j &gt;= 0; j--)&#123; string cur = pre + to_string(j); if(!visited.count(cur))&#123; visited.insert(cur); res += to_string(j); break; &#125; &#125; &#125; return res;&#125; LC764 Largest Plus Sign Problem In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0. What is the largest axis-aligned plus sign of 1s contained in the grid? Return the order of the plus sign. If there is none, return 0. An “axis-aligned plus sign of 1s of order k” has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s. This is demonstrated in the diagrams below. Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s. Examples of Axis-Aligned Plus Signs of Order k: 1234567891011121314151617181920Order 1:000010000Order 2:0000000100011100010000000Order 3:0000000000100000010000111110000100000010000000000 Example 1: 123456789Input: N &#x3D; 5, mines &#x3D; [[4, 2]]Output: 2Explanation:1111111111111111111111011In the above grid, the largest plus sign can only be order 2. One of them is marked in bold. Example 2: 1234Input: N &#x3D; 2, mines &#x3D; []Output: 1Explanation:There is no plus sign of order 2, but there is of order 1. Example 3: 1234Input: N &#x3D; 1, mines &#x3D; [[0, 0]]Output: 0Explanation:There is no plus sign, so return 0. Note: N will be an integer in the range [1, 500]. mines will have length at most 5000. mines[i] will be length 2 and consist of integers in the range [0, N-1]. (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.) Think 分别建立上下左右四个方向上的dp数组，然后取四个当中的最小值即可。 Code 123456789101112131415161718192021int orderOfLargestPlusSign(int N, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123; int res = 0; vector&lt;vector&lt;int&gt;&gt; dp(N, vector&lt;int&gt;(N, N)); for(auto mine: mines) dp[mine[0]][mine[1]] = 0; for(int i = 0; i &lt; N; i++)&#123; int l = 0, r = 0, u = 0, d = 0; for(int j = 0, k = N - 1; j &lt; N; j++, k--)&#123; l = dp[i][j] ? l + 1: 0; r = dp[j][i] ? r + 1: 0; u = dp[i][k] ? u + 1: 0; d = dp[k][i] ? d + 1: 0; dp[i][j] = min(dp[i][j], l); dp[j][i] = min(dp[j][i], r); dp[i][k] = min(dp[i][k], u); dp[k][i] = min(dp[k][i], d); &#125; &#125; for (int k = 0; k &lt; N * N; ++k) res = max(res, dp[k / N][k % N]); return res;&#125; LC787 Cheapest Flights Within K Stops Problem There are n cities connected by m flights. Each flight starts from city u and arrives at v with a price w. Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1. 1234567891011121314151617181920Example 1:Input: n &#x3D; 3, edges &#x3D; [[0,1,100],[1,2,100],[0,2,500]]src &#x3D; 0, dst &#x3D; 2, k &#x3D; 1Output: 200Explanation: The graph looks like this:The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.Example 2:Input: n &#x3D; 3, edges &#x3D; [[0,1,100],[1,2,100],[0,2,500]]src &#x3D; 0, dst &#x3D; 2, k &#x3D; 0Output: 500Explanation: The graph looks like this:The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture. Constraints: The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n`` - 1. The size of flights will be in range [0, n * (n - 1) / 2]. The format of each flight will be (src, ``dst``, price). The price of each flight will be in the range [1, 10000]. k is in the range of [0, n - 1]. There will not be any duplicated flights or self cycles. Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code LC Problem Think Code","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}]},{"title":"Union Find","slug":"Union-Find","date":"2020-06-23T23:43:00.000Z","updated":"2020-06-29T23:57:31.294Z","comments":true,"path":"Union-Find/","link":"","permalink":"http://yoursite.com/Union-Find/","excerpt":"","text":"LC128 Longest Consecutive Sequence Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Think 首先将所有的num存进hash set，然后找到每一个连续序列的开头元素（即num - 1不存在的情况），向后判断每一个num + i是否存在，求得此处的最大长度。 Code 123456789101112131415int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; map; for(int num: nums) map.insert(num); int res = 0; for(int num: nums)&#123; if(!map.count(num - 1))&#123; int len = 1, start = num + 1; while(start != INT_MAX &amp;&amp; map.count(start++))&#123; len++; &#125; res = max(res, len); &#125; &#125; return res;&#125; LC399 Evaluate Division Problem ‘[[“a”,“c”],[“b”,“a”],[“a”,“e”],[“a”,“a”],[“x”,“x”]]’ Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries, where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector&lt;double&gt;. According to the example above: 123equations &#x3D; [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values &#x3D; [2.0, 3.0],queries &#x3D; [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. Think 并查集，首先实现两个函数，一个是getParent，用来获取某一个节点的最根部的父节点；另一个是unionNodes，用来合并两个节点，也就是将node1以及所有和node1共parent的节点合并到node2的分支上面，用对应的结果val进行连接。 对于每一个给出的公式，我们首先判断前后两个变量是否出现过： 如果都没有出现过，则均需要新建，node1作为被除数，设值为val，node2作为除数，设值为1，然后将node1连接到node2上； 如果被除数没出现过，除数出现过，则新建被除数，设置被除数的值为除数对应节点的值乘val； 如果被除数出现过，除数没出现过，则新建除数，设置除数的值为被除数除以val； 如果两者都出现过，则使用unionNodes将两个节点连起来。 对于每一个query，首先判断除数和被除数是否为已知变量，且具有相同的最根父节点（说明可以除），如果不满足条件返回-1，否则返回被除数的值除以除数的值。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Node &#123; double value = 0.0; Node *parent; Node() &#123; parent = this; &#125;&#125;;void UnionNodes(Node *node1, Node *node2, double val, unordered_map&lt;string, Node*&gt;&amp; map)&#123; Node *parent1 = getParent(node1), *parent2 = getParent(node2); double ratio = node2-&gt;value * val / node1-&gt;value; for(auto it = map.begin(); it != map.end(); it++)&#123; if(getParent(it-&gt;second) == parent1)&#123; it-&gt;second-&gt;value *= ratio; &#125; &#125; parent1-&gt;parent = parent2;&#125;Node* getParent(Node* node)&#123; if(node-&gt;parent == node) return node; node-&gt;parent = getParent(node-&gt;parent); return node-&gt;parent;&#125;vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123; unordered_map&lt;string, Node*&gt; map; vector&lt;double&gt; res; for(int i = 0; i &lt; equations.size(); i++)&#123; string s1 = equations[i][0], s2 = equations[i][1]; double val = values[i]; if(!map.count(s1) &amp;&amp; !map.count(s2))&#123; map[s1] = new Node(); map[s2] = new Node(); map[s1]-&gt;value = val; map[s2]-&gt;value = 1; map[s1]-&gt;parent = map[s2]; &#125; else if(!map.count(s2))&#123; map[s2] = new Node(); map[s2]-&gt;value = map[s1]-&gt;value / val; map[s2]-&gt;parent = map[s1]; &#125; else if(!map.count(s1))&#123; map[s1] = new Node(); map[s1]-&gt;value = map[s2]-&gt;value * val; map[s1]-&gt;parent = map[s2]; &#125; else&#123; UnionNodes(map[s1], map[s2], val, map); &#125; &#125; for(auto q: queries)&#123; if(!map.count(q[0]) || !map.count(q[1]) || getParent(map[q[0]]) != getParent(map[q[1]])) res.push_back(-1); else res.push_back(map[q[0]]-&gt;value / map[q[1]]-&gt;value); &#125; return res;&#125; LC547 Friend Circles Problem There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a directfriend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1: 1234567Input: [[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2. Example 2: 1234567Input: [[1,1,0], [1,1,1], [0,1,1]]Output: 1Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. Note: N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1. Think 并查集。主要实现两个部分，一是getRoot，二是对于两个节点应当如何合并。 Code 1234567891011121314151617181920212223242526int getRoot(vector&lt;int&gt; &amp;root, int i)&#123; while(i != root[i])&#123; root[i] = root[root[i]]; i = root[i]; &#125; return root[i];&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n = M.size(); vector&lt;int&gt; root(n); int res = n; for(int i = 0; i &lt; n; i++) root[i] = i; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; if(M[i][j] == 1)&#123; int r1 = getRoot(root, i); int r2 = getRoot(root, j); if(r1 != r2)&#123; res--; root[r2] = r1; &#125; &#125; &#125; &#125; return res;&#125; LC684 Redundant Connection Problem In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v. Example 1: 123456Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 &#x2F; \\2 - 3 Example 2: 123456Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Think 并查集，主要实现的就是并查集的两个函数。 Code 12345678910111213141516vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; root(2001, -1); for(auto edge: edges)&#123; int x = getRoot(root, edge[0]), y = getRoot(root, edge[1]); if(x == y) return edge; root[x] = y; &#125; return &#123;&#125;;&#125;int getRoot(vector&lt;int&gt;&amp; root, int i)&#123; while(root[i] != -1)&#123; i = root[i]; &#125; return i;&#125; LC685 Redundant Connection II Problem In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v. Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: 1234567Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given directed graph will be like this: 1 &#x2F; \\v v2--&gt;3 Example 2: 1234567Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]Output: [4,1]Explanation: The given directed graph will be like this:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Think getRoot函数和上题类似。 主要分三种情况： 无环，但是有入度为2的节点，返回的是后加入的那一条边 有环，且没有入度为2的节点，返回的是最后组成环的那一条边 有环，且有入度为2的节点，返回的是组成环，且是加入入度为2的边的后一条边 因此需要用first和second来记录前后遍历到的两条边，如果当前边对应有root，则说明之前已经有入度为1了，所以需要记录first和second，然后将edge的出节点置为-1. Code 123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; int n = edges.size(); vector&lt;int&gt; root(n + 1, -1), first, second; for(auto &amp;edge: edges)&#123; if(root[edge[1]] == -1)&#123; root[edge[1]] = edge[0]; &#125; else&#123; first = &#123;root[edge[1]], edge[1]&#125;; second = edge; edge[1] = -1; &#125; &#125; for(int i = 0; i &lt;= n; i++) root[i] = i; for(auto &amp;edge: edges)&#123; if(edge[1] == -1) continue; int x = getRoot(root, edge[0]), y = getRoot(root, edge[1]); if(x == y) return first.empty() ? edge: first; root[x] = y; &#125; return second; &#125;int getRoot(vector&lt;int&gt;&amp; root, int i)&#123; while(root[i] != i)&#123; root[i] = root[root[i]]; i = root[i]; &#125; return i;&#125; LC721 Accounts Merge Problem Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order. Example 1: 12345678Input: accounts &#x3D; [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Output: [[&quot;John&quot;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Explanation: The first and third John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.The second John and Mary are different people as none of their email addresses are used by other accounts.We could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], [&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted. Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30]. Think 并查集，首先建立hash map存放root，建立hash map存放每个email对应的name，建立hash表存放所有email对应的序列结果。 首先遍历accounts，构建root和owner数组； 然后遍历accounts，将每一个email连接到对应的root的根节点上； 然后遍历account，将相同root的email存在hash map的相同区域的set里面； 最后将结果的hash map转化成二维数组。 Code 123456789101112131415161718192021222324252627282930313233343536vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123; unordered_map&lt;string, string&gt; root; unordered_map&lt;string, string&gt; owner; unordered_map&lt;string, set&lt;string&gt;&gt; m; vector&lt;vector&lt;string&gt;&gt; res; for(auto account: accounts)&#123; for(int i = 1; i &lt; account.size(); i++)&#123; root[account[i]] = account[i]; owner[account[i]] = account[0]; &#125; &#125; for(auto account: accounts)&#123; string p = getRoot(root, account[1]); for(int i = 2; i &lt; account.size(); i++)&#123; root[getRoot(root, account[i])] = p; &#125; &#125; for(auto account: accounts)&#123; for(int i = 1; i &lt; account.size(); i++)&#123; m[getRoot(root, account[i])].insert(account[i]); &#125; &#125; for(auto a: m)&#123; vector&lt;string&gt; v(a.second.begin(), a.second.end()); v.insert(v.begin(), owner[a.first]); res.push_back(v); &#125; return res;&#125;string getRoot(unordered_map&lt;string, string&gt; &amp;map, string email)&#123; return map[email] == email ? email : getRoot(map, map[email]);&#125; LC794 Valid Tic-Tac-Toe State Problem A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array, and consists of characters &quot; &quot;, &quot;X&quot;, and &quot;O&quot;. The &quot; &quot; character represents an empty square. Here are the rules of Tic-Tac-Toe: Players take turns placing characters into empty squares (&quot; &quot;). The first player always places “X” characters, while the second player always places “O” characters. “X” and “O” characters are always placed into empty squares, never filled ones. The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over. 1234567891011121314151617Example 1:Input: board &#x3D; [&quot;O &quot;, &quot; &quot;, &quot; &quot;]Output: falseExplanation: The first player always plays &quot;X&quot;.Example 2:Input: board &#x3D; [&quot;XOX&quot;, &quot; X &quot;, &quot; &quot;]Output: falseExplanation: Players take turns making moves.Example 3:Input: board &#x3D; [&quot;XXX&quot;, &quot; &quot;, &quot;OOO&quot;]Output: falseExample 4:Input: board &#x3D; [&quot;XOX&quot;, &quot;O O&quot;, &quot;XOX&quot;]Output: true Note: board is a length-3 array of strings, where each string board[i] has length 3. Each board[i][j] is a character in the set {&quot; &quot;, &quot;X&quot;, &quot;O&quot;}. Think 直接检查即可。 Code 12345678910111213141516171819202122232425262728293031bool validTicTacToe(vector&lt;string&gt;&amp; board) &#123; int xCnt = 0, oCnt = 0; for(string s: board)&#123; for(char c: s)&#123; if(c == 'X') xCnt++; else if(c == 'O') oCnt++; &#125; &#125; if(!( (xCnt == oCnt) || (xCnt == oCnt + 1) ) ) return false; bool flag1 = check(board, 'X'); bool flag2 = check(board, 'O'); if(!flag1 &amp;&amp; !flag2) return true; if(flag1) return xCnt == oCnt + 1; if(flag2) return xCnt == oCnt; return false;&#125;bool check(vector&lt;string&gt;&amp; board, char c)&#123; bool flag1 = (board[0][0] == c) &amp;&amp; (board[0][1] == c) &amp;&amp; (board[0][2] == c); bool flag2 = (board[1][0] == c) &amp;&amp; (board[1][1] == c) &amp;&amp; (board[1][2] == c); bool flag3 = (board[2][0] == c) &amp;&amp; (board[2][1] == c) &amp;&amp; (board[2][2] == c); bool flag4 = (board[0][0] == c) &amp;&amp; (board[1][0] == c) &amp;&amp; (board[2][0] == c); bool flag5 = (board[0][1] == c) &amp;&amp; (board[1][1] == c) &amp;&amp; (board[2][1] == c); bool flag6 = (board[0][2] == c) &amp;&amp; (board[1][2] == c) &amp;&amp; (board[2][2] == c); bool flag7 = (board[0][0] == c) &amp;&amp; (board[1][1] == c) &amp;&amp; (board[2][2] == c); bool flag8 = (board[2][0] == c) &amp;&amp; (board[1][1] == c) &amp;&amp; (board[0][2] == c); return flag1 || flag2 || flag3 || flag4 || flag5 || flag6 || flag7 || flag8;&#125; LC821 Shortest Distance to a Character Problem Given a string S and a character C, return an array of integers representing the shortest distance from the character Cin the string. Example 1: 12Input: S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] Note: S string length is in [1, 10000]. C is a single character, and guaranteed to be in string S. All letters in S and C are lowercase. Think 遍历两次数组，分别从前往后和从后往前，记录字符C的位置，然后取i - pos 或者 pos - i即可。 Code 123456789101112131415vector&lt;int&gt; shortestToChar(string S, char C) &#123; int n = S.size(), pos = -n; vector&lt;int&gt; res(n); for(int i = 0; i &lt; n; i++)&#123; if(S[i] == C) pos = i; res[i] = i - pos; &#125; for(int i = pos - 1; i &gt;= 0; i--)&#123; if(S[i] == C) pos = i; res[i] = min(res[i], pos - i); &#125; return res;&#125; LC869 Reordered Power of 2 Problem Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2. Example 1: 12Input: 1Output: true Example 2: 12Input: 10Output: false Example 3: 12Input: 16Output: true Example 4: 12Input: 24Output: false Example 5: 12Input: 46Output: true Note: 1 &lt;= N &lt;= 10^9 Think 遍历所有可能的2的幂次，如果n为2的幂次的重排列，则其每个数字出现的个数应当是相同的。 Code 1234567891011121314151617181920212223bool reorderedPowerOf2(int N) &#123; int *cur = getCount(N); for(int i = 0; i &lt; 32; i++)&#123; if(equalArr(cur, getCount(1 &lt;&lt; i))) return true; &#125; return false;&#125;int* getCount(int n)&#123; int *res = new int[10]; while(n &gt; 0)&#123; res[n % 10]++; n /= 10; &#125; return res;&#125;bool equalArr(int *a1, int *a2)&#123; for(int i = 0; i &lt; 10; i++)&#123; if(a1[i] != a2[i]) return false; &#125; return true;&#125; Review 并查集主要两个函数：getRoot，unionFind getRoot的写法固定，即： 123string getRoot(vector&lt;int&gt; &amp;root, int i)&#123; return root[i] == i ? i : getRoot(root, root[i]);&#125; unionFind函数主要负责判断给定的两个节点是否有相同的root，如果没有则需要将其中一个节点的root值设为另一个节点。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://yoursite.com/tags/Union-Find/"}]},{"title":"Two Pointer(2)","slug":"Two-Pointer-2","date":"2020-06-20T00:04:00.000Z","updated":"2020-06-23T23:42:00.785Z","comments":true,"path":"Two-Pointer-2/","link":"","permalink":"http://yoursite.com/Two-Pointer-2/","excerpt":"","text":"LC28 Implement strStr() Problem Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;Output: 2 Example 2: 12Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Think KMP，参见KMP Code 12345678910111213141516171819202122232425262728293031int strStr(string haystack, string needle) &#123; vector&lt;int&gt; next = getNext(needle); int m = haystack.size(), n = needle.size(); int i = 0, j = 0; while(i &lt; m &amp;&amp; j &lt; n)&#123; if(j == -1 || haystack[i] == needle[j])&#123; i++; j++; &#125; else&#123; j = next[j]; &#125; &#125; return j == n ? i - j: -1;&#125;vector&lt;int&gt; getNext(string needle)&#123; int n = needle.size(); vector&lt;int&gt; next(n, -1); int k = -1, j = 0; while(j &lt; n - 1)&#123; if(k == -1 || needle[k] == needle[j])&#123; j++; k++; next[j] = k; &#125; else&#123; k = next[k]; &#125; &#125; return next;&#125; LC61 Rotate List Problem Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: 1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL Think 首先确定长度，然后截取第n - k和第n - k - 1个元素，进行置换即可。注意要先判断一下k是否为0，如果为0则直接返回head即可。 Code 12345678910111213141516171819202122ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return NULL; int len = 0; ListNode* node = head; while(node)&#123; len++; node = node-&gt;next; &#125; k = k % len; if(k == 0) return head; node = head; for(int i = 0; i &lt; len - k - 1; i++)&#123; node = node-&gt;next; &#125; ListNode* res = node-&gt;next; node-&gt;next = NULL; ListNode* tail = res; while(tail-&gt;next) tail = tail-&gt;next; tail-&gt;next = head; return res;&#125; LC75 Sort Colors Problem Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Think 设两个指针left和right，所有小于left的下标的数值都是0，大于right的下标的数值都是2.设cur = 0，则当cur &lt;= right的时候： 如果cur对应的数值为0，则交换cur和left对应的值，然后cur和left均右移一位； 如果cur对应的数值为2，则交换cur和right对应的值，然后right左移一位； 否则cur右移一位。 Code 12345678910111213void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int left = 0, right = n - 1, cur = 0; while(cur &lt;= right)&#123; if(nums[cur] == 0)&#123; swap(nums[cur++], nums[left++]); &#125; else if(nums[cur] == 2)&#123; swap(nums[cur], nums[right--]); &#125; else cur++; &#125;&#125; LC80 Remove Duplicates from Sorted Array II Problem Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums &#x3D; [1,1,1,2,2,3],Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.It doesn&#39;t matter what you leave beyond the returned length. Example 2: 12345Given nums &#x3D; [0,0,1,1,1,1,2,3,3],Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.It doesn&#39;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; any modification to nums in your function would be known by the caller.&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Think 双指针，分别表示前一个和前两个的值，注意要从第三个数字开始计算。 Code 1234567891011121314151617int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2) return nums.size(); int i = 2; int p1 = nums[0], p2 = nums[1]; for(int j = 2; j &lt; nums.size(); j++)&#123; int num = nums[j]; if(num == p1 &amp;&amp; num == p2)&#123; continue; &#125; else&#123; nums[i++] = num; &#125; p1 = p2; p2 = num; &#125; return i;&#125; LC86 Partition List Problem Given a linked list and a value x, partition it such that all nodes less than xcome before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 Think 定义两个变量。分别指向小于部分的首节点和大于等于部分的首节点 Code 123456789101112131415161718ListNode* partition(ListNode* head, int x) &#123; ListNode *head1 = new ListNode(0), *head2 = new ListNode(0); ListNode *res1 = head1, *res2 = head2; while(head)&#123; ListNode *node = new ListNode(head-&gt;val); if(head-&gt;val &lt; x)&#123; head1-&gt;next = node; head1 = head1-&gt;next; &#125; else&#123; head2-&gt;next = node; head2 = head2-&gt;next; &#125; head = head-&gt;next; &#125; head1-&gt;next = res2-&gt;next; return res1-&gt;next;&#125; LC88 Merge Sorted Array Problem Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3nums2 &#x3D; [2,5,6], n &#x3D; 3Output: [1,2,2,3,5,6] Think 双指针，从最后一位开始遍历。 Code 1234567891011121314void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1; int k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums1[i] &gt; nums2[j])&#123; nums1[k--] = nums1[i--]; &#125; else&#123; nums1[k--] = nums2[j--]; &#125; &#125; while(i &gt;= 0) nums1[k--] = nums1[i--]; while(j &gt;= 0) nums1[k--] = nums2[j--];&#125; LC141 Linked List Cycle Problem Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head &#x3D; [1,2], pos &#x3D; 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head &#x3D; [1], pos &#x3D; -1Output: falseExplanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Think 快慢指针找环 Code 123456789bool hasCycle(ListNode *head) &#123; ListNode *slow = head, *fast = head; while(slow != NULL &amp;&amp; fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(fast == slow) return true; &#125; return false;&#125; LC142 Linked List Cycle II Problem Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head &#x3D; [1,2], pos &#x3D; 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head &#x3D; [1], pos &#x3D; -1Output: no cycleExplanation: There is no cycle in the linked list. Follow-up: Can you solve it without using extra space? Think 首先用快慢指针确定环的长度len，然后快指针先走len步，之后快慢指针一起走，相遇点就是环的起始点。 Code 12345678910111213141516171819202122232425ListNode *detectCycle(ListNode *head) &#123; int len = 0; ListNode* slow = head, *fast = head; bool flag = false; while(slow != NULL &amp;&amp; fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; len++; if(slow == fast)&#123; flag = true; break; &#125; &#125; if(!flag) return NULL; slow = head; fast = head; for(int i = 0; i &lt; len; i++)&#123; fast = fast-&gt;next; &#125; while(slow != fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; LC344 Reverse String Problem Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] Think 双指针，交换即可。 Code 123456789void reverseString(vector&lt;char&gt;&amp; s) &#123; int n = s.size(); int left = 0, right = n - 1; while(left &lt; right)&#123; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; &#125;&#125; LC345 Reverse Vowels of a String Problem Write a function that takes a string as input and reverse only the vowels of a string. Example 1: 12Input: &quot;hello&quot;Output: &quot;holle&quot; Example 2: 12Input: &quot;leetcode&quot;Output: &quot;leotcede&quot; Note: The vowels does not include the letter “y”. Think 双指针，判断是否为元音字母即可。 Code 123456789101112131415161718192021bool isVowel(char c)&#123; return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';&#125;string reverseVowels(string s) &#123; int n = s.size(); int left = 0, right = n - 1; while(left &lt; right)&#123; if(!isVowel(s[left]))&#123; left++; continue; &#125; if(!isVowel(s[right]))&#123; right--; continue; &#125; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; &#125; return s;&#125; LC457 Circular Array Loop Problem You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward ksteps. Conversely, if it’s negative (-k), move backward k steps. Since the array is circular, you may assume that the last element’s next element is the first element, and the first element’s previous element is the last element. Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle’s length &gt; 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements. Example 1: 123Input: [2,-1,1,2,2]Output: trueExplanation: There is a cycle, from index 0 -&gt; 2 -&gt; 3 -&gt; 0. The cycle&#39;s length is 3. Example 2: 123Input: [-1,2]Output: falseExplanation: The movement from index 1 -&gt; 1 -&gt; 1 ... is not a cycle, because the cycle&#39;s length is 1. By definition the cycle&#39;s length must be greater than 1. Example 3: 123Input: [-2,1,-1,-2,-2]Output: falseExplanation: The movement from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle, because movement from index 1 -&gt; 2 is a forward movement, but movement from index 2 -&gt; 1 is a backward movement. All movements in a cycle must follow a single direction. Note: -1000 ≤ nums[i] ≤ 1000 nums[i] ≠ 0 1 ≤ nums.length ≤ 5000 Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity? Think 快慢指针，首先确定从i节点出发找环，如果i处对应的值为0，说明该节点被访问过（即已经判断过是否在环上），则继续下一个节点，否则： 首先判断当前节点的值和fast节点以及fast的next节点是否符合同正负，当符合时，slow向后一位，fast向后两位，判断是否相等即可。 最后将这个环上所有访问过的节点置为0。 Code 1234567891011121314151617181920212223242526bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; if(nums[i] == 0) continue; int slow = i, fast = getNext(nums, i), val = nums[i]; while(val * nums[fast] &gt; 0 &amp;&amp; val * nums[getNext(nums, fast)] &gt; 0)&#123; if(slow == fast)&#123; if(slow == getNext(nums, slow)) break; return true; &#125; slow = getNext(nums, slow); fast = getNext(nums, getNext(nums, fast)); &#125; slow = i; while(val * nums[slow] &gt; 0)&#123; int next = getNext(nums, slow); nums[slow] = 0; slow = next; &#125; &#125; return false; &#125; int getNext(vector&lt;int&gt;&amp; nums, int i)&#123; int n = nums.size(); return (((nums[i] + i) % n) + n) % n; &#125; LC524 Longest Word in Dictionary through Deleting Problem Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example 1: 12345Input:s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output: &quot;apple&quot; Example 2: 12345Input:s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Output: &quot;a&quot; Note: All the strings in the input will only contain lower-case letters. The size of the dictionary won’t exceed 1,000. The length of all the strings in the input won’t exceed 1,000. Think 对于每一个word，判断是否是s的一个子序列，如果是，则判断是否需要更新即可。 Code 123456789101112131415161718192021222324252627string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; int len = 0; string res = \"\"; for(string word: d)&#123; if(canProduce(s, word))&#123; if(len &lt; word.size())&#123; len = word.size(); res = word; &#125; else if(len == word.size())&#123; res = min(res, word); &#125; &#125; &#125; return res;&#125;bool canProduce(string s, string word)&#123; int n = s.size(), m = word.size(); int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m)&#123; if(s[i] == word[j])&#123; j++; &#125; i++; &#125; return j == m;&#125; Review None","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Two Pointer","slug":"Two-Pointer","permalink":"http://yoursite.com/tags/Two-Pointer/"}]},{"title":"Binary Search(2)","slug":"Binary-Search-2","date":"2020-06-16T08:48:41.000Z","updated":"2020-06-20T00:00:54.478Z","comments":true,"path":"Binary-Search-2/","link":"","permalink":"http://yoursite.com/Binary-Search-2/","excerpt":"","text":"LC209 Minimum Size Subarray Sum Problem Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example: 123Input: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). Think Approach 1 二分法，首先计算前i个元素的和的数组sum，然后对于i在0 - n - 1之间的每一个sum[i]，在sum数组中找第一个大于等于sum[i] + s的数字的下标k，此处对应的即为满足条件的子数组范围[i + 1, k]。 Approach 2 双指针法，首先将左指针指向0，然后每次右移一位right，判断此时能把left最多左移多少位，然后取最短的长度即可。 Code Approach 1 123456789101112131415int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; sum(n + 1, 0); for(int i = 1; i &lt;= n; i++)&#123; sum[i] = sum[i - 1] + nums[i - 1]; &#125; int ans = INT_MAX; for(int i = 0; i &lt; n; i++)&#123; auto bound = lower_bound(sum.begin(), sum.end(), sum[i] + s); if(bound != sum.end())&#123; ans = min(ans, (int)(bound - (sum.begin() + i))); &#125; &#125; return (ans == INT_MAX) ? 0 : ans;&#125; Approach 2 1234567891011121314int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = INT_MAX; int sum = 0; int left = 0; for(int i = 0; i &lt; n; i++)&#123; sum += nums[i]; while(sum &gt;= s)&#123; ans = min(ans, i - left + 1); sum -= nums[left++]; &#125; &#125; return (ans == INT_MAX) ? 0 : ans;&#125; LC230 Kth Smallest Element in a BST Problem Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Example 1: 1234567Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1 3 &#x2F; \\ 1 4 \\ 2Output: 1 Example 2: 123456789Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ 2 4 &#x2F; 1Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Constraints: The number of elements of the BST is between 1 to 10^4. You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Think 二分 + 递归，根据左子树的节点数目决定找左子树还是右子树 Code 12345678910int kthSmallest(TreeNode* root, int k) &#123; int left = getCount(root-&gt;left); if(left == k - 1) return root-&gt;val; else if(left &lt; k - 1) return kthSmallest(root-&gt;right, k - left - 1); else return kthSmallest(root-&gt;left, k);&#125;int getCount(TreeNode* root)&#123; if(!root) return 0; return getCount(root-&gt;left) + getCount(root-&gt;right) + 1;&#125; LC275 H-Index II Problem Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” Example: 123456Input: citations &#x3D; [0,1,3,5,6]Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up: This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity? Think 二分查找 Code 1234567891011int hIndex(vector&lt;int&gt;&amp; citations) &#123; int n = citations.size(); int left = 0, right = n - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(citations[mid] == n - mid) return n - mid; else if(citations[mid] &lt; n - mid) left = mid + 1; else right = mid - 1; &#125; return n - left;&#125; LC278 First Bad Version Problem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: 1234567Given n &#x3D; 5, and version &#x3D; 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. Think 二分查找 Code 123456789int firstBadVersion(int n) &#123; int left = 1, right = n; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(isBadVersion(mid)) right = mid; else left = mid + 1; &#125; return left;&#125; LC300 Longest Increasing Subsequence Problem Given an unsorted array of integers, find the length of longest increasing subsequence. Example: 123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Think Approach 1 DP，dp[i] = max(dp[j] + 1) 对所有满足nums[j] &lt; nums[i]且j &lt; i的元素 Approach 2 二分，首先建立一个数组存放最长递增子序列的结果，对于每一个数字，查找这个数组中第一个大于等于当前数字的数组的下标，并用当前数字去替换（这样替换只会使得可能的最长子序列变长而不可能变短），如果没有这样的下标，则说明需要在数组的最后添加一位，最后返回该数组的总长度即可。 Code Approach 1 1234567891011121314int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &lt; nums[i])&#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; int res = 0; for(int cnt: dp) res = max(res, cnt); return res;&#125; Approach 2 12345678910111213int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp; for(int num: nums)&#123; auto i = lower_bound(dp.begin(), dp.end(), num); if(i == dp.end()) dp.push_back(num); else&#123; int idx = i - dp.begin(); dp[idx] = num; &#125; &#125; return dp.size();&#125; LC349 Intersection of Two Arrays Problem Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]Output: [2] Example 2: 12Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]Output: [9,4] Note: Each element in the result must be unique. The result can be in any order. Think hash set Code 12345678910vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; map; for(int num: nums1) map.insert(num); unordered_set&lt;int&gt; res; for(int num: nums2)&#123; if(map.count(num)) res.insert(num); &#125; vector&lt;int&gt; ans(res.begin(), res.end()); return ans;&#125; LC350 Intersection of Two Arrays II Problem Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]Output: [2,2] Example 2: 12Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Think 类似上一题目，用hash map Code 123456789101112vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int, int&gt; map; for(int num: nums1) map[num]++; vector&lt;int&gt; res; for(int num: nums2)&#123; if(map.count(num) &amp;&amp; map[num] &gt; 0)&#123; res.push_back(num); map[num]--; &#125; &#125; return res;&#125; LC352 Data Stream as Disjoint Intervals Problem Given a data stream input of non-negative integers a1, a2, …, an, …, summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, …, then the summary will be: 12345[1, 1][1, 1], [3, 3][1, 1], [3, 3], [7, 7][1, 3], [7, 7][1, 3], [6, 7] Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream’s size? Think 添加数字的时候首先求出当前数字在intervals数组中的位置，然后判断其是否和查找到的位置的前一个区间有重叠部分，如果有，则取得前一个区间，从这一个区间开始进行合并。每当遇到当前区间和val可合并，则更新start和end（表示合并后的区间），然后将当前区间移除。最后插入这个一个区间即可。 Code 123456789101112131415161718192021222324252627class SummaryRanges &#123;public: vector&lt;vector&lt;int&gt;&gt; intervals; /** Initialize your data structure here. */ SummaryRanges() &#123; &#125; void addNum(int val) &#123; auto cmp = [](vector&lt;int&gt; a, vector&lt;int&gt; b) &#123; return a[0] &lt; b[0]; &#125;; vector&lt;int&gt; cur = &#123;val, val&#125;; auto it = lower_bound(intervals.begin(), intervals.end(), cur, cmp); if(it != intervals.begin() &amp;&amp; (*(it - 1))[1] + 1 &gt;= val) it--; int start = val, end = val; while(it != intervals.end() &amp;&amp; val + 1 &gt;= (*it)[0] &amp;&amp; val - 1 &lt;= (*it)[1])&#123; start = min(start, (*it)[0]); end = max(end, (*it)[1]); it = intervals.erase(it); &#125; intervals.insert(it, &#123;start, end&#125;); &#125; vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123; return intervals; &#125;&#125;; LC354 Russian Doll Envelopes Problem You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example: 123Input: [[5,4],[6,4],[6,7],[2,3]]Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]). Think 将envelops数组按照第一位递增第二位递减的顺序排好，然后在所有的第二位组成的序列中查找最长递增子序列即可。因为此时只要在第二位上递增，第一位一定比上一个要小。 Code 123456789101112131415161718192021struct &#123; bool operator()(vector&lt;int&gt; a, vector&lt;int&gt; b) const&#123; if(a[0] &lt; b[0]) return true; else if(a[0] &gt; b[0]) return false; else return a[1] &gt; b[1]; &#125;&#125; cmp;int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) &#123; if(envelopes.empty()) return 0; sort(envelopes.begin(), envelopes.end(), cmp); vector&lt;int&gt; lis; for(auto e: envelopes)&#123; auto it = lower_bound(lis.begin(), lis.end(), e[1]); if(it == lis.end()) lis.push_back(e[1]); else&#123; int idx = it - lis.begin(); lis[idx] = e[1]; &#125; &#125; return lis.size();&#125; LC363 Max Sum of Rectangle No Larger Than K Problem Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: 1234Input: matrix &#x3D; [[1,0,1],[0,-2,3]], k &#x3D; 2Output: 2 Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k &#x3D; 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? Think 首先对每一列，求这一列到最后某一列处的每一行的和，即sum数组，然后从上往下进行累加。首先设定一个set s存放累加和，对于每一个累加和curSum，查找第一个大于等于curSum - k的值，即这两个curSum对应的下标之间即为要求的最大的矩阵和的范围，如果存在则更新res，最后将当前累加和插入s中。 Code 1234567891011121314151617181920212223int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); int res = INT_MIN; for(int i = 0; i &lt; n; i++)&#123; vector&lt;int&gt; sum(m); for(int j = i; j &lt; n; j++)&#123; for(int t = 0; t &lt; m; t++)&#123; sum[t] += matrix[t][j]; &#125; int curSum = 0; set&lt;int&gt; s; s.insert(0); for(int a: sum)&#123; curSum += a; auto it = s.lower_bound(curSum - k); if(it != s.end()) res = max(res, curSum - *it); s.insert(curSum); &#125; &#125; &#125; return res;&#125; Review 二分查找的很多题目其实只是用二分查找进行了优化，很多时候是用lower_bound和upper_bound来代替二分查找，因此不需要刻意的往二分上去想，应当先想一个正常的方法，然后思考如何用二分去优化。","categories":[],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://yoursite.com/tags/Binary-Search/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Bit Manipulation","slug":"Bit-Manipulation","date":"2020-06-13T06:53:07.000Z","updated":"2020-06-16T08:46:49.628Z","comments":true,"path":"Bit-Manipulation/","link":"","permalink":"http://yoursite.com/Bit-Manipulation/","excerpt":"","text":"LC78 Subsets Problem Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums &#x3D; [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Think 回溯 Code 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; helper(nums, 0, &#123;&#125;, res); return res;&#125;void helper(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt; out, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; int n = nums.size(); if(start == n)&#123; res.push_back(out); return; &#125; out.push_back(nums[start]); helper(nums, start + 1, out, res); out.pop_back(); helper(nums, start + 1, out, res);&#125; LC190 Reverse Bits Problem Reverse bits of a given 32 bits unsigned integer. Example 1: 123Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: 123Input: 11111111111111111111111111111101Output: 10111111111111111111111111111111Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825. Follow up: If this function is called many times, how would you optimize it? Think 遍历uint32_t即可 Code 123456789uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i = 0; i &lt; 32; i++)&#123; res &lt;&lt;= 1; res += n &amp; 1; n &gt;&gt;= 1; &#125; return res;&#125; LC191 Number of 1 Bits Problem Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight). Example 1: 123Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits. Example 2: 123Input: 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit. Example 3: 123Input: 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3 above the input represents the signed integer -3. Follow up: If this function is called many times, how would you optimize it? Think 遍历 Code 12345678int hammingWeight(uint32_t n) &#123; int res = 0; for(int i = 0; i &lt; 32; i++)&#123; if(n &amp; 1) res++; n &gt;&gt;= 1; &#125; return res;&#125; LC201 Bitwise AND of Numbers Range Problem Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: 12Input: [5,7]Output: 4 Example 2: 12Input: [0,1]Output: 0 Think 即相当于求m和n的最大公共前缀 Approach 1 m和n同时右移直至相等 Approach 2 Brian Kernighan’s Algorithm，n &amp; (n - 1)相当于去掉n的最右端的1 Code Approach 1 123456789int rangeBitwiseAnd(int m, int n) &#123; int shift = 0; while(m &lt; n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; shift ++; &#125; return m &lt;&lt; shift;&#125; Approach 2 123456int rangeBitwiseAnd(int m, int n) &#123; while(m &lt; n)&#123; n &amp;= (n - 1); &#125; return n;&#125; LC231 Power of Two Problem Given an integer, write a function to determine if it is a power of two. Example 1: 123Input: 1Output: true Explanation: 20 &#x3D; 1 Example 2: 123Input: 16Output: trueExplanation: 24 &#x3D; 16 Example 3: 12Input: 218Output: false Think Approach 1 (x &amp; (-x)) == x，则说明只有1个1 Approach 2 (x &amp; (x - 1)) == 0，说明只有1个1 Code Approach 1 12345bool isPowerOfTwo(int n) &#123; if(n == 0) return false; long x = (long) n; return (x &amp; (-x)) == x;&#125; Approach 2 12345bool isPowerOfTwo(int n) &#123; if(n == 0) return false; long x = (long) n; return (x &amp; (x - 1)) == 0;&#125; LC268 Missing Number Problem Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Think Approach 1 位运算，将每一位的下标和对应的值异或，最后再和n异或即可 Approach 2 数列求和公式，0 - (n - 1) Code Approach 1 1234567int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int missing = nums.size(); for(int i = 0; i &lt; nums.size(); i++)&#123; missing ^= i ^ nums[i]; &#125; return missing;&#125; Approach 2 1234567891011121314151617int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int pred = n * (n + 1) / 2; int sum = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i]; &#125; return pred - sum;&#125;// ORint missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; sum += (i + 1) - nums[i]; &#125; return sum;&#125; LC318 Maximum Product of Word Lengths Problem Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: 123Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]Output: 16 Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;. Example 2: 123Input: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]Output: 4 Explanation: The two words can be &quot;ab&quot;, &quot;cd&quot;. Example 3: 123Input: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: 0 Explanation: No such pair of words. Think 首先将每一个word转成对应的26位bit数字，然后将数字和对应的word的最长的长度对应存放到hash map里面；遍历hash map，找到对应的bit数字的按位与结果为0的（表示两个字符串没有公共字符），返回两者长度的乘积。 Code 12345678910111213141516171819202122int maxProduct(vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;int, int&gt; map; for(auto word: words)&#123; int bit = changeToBit(word); map[bit] = max(map[bit], (int)word.size()); &#125; int res = 0; for(auto i: map)&#123; for(auto j: map)&#123; if((i.first &amp; j.first) == 0) res = max(res, i.second * j.second); &#125; &#125; return res;&#125;int changeToBit(string s)&#123; int res = 0; for(char c: s)&#123; res |= (1 &lt;&lt; (int)(c - 'a')); &#125; return res;&#125; LC338 Counting Bits Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1: 12Input: 2Output: [0,1,1] Example 2: 12Input: 5Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. Think i和i - 1的按位与之后会消除i的最右端的1，也就是有res[i] = res[i &amp; (i - 1)] + 1，同时i一定比i &amp; (i - 1)要大。 Code 1234567vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num + 1, 0); for(int i = 1; i &lt;= num; i++)&#123; res[i] = res[i &amp; (i - 1)] + 1; &#125; return res;&#125; LC342 Power of Four Problem Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: 12Input: 16Output: true Example 2: 12Input: 5Output: false Follow up: Could you solve it without loops/recursion? Think 即三点： 正数 只有一个1 1的位置为倒数奇数位，即num &amp; 0xaaaaaaaa得出的结果是0 Code 123bool isPowerOfFour(int num) &#123; return (num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0) &amp;&amp; ((num &amp; 0xaaaaaaaa) == 0);&#125; LC371 Sum of Two Integers Problem Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example 1: 12Input: a &#x3D; 1, b &#x3D; 2Output: 3 Example 2: 12Input: a &#x3D; -2, b &#x3D; 3Output: 1 Think 采用的是递归式的加法，每次将当前结果加上当前进位即可。需要注意的是左移的时候可能会产生左移INT_MIN的问题，会报错，因此需要先用一个long类型的mask处理一下，使其均变为32位的int；最后返回的时候需要判断当前a是否为INT_MAX，如果是INT_MAX，则需要取反。 Code 12345678910int getSum(int a, int b) &#123; long mask = 0xFFFFFFFF; while(b != 0)&#123; int sum = (a ^ b) &amp; mask; int carry = ((a &amp; b) &amp; mask) &lt;&lt; 1; a = sum; b = carry; &#125; return a &lt; INT_MAX ? a : ~(a &amp; mask); &#125; LC389 Find the Difference Problem Given two strings *s* and *t* which consist of only lowercase letters. String *t* is generated by random shuffling string *s* and then add one more letter at a random position. Find the letter that was added in *t*. Example: 123456789Input:s &#x3D; &quot;abcd&quot;t &#x3D; &quot;abcde&quot;Output:eExplanation:&#39;e&#39; is the letter that was added. Think 将s和t都变成26位的unsigned int，然后判断出两者在那一位不同即可。 Code 1234567891011121314151617char findTheDifference(string s, string t) &#123; uint32_t x1 = change(s), x2 = change(t); uint32_t x = x1 ^ x2; int cnt = 0; while(x)&#123; cnt++; x &gt;&gt;= 1; &#125; return 'a' + cnt - 1;&#125;uint32_t change(string &amp;s)&#123; uint32_t res = 0; for(auto c: s)&#123; res ^= (1 &lt;&lt; (c - 'a')); &#125; return res;&#125; Review 位操作主要包括：AND OR XOR NOT和左移右移(&lt;&lt; 和 &gt;&gt;)，常用的使用这些运算符实现的操作有： Set union A | B Set intersection A &amp; B Set subtraction A &amp; ~B Set negation ALL_BITS ^ A or ~A Set bit A |= 1 &lt;&lt; bit Clear bit A &amp;= ~(1 &lt;&lt; bit) Test bit (A &amp; 1 &lt;&lt; bit) != 0 Remove last bit of 1 A&amp;-A or A&amp;~(A-1) or x^(x&amp;(x-1)) Remove last bit A&amp;(A-1) Get all 1-bits ~0","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://yoursite.com/tags/Bit-Manipulation/"}]},{"title":"Sliding Window","slug":"Sliding-Window","date":"2020-06-11T15:37:07.000Z","updated":"2020-06-13T05:57:58.089Z","comments":true,"path":"Sliding-Window/","link":"","permalink":"http://yoursite.com/Sliding-Window/","excerpt":"","text":"LC239 Sliding Window Maximum Problem Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Follow up: Could you solve it in linear time? Example: 123456789101112Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], and k &#x3D; 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Constraints: 1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 1 &lt;= k &lt;= nums.length Think 首先将整个数组按k个一组，分成多个block，设left[i]表示从当前block的左端到当前位置的最大值，right[i]表示从当前block的右端到当前位置的最大值，对于每一个windows [i, i + k - 1]来说，windows内的最大值就是left[i + k - 1]和right[i]中的较大值。 Code 123456789101112131415161718vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; res(n - k + 1, 0); vector&lt;int&gt; left(n, 0), right(n, 0); left[0] = nums[0]; right[n - 1] = nums[n - 1]; for(int i = 1; i &lt; n; i++)&#123; if(i % k == 0) left[i] = nums[i]; else left[i] = max(nums[i], left[i - 1]); int j = n - 1 - i; if((j + 1) % k == 0) right[j] = nums[j]; else right[j] = max(nums[j], right[j + 1]); &#125; for(int i = 0; i &lt;= n - k; i++)&#123; res[i] = max(left[i + k - 1], right[i]); &#125; return res;&#125; LC424 Longest Repeating Character Replacement Problem Given a string s that consists of only uppercase English letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character. Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations. Note: Both the string’s length and k will not exceed 104. Example 1: 12345678Input:s &#x3D; &quot;ABAB&quot;, k &#x3D; 2Output:4Explanation:Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa. Example 2: 123456789Input:s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1Output:4Explanation:Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.The substring &quot;BBBB&quot; has the longest repeating letters, which is 4. Think 窗口为[left, right]，右移一位right，取得此时的最大count，然后将多余的左边的字符删去，右移left，比较此时的长度值。 p.s. 这里不需要关注maxCount对应的字符是哪一个，maxCount可能在某一次的序列中是invalid的，但是这个maxCount在之前某一次的子串中是符合要求的，因此并不需要将maxCount变小。 Code 1234567891011121314int characterReplacement(string s, int k) &#123; int len = s.size(); int m[26] = &#123;0&#125;; int left = 0, maxCount = 0, maxLen = 0; for(int right = 0; right &lt; len; right++)&#123; maxCount = max(maxCount, ++m[s[right] - 'A']); while(right - left + 1 - maxCount &gt; k)&#123; m[s[left] - 'A']--; left++; &#125; maxLen = max(maxLen, right - left + 1); &#125; return maxLen;&#125; LC480 Sliding Window Median Problem Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: 12[2,3,4] , the median is &#96;3[2,3]&#96;, the median is &#96;(2 + 3) &#x2F; 2 &#x3D; 2.5 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. 12345678Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note: You may assume k is always valid, ie: k is always smaller than input array’s size for non-empty array. Answers within 10^-5 of the actual value will be accepted as correct. Think Approach 1 Two Heap，使用一个最大堆lo和一个最小堆hi，始终保持两者的平衡，即lo的大小要么等于hi要么比hi大1；删除元素的时候并不真的删除，而是先存入hash map中，最后将两个堆中所有顶端元素为待删除元素的pop出去 Approach 2 multiset，有序，使用mid表示当前窗口的中间下标。每次插入新数字的时候，如果新插入的数字比中间值大或者相等，则mid不变，如果比中间值小，则mid–；删除旧数字的时候，如果旧数字比中间值大，则mid不变，否则mid++。 p.s. 这里是否包含等于号的原因在于C++在插入同值的数字进multiset的时候会优先插在尾端，所以对于相等的情况，插入并不会改变mid在[k / 2]的位置；而在删除的时候，由于我们是删除第一个等于这个值的数字，这就会导致mid变成[k / 2] - 1，因此对于相等的情况，mid需要自增1。 Code Approach 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; lo; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; hi; unordered_map&lt;int, int&gt; map; int n = nums.size(); vector&lt;double&gt; res; int i = 0; while(i &lt; k) lo.push(nums[i++]); for(int j = 0; j &lt; k / 2; j++)&#123; hi.push(lo.top()); lo.pop(); &#125; while(true)&#123; res.push_back(k &amp; 1 ? lo.top(): ((double)lo.top() + (double)hi.top()) * 0.5); if(i &gt;= nums.size()) break; int to_remove = nums[i - k], to_add = nums[i++]; int balance = to_remove &lt;= lo.top() ? -1: 1; map[to_remove]++; if(!lo.empty() &amp;&amp; to_add &lt;= lo.top())&#123; balance++; lo.push(to_add); &#125; else&#123; balance--; hi.push(to_add); &#125; if(balance &lt; 0)&#123; balance++; lo.push(hi.top()); hi.pop(); &#125; if(balance &gt; 0)&#123; balance--; hi.push(lo.top()); lo.pop(); &#125; while(map[lo.top()])&#123; map[lo.top()]--; lo.pop(); &#125; while(!hi.empty() &amp;&amp; map[hi.top()])&#123; map[hi.top()]--; hi.pop(); &#125; &#125; return res;&#125; Approach 2 1234567891011121314151617181920vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;double&gt; res; multiset&lt;int&gt; windows(nums.begin(), nums.begin() + k); auto mid = next(windows.begin(), k / 2); for(int i = k; ; i++)&#123; res.push_back(((double)(*mid) + (double)*next(mid, k % 2 - 1)) * 0.5); if(i == nums.size()) break; windows.insert(nums[i]); if(nums[i] &lt; *mid)&#123; mid--; &#125; if(nums[i - k] &lt;= *mid)&#123; mid++; &#125; windows.erase(windows.lower_bound(nums[i - k])); &#125; return res;&#125; LC567 Permutation in String Problem Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string. Example 1: 123Input: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;Output: TrueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;). Example 2: 12Input:s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;Output: False Constraints: The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000]. Think 用int数组当作map存储当前m长度下的每个字符的数目，每次滑动窗口的时候，判断此时是否产生的新的匹配字符数或者已经匹配好的字符数被取消。 Code 12345678910111213141516171819202122232425bool checkInclusion(string s1, string s2) &#123; int m = s1.size(), n = s2.size(); if(m &gt; n) return false; int left = 0, right = m - 1; int map1[26] = &#123;0&#125;, map2[26] = &#123;0&#125;; for(int i = 0; i &lt; m; i++)&#123; map1[s1[i] - 'a']++; map2[s2[i] - 'a']++; &#125; int count = 0; for(int i = 0; i &lt; 26; i++)&#123; if(map1[i] == map2[i]) count++; &#125; for(int i = 0; i &lt; n - m; i++)&#123; int l = s2[i] - 'a', r = s2[i + m] - 'a'; if(count == 26) return true; map2[r]++; if(map2[r] == map1[r]) count++; else if(map2[r] == map1[r] + 1) count--; map2[l]--; if(map2[l] == map1[l]) count++; else if(map2[l] == map1[l] - 1) count--; &#125; return count == 26;&#125; LC1020 Number of Enclaves Problem Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land) A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves. Example 1: 1234Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]Output: 3Explanation: There are three 1s that are enclosed by 0s, and one 1 that isn&#39;t enclosed because its on the boundary. Example 2: 1234Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]Output: 0Explanation: All 1s are either on the boundary or can reach the boundary. Think BFS Code 1234567891011121314151617181920212223242526int numEnclaves(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; queue&lt;vector&lt;int&gt;&gt; q; int m = A.size(), n = A[0].size(); int res = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(A[i][j] == 1)&#123; res++; if(i == 0 || j == 0 || i == m - 1 || j == n - 1) q.push(&#123;i, j&#125;); &#125; &#125; &#125; int dx[] = &#123;1, 0, -1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;; while(!q.empty())&#123; vector&lt;int&gt; cur = q.front(); q.pop(); if(cur[0] &lt; 0 || cur[0] &gt;= m || cur[1] &lt; 0 || cur[1] &gt;= n || A[cur[0]][cur[1]] != 1) continue; A[cur[0]][cur[1]] = 0; res--; for(int i = 0; i &lt; 4; i++)&#123; q.push(&#123;cur[0] + dx[i], cur[1] + dy[i]&#125;); &#125; &#125; return res;&#125; LC1034 Coloring A Border Problem Given a 2-dimensional grid of integers, each value in the grid represents the color of the grid square at that location. Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions. The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column). Given a square at location (r0, c0) in the grid and a color, color the border of the connected component of that square with the given color, and return the final grid. Example 1: 12Input: grid &#x3D; [[1,1],[1,2]], r0 &#x3D; 0, c0 &#x3D; 0, color &#x3D; 3Output: [[3, 3], [3, 2]] Example 2: 12Input: grid &#x3D; [[1,2,2],[2,3,2]], r0 &#x3D; 0, c0 &#x3D; 1, color &#x3D; 3Output: [[1, 3, 3], [2, 3, 3]] Example 3: 12Input: grid &#x3D; [[1,1,1],[1,1,1],[1,1,1]], r0 &#x3D; 1, c0 &#x3D; 1, color &#x3D; 2Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]] Note: 1 &lt;= grid.length &lt;= 50 1 &lt;= grid[0].length &lt;= 50 1 &lt;= grid[i][j] &lt;= 1000 0 &lt;= r0 &lt; grid.length 0 &lt;= c0 &lt; grid[0].length 1 &lt;= color &lt;= 1000 Think BFS，向四个方向遍历，只要有一个方向是数组边界或者不是给定的颜色，则说明当前点是border，不需要再向外扩展了。 Code 123456789101112131415161718192021222324252627282930vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; res; unordered_set&lt;int&gt; component; component.insert(r0 * n + c0); queue&lt;vector&lt;int&gt;&gt; q; q.push(&#123;r0, c0&#125;); int dx[] = &#123;1, 0, -1, 0&#125;; int dy[] = &#123;0, 1, 0, -1&#125;; while(!q.empty())&#123; vector&lt;int&gt; cur = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++)&#123; int x = cur[0] + dx[i], y = cur[1] + dy[i]; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == grid[r0][c0])&#123; if(!component.count(x * n + y))&#123; component.insert(x * n + y); q.push(&#123;x, y&#125;); &#125; &#125; else&#123; res.push_back(cur); &#125; &#125; &#125; for(auto b: res)&#123; grid[b[0]][b[1]] = color; &#125; return grid;&#125; LC1037 Valid Boomerang Problem A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang. Example 1: 12Input: [[1,1],[2,3],[3,2]]Output: true Example 2: 12Input: [[1,1],[2,2],[3,3]]Output: false Note: points.length == 3 points[i].length == 2 0 &lt;= points[i][j] &lt;= 100 Think 斜率计算 Code 123bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; return (points[0][1] - points[1][1]) * (points[0][0] - points[2][0]) != (points[0][1] - points[2][1]) * (points[0][0] - points[1][0]);&#125; LC1138 Alphabet Board Path Problem On an alphabet board, we start at position (0, 0), corresponding to character board[0][0]. Here, board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;], as shown in the diagram below. We may make the following moves: 'U' moves our position up one row, if the position exists on the board; 'D' moves our position down one row, if the position exists on the board; 'L' moves our position left one column, if the position exists on the board; 'R' moves our position right one column, if the position exists on the board; '!' adds the character board[r][c] at our current position (r, c) to the answer. (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to target in the minimum number of moves. You may return any path that does so. Example 1: 12Input: target &#x3D; &quot;leet&quot;Output: &quot;DDR!UURRR!!DDD!&quot; Example 2: 12Input: target &#x3D; &quot;code&quot;Output: &quot;RR!DDRR!UUL!R!&quot; Constraints: 1 &lt;= target.length &lt;= 100 target consists only of English lowercase letters. Think 求出两个字母的垂直距离和水平距离，根据距离加UDLR即可 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960string alphabetBoardPath(string target) &#123; string res = \"\"; int prevx = 0, prevy = 0; for(auto c: target)&#123; int x = (c - 'a') % 5, y = (c - 'a') / 5; int dx = x - prevx, dy = y - prevy; char prev = prevy * 5 + prevx + 'a'; if(prev != 'z')&#123; if(dx &gt; 0)&#123; for(int i = 0; i &lt; dx; i++)&#123; res += \"R\"; &#125; &#125; else&#123; for(int i = 0; i &lt; (-dx); i++)&#123; res += \"L\"; &#125; &#125; if(dy &gt; 0)&#123; for(int i = 0; i &lt; dy; i++)&#123; res += \"D\"; &#125; &#125; else&#123; for(int i = 0; i &lt; (-dy); i++)&#123; res += \"U\"; &#125; &#125; &#125; else&#123; if(dy &gt; 0)&#123; for(int i = 0; i &lt; dy; i++)&#123; res += \"D\"; &#125; &#125; else&#123; for(int i = 0; i &lt; (-dy); i++)&#123; res += \"U\"; &#125; &#125; if(dx &gt; 0)&#123; for(int i = 0; i &lt; dx; i++)&#123; res += \"R\"; &#125; &#125; else&#123; for(int i = 0; i &lt; (-dx); i++)&#123; res += \"L\"; &#125; &#125; &#125; res += \"!\"; prevx = x; prevy = y; &#125; return res;&#125; LC1145 Binary Tree Coloring Game Problem Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 &lt;= x &lt;= n, and the second player names a value y with 1 &lt;= y &lt;= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false. Example 1: 123Input: root &#x3D; [1,2,3,4,5,6,7,8,9,10,11], n &#x3D; 11, x &#x3D; 3Output: trueExplanation: The second player can choose the node with value 2. Constraints: root is the root of a binary tree with n nodes and distinct node values from 1 to n. n is odd. 1 &lt;= x &lt;= n &lt;= 100 Think 使用一个helper函数遍历数组，同时返回以当前节点为根节点的子树的元素数目。要选择y使得蓝色节点最大化，则y可选的主要有三个： x的左子节点 x的右子节点 x的父节点 对于左右子节点，我们可以分别用全局变量l和r来记录，对于父节点，则蓝色节点的最大数目为n - l - r，最后判断三者中的最大的那一个是否比n / 2大即可。 Code 123456789101112131415int l = -1, r = -1;bool btreeGameWinningMove(TreeNode* root, int n, int x) &#123; helper(root, x); int p = l + r + 1; return max(n - p, max(l, r)) &gt; n / 2;&#125;int helper(TreeNode* root, int x)&#123; if(!root) return 0; int left = helper(root-&gt;left, x), right = helper(root-&gt;right, x); if(root-&gt;val == x)&#123; l = left; r = right; &#125; return left + right + 1;&#125; Review 滑动窗口问题主要分为两类： 定长窗口，一般使用hash表记录每一个元素的出现次数，然后用新窗口内元素的出现次数和原始的进行比较即可，注意要判断两次，一次是新加入的元素匹配从而导致的元素匹配数+1，或者导致元素不匹配从而匹配的元素数目-1；一次是去除元素之后恰好符合匹配元素的数目从而导致的元素匹配数+1，或者导致元素的匹配数-1。 不定长窗口，一般也需要用hash表记录窗口内每一个元素出现的次数，同时需要用while循环将所有不满足要求的left元素从 窗口中移除。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://yoursite.com/tags/Sliding-Window/"}]},{"title":"Divide and Conquer","slug":"Divide-and-Conquer","date":"2020-06-10T00:30:32.000Z","updated":"2020-06-11T15:34:45.936Z","comments":true,"path":"Divide-and-Conquer/","link":"","permalink":"http://yoursite.com/Divide-and-Conquer/","excerpt":"","text":"LC23 Merge k Sorted Lists Problem Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Think 两个有序链表的合并 二分归并，链表两两合并即可 Code 1234567891011121314151617181920212223242526272829303132333435363738ListNode* merge2Lists(ListNode* cur1, ListNode* cur2)&#123; ListNode* cur = new ListNode(); ListNode* node = cur; while(cur1 &amp;&amp; cur2)&#123; if(cur1-&gt;val &lt; cur2-&gt;val)&#123; cur-&gt;next = new ListNode(cur1-&gt;val); cur1 = cur1-&gt;next; cur = cur-&gt;next; &#125; else&#123; cur-&gt;next = new ListNode(cur2-&gt;val); cur2 = cur2-&gt;next; cur = cur-&gt;next; &#125; &#125; if(cur1)&#123; cur-&gt;next = cur1; &#125; if(cur2)&#123; cur-&gt;next = cur2; &#125; return node-&gt;next;&#125;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if(lists.empty()) return NULL; int n = lists.size(); int interval = 1; while (interval &lt; n) &#123; for(int i = 0; i &lt; n - interval; i += interval * 2)&#123; lists[i] = merge2Lists(lists[i], lists[i + interval]); &#125; interval *= 2; &#125; return lists[0];&#125; LC169 Majority Element Problem Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 12Input: [3,2,3]Output: 3 Example 2: 12Input: [2,2,1,1,1,2,2]Output: 2 Think 投票法 Code 12345678910111213int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int res = nums[0]; int cnt = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; if(nums[i] != res) cnt--; else cnt++; if(cnt == 0)&#123; res = nums[i]; cnt = 1; &#125; &#125; return res;&#125; LC215 Kth Largest Element in an Array Problem Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: 12Input: [3,2,1,5,6,4] and k &#x3D; 2Output: 5 Example 2: 12Input: [3,2,3,1,2,4,5,5,6] and k &#x3D; 4Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. Think 最大堆 Code 12345int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; q(nums.begin(), nums.end()); for(int i = 0; i &lt; k - 1; i++) q.pop(); return q.top();&#125; LC218 The Skyline Problem Problem A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] Think 归并，首先计算左边n/2的部分的skyline，然后计算右边n/2部分的skyline，然后将它们两个合并，合并的主要方法如下： 取得当前最左的那个节点 判断当前的最大高度应该为多少，即取此时的leftY和rightY的最大值 如果最大值发生变化，则需要一个点去表明，需要添加一个点，否则不需要 添加点的时候需要判断结果数组里是否已经存在当前的横坐标，如果存在则直接更新对应的高度即可，否则需要添加进结果数组 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; if(buildings.empty()) return &#123;&#125;; sort(buildings.begin(), buildings.end()); return helper(buildings, 0, buildings.size() - 1);&#125;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; buildings, int start, int end) &#123; if(start == end) return &#123;&#123;buildings[start][0], buildings[start][2]&#125;, &#123;buildings[start][1], 0&#125;&#125;; int mid = start + (end - start) / 2; vector&lt;vector&lt;int&gt;&gt; left = helper(buildings, start, mid); vector&lt;vector&lt;int&gt;&gt; right = helper(buildings, mid + 1, end); vector&lt;vector&lt;int&gt;&gt; res; int nL = left.size(), nR = right.size(); int leftY = 0, rightY = 0, curY = 0, maxY = 0; int pL = 0, pR = 0, x = 0; while(pL &lt; nL &amp;&amp; pR &lt; nR)&#123; vector&lt;int&gt; pointL = left[pL]; vector&lt;int&gt; pointR = right[pR]; if(pointL[0] &lt; pointR[0])&#123; x = pointL[0]; leftY = pointL[1]; pL++; &#125; else&#123; x = pointR[0]; rightY = pointR[1]; pR++; &#125; maxY = max(leftY, rightY); if(curY != maxY)&#123; if(res.empty() || res.back()[0] != x) res.push_back(&#123;x, maxY&#125;); else res.back()[1] = maxY; curY = maxY; &#125; &#125; while(pL &lt; nL)&#123; vector&lt;int&gt; point = left[pL++]; x = point[0]; leftY = point[1]; if(curY != leftY)&#123; if(res.empty() || res.back()[0] != x) res.push_back(&#123;x, leftY&#125;); else res.back()[1] = leftY; curY = leftY; &#125; &#125; while(pR &lt; nR)&#123; vector&lt;int&gt; point = right[pR++]; x = point[0]; rightY = point[1]; if(curY != rightY)&#123; if(res.empty() || res.back()[0] != x) res.push_back(&#123;x, rightY&#125;); else res.back()[1] = rightY; curY = rightY; &#125; &#125; return res;&#125; LC240 Search a 2D Matrix II Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Think 从左下角开始查找，偏小则向右，偏大则向上 Code 12345678910111213bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int i = m - 1, j = 0; int cur; while(i &gt;= 0 &amp;&amp; j &lt; n)&#123; cur = matrix[i][j]; if(cur &lt; target) j++; else if(cur &gt; target) i--; else return true; &#125; return false;&#125; LC241 Different Ways to Add Parentheses Problem Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) &#x3D; 0 (2-(1-1)) &#x3D; 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) &#x3D; -34 ((2*3)-(4*5)) &#x3D; -14 ((2*(3-4))*5) &#x3D; -10 (2*((3-4)*5)) &#x3D; -10 (((2*3)-4)*5) &#x3D; 10 Think 遍历input，对每一个符号两端的字符串进行计算，得出所有可能的值 Code 12345678910111213141516vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; int n = input.size(); for(int i = 0; i &lt; n; i++)&#123; if(ispunct(input[i]))&#123; for(auto first: diffWaysToCompute(input.substr(0, i)))&#123; for(auto second: diffWaysToCompute(input.substr(i + 1)))&#123; if(input[i] == '+') res.push_back(first + second); else if(input[i] == '-') res.push_back(first - second); else res.push_back(first * second); &#125; &#125; &#125; &#125; return res.empty() ? vector&lt;int&gt;&#123;stoi(input)&#125;: res;&#125; LC282 Expression Add Operators Problem Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Example 1: 12Input: num &#x3D; &quot;123&quot;, target &#x3D; 6Output: [&quot;1+2+3&quot;, &quot;1*2*3&quot;] Example 2: 12Input: num &#x3D; &quot;232&quot;, target &#x3D; 8Output: [&quot;2*3+2&quot;, &quot;2+3*2&quot;] Example 3: 12Input: num &#x3D; &quot;105&quot;, target &#x3D; 5Output: [&quot;1*0+5&quot;,&quot;10-5&quot;] Example 4: 12Input: num &#x3D; &quot;00&quot;, target &#x3D; 0Output: [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;] Example 5: 12Input: num &#x3D; &quot;3456237490&quot;, target &#x3D; 9191Output: [] Think 递归，分三种情况，如果是乘法的话使用prevDiff即可，curNum = curNum - prevDiff + prevDiff * val Code 12345678910111213141516171819202122232425262728293031323334vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; res; string each = \"\"; dfs(num, target, 0, 0, 0, each, res); return res;&#125;void dfs(string&amp; num, int&amp; target, int at, ll total, ll lastop, string&amp; each, vector&lt;string&gt;&amp; res)&#123; if(at &gt;= num.size())&#123; if(total == target)&#123; res.push_back(each); return; &#125; &#125; for(int i = at; i &lt; num.size(); i++)&#123; string val = num.substr(at, i - at + 1); if(val[0] == '0' &amp;&amp; val.size() &gt; 1) break; if(at == 0)&#123; each = val; dfs(num, target, i + 1, stol(val), stol(val), each, res); each = \"\"; &#125;else&#123; int len = each.size(); each += \"+\" + val; dfs(num, target, i + 1, total + stol(val), stol(val), each, res); each.resize(len); each += \"-\" + val; dfs(num, target, i + 1, total - stol(val), stol(val) * -1, each, res); each.resize(len); each += \"*\" + val; dfs(num, target, i + 1, total - lastop + lastop * stol(val), lastop * stol(val), each, res); each.resize(len); &#125; &#125;&#125; LC312 Burst Balloons Problem Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: 1234Input: [3,1,5,8]Output: 167 Explanation: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 Think DP，设dp[i, j]表示nums[i, j]部分的最大结果，则有 dp[i, j] = max(dp[i, k - 1] + dp[k + 1, j] + nums[k] * nums[i - 1] * nums[j + 1]), for all k &lt;= j and k &gt;= i p.s. 遍历顺序，需要先遍历小区间，再遍历大区间，所以遍历顺序应当是区间j - i + 1的从小到大的顺序。 Code 123456789101112131415int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2)); for(int len = 1; len &lt;= n; len++)&#123; for(int i = 1; i &lt;= n - len + 1; i++)&#123; int j = i + len - 1; for(int k = i; k &lt;= j; k++)&#123; dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j + 1]); &#125; &#125; &#125; return dp[1][n];&#125; LC315 Count of Smaller Numbers After Self Problem You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: 1234567Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element. Think 二分搜索法，从数组最后开始遍历，遍历的时候将当前值插入新数组中，使得新数组有序，则插入的位置就是这一位数字对应的结果，因为此时数组内的所有数字都是在这位数字之后的，只要比这个数字小的都会在新数组中排在这个数组之前。 Code 123456789101112131415vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; t, res(n, 0); for(int i = n - 1; i &gt;= 0; i--)&#123; int left = 0, right = t.size(); while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[i] &gt; t[mid]) left = mid + 1; else right = mid; &#125; res[i] = left; t.insert(t.begin() + left, nums[i]); &#125; return res;&#125; LC327 Count of Range Sum Problem Given an integer array nums, return the number of range sums that lie in [lower, upper]inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j(i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: 123Input: nums &#x3D; [-2,5,-1], lower &#x3D; -2, upper &#x3D; 2,Output: 3 Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2. Think 首先建立multiset对所有sums[0…i]进行排序，同时查找满足0&lt;=j&lt;i和sums[i] - upper &lt;= sums[j] &lt;= sums[i] - lower的j的所有取值。前者可以用lower_bound查找第一满足条件的j，后者可以用upper_bound查找第一个不满足条件的j，两者相减就是该sums[i]对应的j的个数。 Code 12345678910111213int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(); multiset&lt;long&gt; sums; long sum = 0; int res = 0; sums.insert(0); for(int i = 0; i &lt; n; i++)&#123; sum += nums[i]; res += distance(sums.lower_bound(sum - upper), sums.upper_bound(sum - lower)); sums.insert(sum); &#125; return res;&#125; LC493 Reverse Pairs Problem Given an array nums, we call (i, j) an *important reverse pair* if i &lt; j and nums[i] &gt; 2*nums[j]. You need to return the number of important reverse pairs in the given array. Example1: 12Input: [1,3,2,3,1]Output: 2 Example2: 12Input: [2,4,3,5,1]Output: 3 Note: The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer. Think Approach 1 BIT - 树状数组，即将上一题中的multiset改为BIT，然后将求距离变成getSum，插入数组变成update Approach 2 - TLE D&amp;C，类似merge sort，每次先求左半部分和右半部分的结果，然后求i在左半部分，j在右半部分的结果数目，通过遍历左半部分查找右半部分来实现。 Code Approach 1 123456789101112131415161718192021222324252627int reversePairs(vector&lt;int&gt;&amp; nums) &#123; int res = 0, n = nums.size(); vector&lt;int&gt; v = nums, bits(n + 1); sort(v.begin(), v.end()); unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; n; i++) m[v[i]] = i + 1; for(int i = n - 1; i &gt;= 0; i--)&#123; res += getSum(lower_bound(v.begin(), v.end(), nums[i] / 2.0) - v.begin(), bits); update(m[nums[i]], bits); &#125; return res;&#125;int getSum(int i, vector&lt;int&gt; &amp;bits)&#123; int sum = 0; while(i &gt; 0)&#123; sum += bits[i]; i -= (i &amp; -i); &#125; return sum;&#125;void update(int i, vector&lt;int&gt; &amp;bits)&#123; while(i &lt; bits.size())&#123; bits[i] += 1; i += (i &amp; -i); &#125;&#125; Approach 2 123456789101112131415int reversePairs(vector&lt;int&gt;&amp; nums) &#123; return helper(nums, 0, nums.size() - 1); &#125; int helper(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left &gt;= right) return 0; int mid = left + (right - left) / 2; int res = helper(nums, left, mid) + helper(nums, mid + 1, right); for(int i = left; i &lt;= mid; i++)&#123; int j = mid + 1; while(j &lt;= right &amp;&amp; nums[i] / 2.0 &gt; nums[j]) j++; res += j - mid - 1; &#125; sort(nums.begin() + left, nums.begin() + right + 1); return res; &#125; Review 分治法主要和递归与二分相结合，对于分治法，主要有三种形式： Binary Search Tree-based Binary Indexed Tree-based 12345678910111213141516// 从节点i到数组尾端节点的所有节点的和int getSum(int[] bit, int i) &#123; int sum = 0; while (i &lt; bit.length) &#123; sum += bit[i]; i += i &amp; -i; &#125; return sum;&#125;//在位置i插入一个数字kvoid insert(int[] bit, int i, int k) &#123; while (i &gt; 0) &#123; bit[i] += k; i -= i &amp; -i; &#125;&#125; Merge Sort-based 其主要思想就是：分解数组，通过解决子数组上的子问题来解决整个问题 设数组为nums，nums[i, j]表示nums数组中i到j的部分（包含i和j），T(i, j)表示在子数组nums[i, j]上的子问题的解，则我们最终要解决的问题为T(0, n - 1)。一般有两种可能的情况： Sequential recurrence relation T(i, j) = T(i, j - 1) + C Partition recurrence relation T(i, j) = T(i, m) + T(m + 1, j) + C, where m = (i + j) / 2 如果不同的子问题之间存在重叠的话，则需要保存所有子问题的结果，类似于DP。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://yoursite.com/tags/Divide-and-Conquer/"}]},{"title":"Hash Table(1)","slug":"Hash-Table-1","date":"2020-06-04T14:17:00.000Z","updated":"2020-06-07T13:11:17.873Z","comments":true,"path":"Hash-Table-1/","link":"","permalink":"http://yoursite.com/Hash-Table-1/","excerpt":"","text":"LC1 Two Sum Problem Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Think 将数组改造成hashtable，然后遍历数组，找hashtable中是否有target - nums[i] Code 123456789101112vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); i++)&#123; map[nums[i]] = i; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; if(map.count(nums[i]) &amp;&amp; map[target - nums[i]] &gt; i)&#123; return &#123;i, map[target - nums[i]]&#125;; &#125; &#125; return &#123;-1, -1&#125;;&#125; LC30 Substring with Concatenation of All Words Problem You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: 123456Input: s &#x3D; &quot;barfoothefoobarman&quot;, words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoo&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too. Example 2: 1234Input: s &#x3D; &quot;wordgoodgoodgoodbestword&quot;, words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]Output: [] Think 首先将所有的words存在hash table中，计算所查找的子串的长度以及每个单词的长度和数量。 遍历开头长度为wordSize的子字符串，即第一个可能的起始节点在[0, wordSize - 1]中，设cnt为需要的word的数目。 然后遍历所有的word，如果word在map中存在，则对应的值-1，cnt - 1；如果此时j大于总共所需长度len = n * wordSize，则去找这个对应最开头的那一个长度为wordSize的子串，相当于滑动窗口的左端向右滑动了一位，使map中对应word+1， cnt+1；最后判断此时cnt是否等于0，如果等于0则说明找到一个满足条件的位置， Code 123456789101112131415161718192021222324252627vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; if(words.empty()) return &#123;&#125;; vector&lt;int&gt; res; int n = words.size(); int wordSize = words[0].size(); int len = n * wordSize; if(len &gt; s.size()) return &#123;&#125;; unordered_map&lt;string, int&gt; map; for(auto word: words)&#123; map[word]++; &#125; int cnt = n; for(int i = 0; i &lt; wordSize; i++)&#123; unordered_map&lt;string, int&gt; cur = map; cnt = n; for(int j = i; j + wordSize &lt;= s.size(); j += wordSize)&#123; string word = s.substr(j, wordSize); if(cur[word]-- &gt; 0) cnt--; if(j - len &gt;= 0)&#123; string out = s.substr(j - len, wordSize); if(++cur[out] &gt; 0) cnt++; &#125; if(cnt == 0) res.push_back(j - len + wordSize); &#125; &#125; return res;&#125; LC36 Valid Sudoku Problem Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: 12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2: 123456789101112131415Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9. Think 直接判断每行每列和每个3x3矩阵即可 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool flag = true; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; flag = flag &amp;&amp; isValidSub(board, i, j); if(!flag) return flag; &#125; &#125; for(int i = 0; i &lt; 9; i++)&#123; flag = flag &amp;&amp; isValidCol(board, i); if(!flag) return flag; &#125; for(int i = 0; i &lt; 9; i++)&#123; flag = flag &amp;&amp; isValidRow(board, i); if(!flag) return flag; &#125; return flag;&#125;bool isValidSub(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n)&#123; int map[9] = &#123;0&#125;; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; char c = board[i + m * 3][j + n * 3]; if(isdigit(c))&#123; int cur = c - '1'; if(map[cur] == 0) map[cur]++; else&#123; return false; &#125; &#125; &#125; &#125; return true;&#125;bool isValidCol(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m)&#123; int map[9] = &#123;0&#125;; for(int i = 0; i &lt; 9; i++)&#123; char c = board[i][m]; if(isdigit(c))&#123; int cur = c - '1'; if(map[cur] == 0) map[cur]++; else&#123; return false; &#125; &#125; &#125; return true;&#125;bool isValidRow(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m)&#123; int map[9] = &#123;0&#125;; for(int i = 0; i &lt; 9; i++)&#123; char c = board[m][i]; if(isdigit(c))&#123; int cur = c - '1'; if(map[cur] == 0) map[cur]++; else&#123; return false; &#125; &#125; &#125; return true;&#125; LC37 Sudoku Solver Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character '.'. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Think 回溯递归，判断当前填写是否合法 Code 12345678910111213141516171819202122232425262728293031323334void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; helper(board, 0, 0);&#125;bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n)&#123; if(m == 9) return true; if(n == 9) return helper(board, m + 1, 0); if(board[m][n] != '.') return helper(board, m, n + 1); for(char c = '1'; c &lt;= '9'; c++)&#123; if(isValid(board, m, n, c))&#123; board[m][n] = c; if(helper(board, m, n + 1)) return true; board[m][n] = '.'; &#125; &#125; return false;&#125;bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n, char val)&#123; for(int i = 0; i &lt; 9; i++)&#123; if(board[m][i] == val) return false; &#125; for(int i = 0; i &lt; 9; i++)&#123; if(board[i][n] == val) return false; &#125; int row = m - m % 3, col = n - n % 3; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; if(board[row + i][col + j] == val) return false; &#125; &#125; return true;&#125; LC76 Minimum Window Substring Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: 12Input: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;Output: &quot;BANC&quot; Note: If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Think hash table + 滑动窗口 首先将t中所有的字母都存在hash table中，然后预处理字符串s，删去其中所有的不存在于t中的字符，转化为包含下标和字符的数组； 设置滑动窗口为[l, r]，判断r处的字符是否在t中，且是否有剩余的容量，如果恰好容量到达t中该字符的数目，则已匹配好的字符数目formed ++；然后对左端的l进行右移处理：如果formed == required，则可以右移l，并将当前的[l, r]存进结果中，然后将l处的字符的数目恢复即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; m; for(auto c: t)&#123; m[c]++; &#125; int required = m.size(); vector&lt;pair&lt;int, char&gt;&gt; filteredS; for(int i = 0; i &lt; s.size(); i++)&#123; char c = s[i]; if(m.count(c))&#123; filteredS.push_back(&#123;i, c&#125;); &#125; &#125; int l = 0, r = 0, formed = 0; unordered_map&lt;char, int&gt; wordCnt; int ans[] = &#123;-1, 0, 0&#125;; while(r &lt; filteredS.size())&#123; char c = filteredS[r].second; wordCnt[c]++; if(m.count(c) &amp;&amp; m[c] == wordCnt[c])&#123; formed++; &#125; while(l &lt;= r &amp;&amp; required == formed)&#123; c = filteredS[l].second; int start = filteredS[l].first; int end = filteredS[r].first; if (ans[0] == -1 || end - start + 1 &lt; ans[0]) &#123; ans[0] = end - start + 1; ans[1] = start; ans[2] = end; &#125; wordCnt[c]--; if(m.count(c) &amp;&amp; wordCnt[c] &lt; m[c]) formed--; l++; &#125; r++; &#125; return ans[0] == -1 ? \"\" : s.substr(ans[1], ans[2] - ans[1] + 1);&#125; LC138 Copy List with Random Pointer Problem A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node. Example 1: 12Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Example 2: 12Input: head &#x3D; [[1,1],[2,1]]Output: [[1,1],[2,1]] Example 3: 12Input: head &#x3D; [[3,null],[3,0],[3,null]]Output: [[3,null],[3,0],[3,null]] Example 4: 123Input: head &#x3D; []Output: []Explanation: Given linked list is empty (null pointer), so return null. Constraints: -10000 &lt;= Node.val &lt;= 10000 Node.random is null or pointing to a node in the linked list. Number of Nodes will not exceed 1000. Think Approach 1 递归+hash table Approach 2 三次遍历，第一次复制节点，插在当前节点之后；第二次赋值random指针；第三次断开链接，注意要恢复原来的链表。 Code Approach 1 12345678910111213Node* copyRandomList(Node* head) &#123; unordered_map&lt;Node*, Node*&gt; m; return helper(head, m);&#125;Node* helper(Node* cur, unordered_map&lt;Node*, Node*&gt;&amp; m)&#123; if(!cur) return NULL; if(m.count(cur)) return m[cur]; Node* node = new Node(cur-&gt;val); m[cur] = node; node-&gt;next = helper(cur-&gt;next, m); node-&gt;random = helper(cur-&gt;random, m); return node;&#125; Approach 2 123456789101112131415161718192021222324Node* copyRandomList(Node* head) &#123; if (!head) return NULL; Node *cur = head; while (cur) &#123; Node *t = new Node(cur-&gt;val); t-&gt;next = cur-&gt;next; cur-&gt;next = t; cur = t-&gt;next; &#125; cur = head; while (cur) &#123; if (cur-&gt;random) cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; cur = cur-&gt;next-&gt;next; &#125; cur = head; Node *res = head-&gt;next; while (cur) &#123; Node *t = cur-&gt;next; cur-&gt;next = t-&gt;next; if (t-&gt;next) t-&gt;next = t-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return res;&#125; LC149 Max Points on a Line Problem Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: 12345678910Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4 Example 2: 1234567891011Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Think 分三部分，首先确定一个点，然后判断和这个点在一条直线上的点的数目（未遍历过的点），其中分解为对于每一个点，都将这个点和初始选择的点构成的直线加入到map中，注意此处需要判断重复点和水平线（或者竖直线）的情况。 p.s.由于double可能存在精度不够的情况，这里采用pair&lt;dx, dy&gt;作为map的key，因此需要先进行化简，即先求最小公约数。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;vector&lt;int&gt;&gt; points;pair&lt;int, int&gt; addLine(int i, int j, int count, int duplicate, map&lt;pair&lt;int, int&gt;, int&gt;&amp; lines, int&amp; horizontal)&#123; int x1 = points[i][0], x2 = points[j][0]; int y1 = points[i][1], y2 = points[j][1]; if(x1 == x2 &amp;&amp; y1 == y2)&#123; duplicate++; &#125; else if(y1 == y2)&#123; horizontal++; count = max(horizontal, count); &#125; else&#123; int dx = x1 - x2, dy = y1 - y2; int g = gcd(dx, dy); dx = dx / g; dy = dy / g; pair&lt;int, int&gt; p = &#123;dx, dy&#125;; if(!lines.count(p)) lines[p] = 1; lines[p]++; count = max(count, lines[p]); &#125; return &#123;count, duplicate&#125;;&#125;int maxPointsThroughI(int i)&#123; map&lt;pair&lt;int, int&gt;, int&gt; lines; int horizontal = 1; int count = 1; int duplicate = 0; for(int j = i + 1; j &lt; points.size(); j++)&#123; auto p = addLine(i, j, count, duplicate, lines, horizontal); count = p.first; duplicate = p.second; &#125; return count + duplicate;&#125;int gcd(int x, int y)&#123; if(y == 0) return x; else return gcd(y, x % y);&#125;int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; this-&gt;points = points; int n = points.size(); if(n &lt; 3) return n; int res = 1; for(int i = 0; i &lt; n; i++)&#123; res = max(res, maxPointsThroughI(i)); &#125; return res;&#125; LC166 Fraction to Recurring Decimal Problem Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: 12Input: numerator &#x3D; 1, denominator &#x3D; 2Output: &quot;0.5&quot; Example 2: 12Input: numerator &#x3D; 2, denominator &#x3D; 1Output: &quot;2&quot; Example 3: 12Input: numerator &#x3D; 2, denominator &#x3D; 3Output: &quot;0.(6)&quot; Think 首先判断结果的正负，然后将除数和被除数都转变为long型的正数，求出整数部分和余数remainder。 如果remainder = 0，说明为整数，直接返回即可； 如果remainder不为0，则建立一个hash table，存放每一个remainder对应在res的什么位置；当remainder不等于0时循环：如果此时hash table中存在当前remainder，说明之前遇到过这个remainder，也就是产生了循环，因此直接去hash table中找上一次遇到这个remainder的开始的位置，在那个地方插入左括号，res最右端插入右括号，返回即可；否则，记录当前remainder的位置，remainder乘10，然后将这一位的结果存入res，remainder变成这一位除完的余数。 Code 123456789101112131415161718192021222324string fractionToDecimal(int numerator, int denominator) &#123; if(numerator == 0) return \"0\"; string res = \"\"; if(numerator &lt; 0 ^ denominator &lt; 0) res += \"-\"; long dividend = abs(numerator); long divisor = abs(denominator); res += to_string(dividend / divisor); long reminder = dividend % divisor; if(reminder == 0) return res; res += \".\"; unordered_map&lt;long, int&gt; m; while(reminder != 0)&#123; if(m.count(reminder))&#123; res.insert(res.begin() + m[reminder], '('); res += \")\"; break; &#125; m[reminder] = res.size(); reminder *= 10; res += to_string(reminder / divisor); reminder = reminder % divisor; &#125; return res;&#125; LC187 Repeated DNA Sequences Problem All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: 123Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] Think 滑动窗口+hash table，注意substr的复杂度为O(L)，其中L为截取的长度。 Code 123456789101112131415vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; int n = s.size(); unordered_set&lt;string&gt; strSet; set&lt;string&gt; res; string str = s.substr(0, 10); strSet.insert(str); for(int i = 1; i &lt;= n - 10; i++)&#123; str.erase(str.begin()); str += s[i + 9]; if(strSet.count(str)) res.insert(str); else strSet.insert(str); &#125; vector&lt;string&gt; ans(res.begin(), res.end()); return ans;&#125; LC204 Count Primes Problem Count the number of prime numbers less than a non-negative number, *n*. Example: 123Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Think 设定一个长度为n的数组，每一位表示当前下标对应的数字处是否为质数。遍历数组，如果当前数字为质数，则将所有它的倍数都置为true。统计这个数组中false的数目即可。 Code 12345678910111213141516int countPrimes(int n) &#123; if(n &lt;= 2) return 0; vector&lt;bool&gt; passed(n, false); int sum = 1; int upper = sqrt(n); for(int i = 3; i &lt; n; i += 2)&#123; if(!passed[i])&#123; sum++; if(i &gt; upper) continue; for(int j = i * i; j &lt; n; j += i)&#123; passed[j] = true; &#125; &#125; &#125; return sum;&#125; LC205 Isomorphic Strings Problem Given two strings *s* and *t*, determine if they are isomorphic. Two strings are isomorphic if the characters in *s* can be replaced to get *t*. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 12Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;Output: true Example 2: 12Input: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;Output: false Example 3: 12Input: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;Output: true Note: You may assume both *s* and *t* have the same length. Think 首先建立数组m1和m2，其包含了s和t里面的每个字符串和下标的对应关系。如果当前字符串s在m1中对应的下标和字符串t在m2中对应的下标不一致，则说明这当中某一个字符出现在了别的地方，也就是不满足要求的一一对应的关系，返回false，否则记录当前的字符和下标。 Code 12345678910bool isIsomorphic(string s, string t) &#123; int n = s.size(); vector&lt;int&gt; m1(256, -1), m2(256, -1); for(int i = 0; i &lt; n; i++)&#123; if(m1[s[i]] != m2[t[i]]) return false; m1[s[i]] = i; m2[t[i]] = i; &#125; return true;&#125; LC217 Contains Duplicate Problem Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: 12Input: [1,2,3,1]Output: true Example 2: 12Input: [1,2,3,4]Output: false Example 3: 12Input: [1,1,1,3,3,4,3,2,4,2]Output: true Think hash table Code 12345678bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; s; for(auto n: nums)&#123; if(s.count(n)) return true; s.insert(n); &#125; return false;&#125; LC219 Contains Duplicate II Problem Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: 12Input: nums &#x3D; [1,2,3,1], k &#x3D; 3Output: true Example 2: 12Input: nums &#x3D; [1,0,1,1], k &#x3D; 1Output: true Example 3: 12Input: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2Output: false Think Hash table存放当前数字和下标 Code 1234567891011bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; s; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; if(s.count(nums[i]))&#123; if(i - s[nums[i]] &lt;= k) return true; &#125; s[nums[i]] = i; &#125; return false; &#125; LC242 Valid Anagram Problem Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: 12Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;Output: true Example 2: 12Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? Think Hash table，分别遍历s和t，判断是否还有余量 Code 12345678910111213141516bool isAnagram(string s, string t) &#123; if(s.size() != t.size()) return false; unordered_map&lt;char, int&gt; m; for(auto c: s)&#123; m[c]++; &#125; for(auto c: t)&#123; if(!m.count(c)) return false; else&#123; m[c]--; if(m[c] &lt; 0) return false; &#125; &#125; return true;&#125; LC274 H-Index Problem Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her Npapers have at least h citations each, and the other N − h papers have no more than hcitations each.” Example: 123456Input: citations &#x3D; [3,0,6,1,5]Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Think 首先对论文进行升序排序，设当前遍历到的论文为i，则每次判断第n - 1 - i篇论文（即第i大的论文）的引用数是否大于i，如果大于，则说明要找的临界点还在后面，i++，否则返回i即可。 Code 1234567int hIndex(vector&lt;int&gt;&amp; citations) &#123; sort(citations.begin(), citations.end()); int n = citations.size(); int i = 0; while(i &lt; n &amp;&amp; citations[n - 1 - i] &gt; i) i++; return i;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}]},{"title":"Depth First Search(1)","slug":"Depth-First-Search-1","date":"2020-06-02T21:18:21.000Z","updated":"2020-06-04T14:09:56.315Z","comments":true,"path":"Depth-First-Search-1/","link":"","permalink":"http://yoursite.com/Depth-First-Search-1/","excerpt":"","text":"LC105 Construct Binary Tree from Preorder and Inorder Traversal Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given 12preorder &#x3D; [3,9,20,15,7]inorder &#x3D; [9,3,15,20,7] Return the following binary tree: 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 Think 递归，preorder首元素为根，以这个作为区分，可以得到左右子树的preorder和inorder Code 12345678910111213TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if(preorder.empty() || inorder.empty()) return NULL; TreeNode* root = new TreeNode(preorder[0]); int pos = distance(inorder.begin(), find(inorder.begin(), inorder.end(), preorder[0])); cout &lt;&lt; pos &lt;&lt; endl; vector&lt;int&gt; inorder1(inorder.begin(), inorder.begin() + pos); vector&lt;int&gt; inorder2(inorder.begin() + pos + 1, inorder.end()); vector&lt;int&gt; preorder1(preorder.begin() + 1, preorder.begin() + pos + 1); vector&lt;int&gt; preorder2(preorder.begin() + pos + 1, preorder.end()); root-&gt;left = buildTree(preorder1, inorder1); root-&gt;right = buildTree(preorder2, inorder2); return root;&#125; LC106 Construct Binary Tree from Inorder and Postorder Traversal Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given 12inorder &#x3D; [9,3,15,20,7]postorder &#x3D; [9,15,7,20,3] Return the following binary tree: 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 Think 和上一题类似 Code 123456789101112TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if(postorder.empty() || inorder.empty()) return NULL; TreeNode* root = new TreeNode(postorder.back()); int pos = distance(inorder.begin(), find(inorder.begin(), inorder.end(), postorder.back())); vector&lt;int&gt; inorder1(inorder.begin(), inorder.begin() + pos); vector&lt;int&gt; inorder2(inorder.begin() + pos + 1, inorder.end()); vector&lt;int&gt; postorder1(postorder.begin(), postorder.begin() + pos); vector&lt;int&gt; postorder2(postorder.begin() + pos, postorder.end() - 1); root-&gt;left = buildTree(inorder1, postorder1); root-&gt;right = buildTree(inorder2, postorder2); return root;&#125; LC108 Convert Sorted Array to Binary Search Tree Problem Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 &#x2F; \\ -3 9 &#x2F; &#x2F; -10 5 Think 类似上一题 Code 1234567891011TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return NULL; int n = nums.size(); int mid = n / 2; TreeNode* root = new TreeNode(nums[mid]); vector&lt;int&gt; left(nums.begin(), nums.begin() + mid); vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end()); root-&gt;left = sortedArrayToBST(left); root-&gt;right = sortedArrayToBST(right); return root;&#125; LC109 Convert Sorted List to Binary Search Tree Problem Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 &#x2F; \\ -3 9 &#x2F; &#x2F; -10 5 Think 采用类似于数组的方式，首先求出链表的长度，然后首先以当前节点建立一个一个节点，然后让左子节点等于left到mid - 1的部分求得的treenode，右子节点等于mid + 1到right的部分求得的treenode，在这里要注意由于里面需要使用链表节点，要先存储最初始的head节点。 Code 12345678910111213141516171819202122232425ListNode* head;int getListSize(ListNode* head)&#123; int res = 0; ListNode* node = head; while(node)&#123; node = node-&gt;next; res++; &#125; return res;&#125;TreeNode* sortedListToBST(ListNode* head) &#123; int len = getListSize(head); this-&gt;head = head; return helper(0, len - 1);&#125;TreeNode* helper(int left, int right)&#123; if(left &gt; right) return NULL; int mid = left + (right - left) / 2; TreeNode* tmp = helper(left, mid - 1); TreeNode* res = new TreeNode(this-&gt;head-&gt;val); res-&gt;left = tmp; this-&gt;head = this-&gt;head-&gt;next; res-&gt;right = helper(mid + 1, right); return res;&#125; LC112 Path Sum Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Think 递归DFS Code 12345bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return sum == root-&gt;val; return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);&#125; LC113 Path Sum II Problem Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ &#x2F; \\7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] Think 递归DFS，其中带上结果数组res Code 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; helper(root, sum, &#123;&#125;, res); return res;&#125;void helper(TreeNode* root, int sum, vector&lt;int&gt; path, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!root) return; path.push_back(root-&gt;val); if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; if(sum == root-&gt;val)&#123; res.push_back(path); &#125; return; &#125; sum -= root-&gt;val; helper(root-&gt;left, sum, path, res); helper(root-&gt;right, sum, path, res);&#125; LC114 Flatten Binary Tree to Linked List Problem Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 &#x2F; \\ 2 5 &#x2F; \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Think 递归，首先将左右子树flatten，然后将现在的右子树连到左子树最下方，将左子树置于当前节点的右子节点处即可。 Code 12345678910111213void flatten(TreeNode* root) &#123; if(!root) return; flatten(root-&gt;left); flatten(root-&gt;right); if(!root-&gt;left) return; TreeNode* bottom = root-&gt;left; while(bottom-&gt;right)&#123; bottom = bottom-&gt;right; &#125; bottom-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL;&#125; LC116 Populating Next Right Pointers in Each Node Problem You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root &#x3D; [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096. -1000 &lt;= node.val &lt;= 1000 Think Approach 1 BFS层序遍历 Approach 2 按层遍历，使用leftmost表示上一层的最左节点 Code Approach 1 123456789101112131415161718Node* connect(Node* root) &#123; if(!root) return NULL; queue&lt;Node*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); Node* pre = NULL; for(int i = 0; i &lt; len; i++)&#123; Node* node = q.front(); q.pop(); if(pre != NULL) pre-&gt;next = node; pre = node; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return root;&#125; Approach 2 12345678910111213141516Node* connect(Node* root) &#123; if(!root) return NULL; Node* leftmost = root; while(leftmost-&gt;left != NULL)&#123; Node* head = leftmost; while(head != NULL)&#123; head-&gt;left-&gt;next = head-&gt;right; if(head-&gt;next != NULL)&#123; head-&gt;right-&gt;next = head-&gt;next-&gt;left; &#125; head = head-&gt;next; &#125; leftmost = leftmost-&gt;left; &#125; return root;&#125; LC117 Populating Next Right Pointers in Each Node II Problem Given a binary tree 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root &#x3D; [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 6000. -100 &lt;= node.val &lt;= 100 Think BFS层序遍历 Code 123456789101112131415161718Node* connect(Node* root) &#123; if(!root) return NULL; queue&lt;Node*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); Node* pre = NULL; for(int i = 0; i &lt; len; i++)&#123; Node* node = q.front(); q.pop(); if(pre != NULL) pre-&gt;next = node; pre = node; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return root;&#125; LC124 Binary Tree Maximum Path Sum Problem Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 &#x2F; \\ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 &#x2F; \\ 9 20 &#x2F; \\ 15 7Output: 42 Think 可以转化为计算每一个节点处的最大左路径和最大右路径的和，再加上节点本身的值，因此可以使用一个递归函数来求解这个路径（某一个节点到叶节点的最大路径和）。 Code 12345678910111213int res = INT_MIN;int maxGain(TreeNode* root)&#123; if(!root) return 0; int left = max(maxGain(root-&gt;left), 0); int right = max(maxGain(root-&gt;right), 0); int newPath = root-&gt;val + left + right; res = max(newPath, res); return root-&gt;val + max(left, right);&#125;int maxPathSum(TreeNode* root) &#123; maxGain(root); return res;&#125; LC129 Sum Root to Leaf Numbers Problem Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 &#x2F; \\ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum &#x3D; 12 + 13 &#x3D; 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 &#x2F; \\ 9 0 &#x2F; \\5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026. Think DFS递归，每次cur加上当前节点的值，然后乘上10传递给两个子树 Code 123456789101112131415int sumNumbers(TreeNode* root) &#123; if(!root) return 0; int res = 0; helper(root, 0, res); return res;&#125;void helper(TreeNode* node, int cur, int &amp;res)&#123; cur += node-&gt;val; if(!node-&gt;left &amp;&amp; !node-&gt;right)&#123; res += cur; return; &#125; if(node-&gt;left) helper(node-&gt;left, cur * 10, res); if(node-&gt;right) helper(node-&gt;right, cur * 10, res);&#125; LC257 Binary Tree Paths Problem Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 1234567891011Input: 1 &#x2F; \\2 3 \\ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Think 递归DFS Code 123456789101112131415vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; if(!root) return &#123;&#125;; vector&lt;string&gt; res; helper(root, \"\", res); return res;&#125;void helper(TreeNode* node, string cur, vector&lt;string&gt; &amp;res)&#123; cur += \"-&gt;\" + to_string(node-&gt;val); if(!node-&gt;left &amp;&amp; !node-&gt;right)&#123; res.push_back(cur.substr(2)); return; &#125; if(node-&gt;left) helper(node-&gt;left, cur, res); if(node-&gt;right) helper(node-&gt;right, cur, res);&#125; LC332 Reconstruct Itinerary Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&quot;JFK&quot;, &quot;LGA&quot;] has a smaller lexical order than [&quot;JFK&quot;, &quot;LGB&quot;]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. Example 1: 12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2: 1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. Think DFS + 栈，首先用multiset map存放每一条边，然后建立一个栈，首先将“JFK”存进栈，当栈不为空时： 设栈顶元素为s，如果map[t]为空，表明之后都不会再访问这个点，因此把这个点从栈中取出来放入结果数组中，否则将当前到达的节点放入栈中，并multiset map中删除对应元素 Code 1234567891011121314151617181920vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123; vector&lt;string&gt; res; stack&lt;string&gt; st; st.push(\"JFK\"); unordered_map&lt;string, multiset&lt;string&gt;&gt; map; for(auto t: tickets)&#123; map[t[0]].insert(t[1]); &#125; while(!st.empty())&#123; string s = st.top(); if(map[s].empty())&#123; res.insert(res.begin(), s); st.pop(); &#125; else &#123; st.push(*map[s].begin()); map[s].erase(map[s].begin()); &#125; &#125; return res;&#125; LC337 House Robber III Problem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 12345678910Input: [3,2,3,null,3,null,1] 3 &#x2F; \\ 2 3 \\ \\ 3 1Output: 7 Explanation: Maximum amount of money the thief can rob &#x3D; 3 + 3 + 1 &#x3D; 7. Example 2: 12345678910Input: [3,4,5,1,3,null,1] 3 &#x2F; \\ 4 5 &#x2F; \\ \\ 1 3 1Output: 9Explanation: Maximum amount of money the thief can rob &#x3D; 4 + 5 &#x3D; 9. Think 递归，当前节点node处开始抢，所能拿到的最大数值为node-&gt;val + ll + lr + rl + rr或者l + r Code 1234567891011int rob(TreeNode* root) &#123; int l = 0, r = 0; return helper(root, l, r);&#125;int helper(TreeNode* node, int&amp; l, int&amp; r)&#123; if(!node) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = helper(node-&gt;left, ll, lr); r = helper(node-&gt;right, rl, rr); return max(node-&gt;val + ll + lr + rl + rr, l + r);&#125; LC394 Decode String Problem Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_stringinside the square brackets is being repeated exactly k times. Note that kis guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Example 1: 12Input: s &#x3D; &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot; Example 2: 12Input: s &#x3D; &quot;3[a2[c]]&quot;Output: &quot;accaccacc&quot; Example 3: 12Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;Output: &quot;abcabccdcdcdef&quot; Example 4: 12Input: s &#x3D; &quot;abc3[cd]xyz&quot;Output: &quot;abccdcdcdxyz&quot; Think 递归，每一次的结果等于重复外围的数字次数的内部的内容，利用一个全局变量i来进行s的遍历。 Code 1234567891011121314151617181920212223string decodeString(string s) &#123; int i = 0; return helper(s, i);&#125;string helper(string s, int&amp; i)&#123; string res; while(i &lt; s.size() &amp;&amp; s[i] != ']')&#123; if(!isdigit(s[i]))&#123; res += s[i++]; &#125; else&#123; int n = 0; while(i &lt; s.size() &amp;&amp; isdigit(s[i])) n = n * 10 + s[i++] - '0'; i++; string repeat = helper(s, i); i++; for(int j = 0; j &lt; n; j++)&#123; res += repeat; &#125; &#125; &#125; return res;&#125; Review DFS一般是和递归联系起来的，主要包括如下内容的递归： 树上的递归，即左右子树存在相同的结构； 内部最小子结构的递归；","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"C++中的sort函数","slug":"C++-中的sort函数","date":"2020-06-01T07:19:01.000Z","updated":"2020-06-01T07:47:13.589Z","comments":true,"path":"C++-中的sort函数/","link":"","permalink":"http://yoursite.com/C++-%E4%B8%AD%E7%9A%84sort%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++中的sort函数的原型 sort(iterator1, iterator2) - 对数组进行递增(non-descending)排序 sort(iterator1, iterator2, comp) - 对数组按照给定的comp方式进行排序 sort函数的第三个参数 第三个参数为cpmparision function object，相当于bool cmp(const Type1 &amp;a, const Type2 &amp;b)，如果第一个变量比第二个小，则应当返回true。一般有三种方式： standard library comparison function object 1std::sort(s.begin(), s.end(), std::greater&lt;int&gt;()) custom function object 1234567struct &#123; bool operator()(int a, int b) const &#123; return a &lt; b; &#125; &#125; customLess;std::sort(s.begin(), s.end(), customLess); lambda expression 123std::sort(s.begin(), s.end(), [](int a, int b) &#123; return a &gt; b; &#125;);","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Greedy(2)","slug":"Greedy-2","date":"2020-05-31T09:05:19.000Z","updated":"2020-09-19T02:19:13.522Z","comments":true,"path":"Greedy-2/","link":"","permalink":"http://yoursite.com/Greedy-2/","excerpt":"","text":"LC315 Remove Duplicate Letters Problem Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: 12Input: &quot;bcabc&quot;Output: &quot;abc&quot; Example 2: 12Input: &quot;cbacdcbc&quot;Output: &quot;acdb&quot; Think 首先遍历字符串，求得每个字母的出现次数，然后用一个哈希表来存放当前字母是否已经被访问过。 再次遍历字符串，首先将当前字母对应的出现次数-1，如果该字母已经访问过，则说明当前字母已经加入了结果，则继续下一次循环；否则，将当前字母不断的和结果字符串的最后一个字符进行比较，如果比结果字符串的最后一个字母小，而且这个最后一个字母对应的cnt数组大于0，说明之后还会出现这个字母，因此可以从res中删去；最后将当前遍历到的字母分别加入结果字符串和哈希表中。 Code 1234567891011121314151617string removeDuplicateLetters(string s) &#123; vector&lt;int&gt; cnt(26, 0); unordered_set&lt;char&gt; map; for(auto c: s) cnt[c - 'a']++; string res = \"0\"; for(auto c: s)&#123; cnt[c - 'a']--; if(map.count(c)) continue; while(c &lt; res.back() &amp;&amp; cnt[res.back() - 'a'] != 0)&#123; map.erase(res.back()); res.pop_back(); &#125; res += c; map.insert(c); &#125; return res.substr(1);&#125; LC321 Create Maximum Number Problem Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. Note: You should try to optimize your time and space complexity. Example 1: 123456Input:nums1 &#x3D; [3, 4, 6, 5]nums2 &#x3D; [9, 1, 2, 5, 8, 3]k &#x3D; 5Output:[9, 8, 6, 5, 3] Example 2: 123456Input:nums1 &#x3D; [6, 7]nums2 &#x3D; [6, 0, 4]k &#x3D; 5Output:[6, 7, 6, 0, 4] Example 3: 123456Input:nums1 &#x3D; [3, 9]nums2 &#x3D; [8, 9]k &#x3D; 3Output:[9, 8, 9] Think 设两个数组长度分别为m和n，设从第一个数组中取i个数字，则从第二个数组中取k-i个数字。 i的范围的确定： 当i &gt; n的时候，第一个数组至少要取k - n个数字；当i &lt;= n的时候，第一个数组至少取0个数字，因此i的最小值应该为max(0, k - n)； 对应的，在nums1数组中最大只能取k个数和m个数字中的较小值，即i的最大值为min(k, m)； 对于每一种i的情况，判断res和nums1取i个数字，nums2取k-i个数字并merge之后的大小。因此需要解决如下问题： 从一个数组nums中取k个数字所能组成的最大值： 设nums的长度为n，因此需要删除n - k个数字。采用类似上一题的做法，每次判断是否还有数字要删除(drop &gt; 0)、结果数组不为空(!res.empty())以及当前数字是否大于res数组的尾端的数字(num &gt; res.back())，将所有满足这些条件的数字删除，然后将当前数字push进res数组，最后resize为k(取前k个数)； merge两个数组所能组成的最大值：这里的merge不能单纯比较每个数组的开头的元素的大小，而是需要对数组整体进行大小比较，取较大数组的头元素，然后将这个头元素从数组中删去。 Code 1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int m = nums1.size(), n = nums2.size(); vector&lt;int&gt; res; for(int i = max(0, k - n); i &lt;= min(k, m); i++)&#123; res = max(res, mergeVector(maxNumber(nums1, i), maxNumber(nums2, k - i))); &#125; return res;&#125;vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; int drop = (int)nums.size() - k; for(auto num: nums)&#123; while(drop &gt; 0 &amp;&amp; !res.empty() &amp;&amp; num &gt; res.back())&#123; res.pop_back(); drop--; &#125; res.push_back(num); &#125; res.resize(k); return res;&#125;vector&lt;int&gt; mergeVector(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2) &#123; vector&lt;int&gt; res; while (!nums1.empty() || !nums2.empty()) &#123; vector&lt;int&gt; &amp;tmp = (nums1 &gt; nums2) ? nums1 : nums2; res.push_back(tmp[0]); tmp.erase(tmp.begin()); &#125; return res;&#125; LC330 Patching Array Problem Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: 1234567Input: nums &#x3D; [1,3], n &#x3D; 6Output: 1 Explanation:Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.Now if we add&#x2F;patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].So we only need 1 patch. Example 2: 123Input: nums &#x3D; [1,5,10], n &#x3D; 20Output: 2Explanation: The two patches can be [2, 4]. Example 3: 12Input: nums &#x3D; [1,2,2], n &#x3D; 5Output: 0 Think 初始化当前可计算范围为[1, 1)，进行下列循环： 设当前可计算范围为[1, miss)，也就是miss是无法计算的，那么为了计算miss，我们直接将miss添加进数组即可。在添加之前我们要先判断当前数组内是否存在可以计算出miss值的数字，即后一位的num是否小于等于miss，如果满足，则miss = miss + nums[i]，否则需要添加一个数字miss进数组，然后miss = miss * 2。 Initialize the range [1, miss) = [1, 1) = empty While n is not covered yet if the current element nums[i] is less than or equal tomiss extends the range to [1, miss + nums[i]) increase i by 1 otherwise patch the array with miss, extends the range to [1, miss + miss) increase the number of patches Return the number of patches Code 123456789101112131415int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; long right = 1; int i = 0, res = 0; while(right &lt;= n)&#123; if(i &lt; nums.size() &amp;&amp; nums[i] &lt;= right)&#123; right += nums[i]; i++; &#125; else&#123; right *= 2; res++; &#125; &#125; return res;&#125; LC392 Is Subsequence Problem Given a string s and a string t, check if s is subsequence of t. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not). Follow up: If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits: Special thanks to @pbrother for adding this problem and creating all test cases. Example 1: 12Input: s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;Output: true Example 2: 12Input: s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;Output: false Constraints: 0 &lt;= s.length &lt;= 100 0 &lt;= t.length &lt;= 10^4 Both strings consists only of lowercase characters. Think 双指针，分别从两个字符串开头遍历，相同则同时后移，不同则后移t对应的指针，最后判断s是否遍历完即可。 Code 1234567891011121314bool isSubsequence(string s, string t) &#123; int m = s.size(), n = t.size(); int i = 0, j = 0; while(i &lt; m &amp;&amp; j &lt; n)&#123; if(s[i] == t[j])&#123; i++; j++; &#125; else&#123; j++; &#125; &#125; return i == m; &#125; LC402 Remove K Digits Problem Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: 123&gt;Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: 123&gt;Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: 123&gt;Input: num &#x3D; &quot;10&quot;, k &#x3D; 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. Think Greedy+Stack 建立一个栈，然后遍历num，如果当前num[i]比栈顶的数值小，而且k&gt;0(说明还可以删数字)，则将栈顶的数字pop出来，将num[i]push进去。然后将栈的前n - k个数字提取出来，形成字符串，并将前缀0去掉。 Code 1234567891011121314151617181920212223242526string removeKdigits(string num, int k) &#123; stack&lt;char&gt; s; int drop = 0; int n = num.size(); for(auto digit: num)&#123; while(!s.empty() &amp;&amp; k &gt; 0 &amp;&amp; s.top() &gt; digit)&#123; k--; s.pop(); &#125; s.push(digit); &#125; for(int i = 0; i &lt; k; i++)&#123; s.pop(); &#125; string res; while(!s.empty())&#123; res = s.top() + res; s.pop(); &#125; int left = 0; while(res[left] == '0')&#123; left++; &#125; res = res.substr(left); return res == \"\" ? \"0\": res;&#125; LC406 Queue Reconstruction by Height Problem Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100. Example 12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] Think 首先对所有的people进行排序，排序规则为，第一位降序，第二位升序，然后按顺序将每一个p插入在res.begin() + p[1]的部分。 Code 1234567891011121314151617181920212223242526272829struct&#123; bool operator()(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2) const&#123; if(p1[0] &gt; p2[0])&#123; return true; &#125; else if(p1[0] &lt; p2[0])&#123; return false; &#125; else&#123; if(p1[1] &gt; p2[1])&#123; return false; &#125; else&#123; return true; &#125; &#125; &#125;&#125; cmp;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), cmp); vector&lt;vector&lt;int&gt;&gt; res; for(auto p: people)&#123; res.insert(res.begin() + p[1], p); &#125; return res; &#125;&#125;; LC435 Non-overlapping Intervals Problem Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1: 123Input: [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Example 2: 123Input: [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. Example 3: 123Input: [[1,2],[2,3]]Output: 0Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping. Note: You may assume the interval’s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other. Think Greedy，首先对所有intervals按照结束时间进行排序，然后遍历intervals，判断如果两个interval有重叠，则保留结束时间在前的那一个（需要更新prev和cnt）。 Code 12345678910111213141516171819202122232425struct&#123; bool operator()(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123; return a[1] &lt; b[1]; &#125;&#125;comp;class Solution &#123;public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if(intervals.empty()) return 0; sort(intervals.begin(), intervals.end(), comp); int n = intervals.size(); int end = intervals[0][1], prev = 0, cnt = 0; for(int i = 1; i &lt; n; i++)&#123; if(intervals[prev][1] &gt; intervals[i][0])&#123; if(intervals[prev][1] &gt; intervals[i][1])&#123; prev = i; &#125; cnt++; &#125;else&#123; prev = i; &#125; &#125; return cnt; &#125;&#125;; LC452 Minimum Number of Arrows to Burst Balloons Problem There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: 12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons). Think 首先对数组进行排序，设置当前的重叠区间cur为points[0]，然后遍历points数组，如果和下一个区间有重叠部分，则说明可以在这个重叠区间里射击即可打穿气球，因此不需要更多一次的次数，因此cur设置为新的重叠区间；如果没有重叠部分，则说明需要更多一次的次数来射击气球，因此次数需要+1，当前重叠区间设置为当前points的区间即可。 Code 1234567891011121314151617int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; if(points.empty()) return 0; sort(points.begin(), points.end()); vector&lt;int&gt; cur = points[0]; int res = 1; for(int i = 1; i &lt; points.size(); i++)&#123; if(cur[1] &lt; points[i][0])&#123; cur = points[i]; res++; &#125; else&#123; cur[0] = max(cur[0], points[i][0]); cur[1] = min(cur[1], points[i][1]); &#125; &#125; return res;&#125; LC455 Assign Cookies Problem Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note: You may assume the greed factor is always positive. You cannot assign more than one cookie to one child. Example 1: 1234567Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. Example 2: 1234567Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Think 首先将g和s排序，设置i和j初始为0，对每一个饼干j，如果s[j] &gt;= g[i]，即饼干j可以满足第i个人的要求，就跳到下一个人(i++)，且res++ Code 1234567891011121314int findContentChildren(vector&lt;int&gt; &amp;g, vector&lt;int&gt; &amp;s)&#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int i = 0, j = 0, res = 0; while(i &lt; g.size() &amp;&amp; j &lt; s.size())&#123; if(g[i] &lt;= s[j])&#123; i++; res++; &#125; j++; &#125; return res;&#125; LC502 IPO Problem Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have Wcapital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital. To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital. Example 1: 123456789Input: k&#x3D;2, W&#x3D;0, Profits&#x3D;[1,2,3], Capital&#x3D;[0,1,1].Output: 4Explanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, output the final maximized capital, which is 0 + 1 + 3 &#x3D; 4. Note: You may assume all numbers in the input are non-negative integers. The length of Profits array and Capital array will not exceed 50,000. The answer is guaranteed to fit in a 32-bit signed integer. Think 首先判断是否所有的项目都立刻可以做，如果是的话就直接取利润最大的k个项目就可以了；否则： 建立一个最小堆，将每一个capital和profit对在堆中按capital升序排列； 建立一个最大堆，存放当前所有可以做的项目，按profit降序排列； 如果k&gt;0，则说明还可以完成任务，因此将当前所有可以完成的任务加入available堆中，然后取出其中profit最大的任务即可。重复这个过程直到k=0或者无可做任务。 Code 12345678910111213141516171819202122232425262728293031323334353637383940int findMaximizedCapital(int k, int W, vector&lt;int&gt;&amp; Profits, vector&lt;int&gt;&amp; Capital) &#123; bool speedUp = true; for(auto c: Capital)&#123; if(W &lt; c)&#123; speedUp = false; break; &#125; &#125; if(speedUp)&#123; priority_queue&lt;int&gt; q; for(auto p: Profits)&#123; q.push(p); &#125; for(int i = 0; i &lt; k; i++)&#123; W += q.top(); q.pop(); &#125; return W; &#125; int n = Profits.size(); priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, greater&lt;vector&lt;int&gt;&gt;&gt; projects; for(int i = 0; i &lt; n; i++)&#123; projects.push(&#123;Capital[i], Profits[i]&#125;); &#125; priority_queue&lt;int&gt; available; while(k &gt; 0)&#123; while(!projects.empty() &amp;&amp; projects.top()[0] &lt;= W)&#123; available.push(projects.top()[1]); projects.pop(); &#125; if(!available.empty())&#123; W += available.top(); available.pop(); &#125; else break; k--; &#125; return W;&#125; LC621 Task Scheduler Problem Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. Example: 123Input: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2Output: 8Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Constraints: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. Think Approach 1 首先统计各个字母的出现次数，然后排序，取出现次数最多的那一个，即从这一个开始需要进入一个小循环，长度为n，在这个循环里不能有重复的task出现，而只有当第25-i类task存在的时候才会对其次数减一，否则相当于idle；然后再对出现次数数组进行排序，继续下一次循环。 Approach 2 首先统计各个字母的出现次数，然后排序，从出现次数最多的那一个开始，将其放在所有时间循环的开头，然后一次将后面的task放在循环的下一个位置，也就是idle的位置每一次都会减少times[i]，最后直接计算idle + tasks.size()即可。 Code Approach 1 12345678910111213141516171819int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; vector&lt;int&gt; times(26, 0); for(auto c: tasks)&#123; times[c - 'A']++; &#125; sort(times.begin(), times.end()); int res = 0; while(times.back() &gt; 0)&#123; int i = 0; while(i &lt;= n)&#123; if(times[25] == 0) break; if(i &lt; 26 &amp;&amp; times[25 - i] &gt; 0) times[25 - i]--; i++; res++; &#125; sort(times.begin(), times.end()); &#125; return res;&#125; Approach 2 123456789101112int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; vector&lt;int&gt; times(26, 0); for(auto c: tasks)&#123; times[c - 'A']++; &#125; sort(times.begin(), times.end()); int max_val = times[25] - 1, idle = max_val * n; for(int i = 24; i &gt;= 0 &amp;&amp; times[i] &gt; 0; i--)&#123; idle -= min(times[i], max_val); &#125; return idle &gt; 0 ? idle + tasks.size() : tasks.size();&#125; Review Greedy的题目都不简单，主要不同的贪心算法的贪的地方不一样，而且很多时候也很难证明贪心算法的正确性，因此面对可能是贪心算法的题目，首先要先确定贪心算法是否有合理性，一般情况先可以通过反证法来略微思考一下，或者举几个例子试一下；在确定了是采用贪心算法的时候，我们就需要判断应该在何处“贪”，一般情况下是出现次数、利润、价格、单位利润率等方向，必要时除了使用sort之外，还可以考虑使用堆(priority_queue)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Greedy","slug":"Greedy","permalink":"http://yoursite.com/tags/Greedy/"}]},{"title":"LeetCode的一些总结","slug":"LeetCode的一些总结","date":"2020-05-27T08:21:38.000Z","updated":"2020-09-09T16:22:11.510Z","comments":true,"path":"LeetCode的一些总结/","link":"","permalink":"http://yoursite.com/LeetCode%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"一些套路的总结 分解问题的角度：固定某一个维度，尝试另一维度上的所有可能 可能是array的(i, j) pointers 可能是矩形的长与宽 可能是tree的每一个subtree，比如固定左子树，来遍历每一个可能的右子树 可能是情景题的每一对pair 求所有解的，一 般暴力上backtracking 如果问最短/最少的, 先想BFS和DP 如果环相关，或者涉及到重复访问，可以使用DFS + visited state（或者记忆数组） 如果问连通性, 静态靠DFS/BFS, 动态靠Union-Find 如果不同的实例或者节点之间有依赖性, 想想Topologic order 和indegree DAG的万能套路：先进行DFS+memo, 再考虑如何转化成DP 建图的时候想想vertex, edges/neighbors, cost分别是什么。如果出现cycle, 别忘了给vertex增加状态（visited） 树相关, 记得考虑backtracking 和 pure recursion两条路 遇到字符串/字典/char board相关的, Trie tree（前缀树）总是可以试试的 Range里求最大/最小/sum等特征值, Segment tree（线段树）会是不错的选择 Matrix和Array通常都是 Two Pointers Sliding Window(fixed &amp; not fixed) DP DP题型往往是 问你可不可以啊, 数量有多少啊 -&gt; 使用bool类型的数组 两个string上match来match去的 -&gt; 二维数组，两个维度分别为两个string的长度 1D/2D array 相关 博弈游戏 -&gt; 考虑可以往前多少步可以找到相关状态 破解DAG cycle想想哪个维度是具有单调性的: 常见的steps, directions, paths Reversed idea非常重要, 可能会帮助你破题: 最长可能是某种最短的反面, 最多可能是某种最少的反面, obstacle的反面是reachable, subarray的反面是array中的剩下元素, left的反面是right Look up别忘了HashMap/HashSet（HashMap + DLL是常见hybrid数据结构） 找规律试试那些旁门左道: 单调Stack/双端Deque 数组相关，而且涉及到元素之间大小比较的，可以先考虑是否可以先进行排序 时空复杂度 backtracking相关, 想想branching factor和height DFS+memo/DP相关, 想想state数量, 以及每个state的cost tree相关, 总是要考虑balanced 和 single linked list的 array/矩阵相关, 先数数你有多少个for loops binary search application相关, 别忘了check function开销 stack/queue/deque相关, 常说的吃进去一次又吐出来一次 Java的string是朵奇葩, string concatenation不是免费的 -&gt; O(n) 没人知道n是什么, 先告诉别人m，n，k，V，E是什么 比较不同sol的trade offs Time/Space complexity异同 online/offline算法(online算法表示可以一直有数据传输进来的方法) pre-computation cost，预处理 不同APIs的call frequency差异会导致不同的时间要求 extension: 是否适用于generic parameters/stream input 线程安全/large scale DP问题的一些总结 DP有六步，建议面试时写在白板上，一步都不能少，基本上你写出这些 implement起来也非常简单了 definition: dp(i)或者dp(i, j) 表示什么含义，比如largest subarray sum ending at arr(i), and must include arr(i)，注意语言描述，包括还是不包括arr(i)/matrix(i, j)； induction rule: dp(i) 的 dependency 是怎么样的，依赖于dp(i-1) 还是 dp(i+1) 还是 dp(k) for all k &lt; i or all k &gt; i 等等，试着过几个小例子推导一下； base case: 往往是dp(0)，二维往往是第一行， 第一列，也就是dp(i, 0)和dp(0, j)； result: 往往是dp(n), max(dp(i)) 等等, 从definition 出发； filling order: 也就是你填dp表格的顺序，从induction rule 的 dependency出发，判断是从左到右还是从左上到右下； optimized: 分为时间和空间两方面： 时间的比较难，因为往往需要你重新define dp state 和 induction rule； 空间比较简单，可以根据induction rule看出来，比如斐波那契数列: dp = dp(i-1) + dp(i-2), 那么dp(i) 只依赖于前两个元素，就不需要create 整个 dp array，两个variable即可，空间可以从O(n)优化到O(1)。 14种常见模式 滑动窗口 滑动窗口主要就是维护一个可以不断变化左右边界的子数组，如下图所示： 每一次该窗口左边界右移一格，右边界根据需要进行相应的变化，可能向左移动，可能向右移动，也可能不变。 滑动窗口的问题的标志 输入是线性的结构，比如链表、数组和字符串 被要求求解最长或者最短的子字符串，子数组或者特定值 常见问题 Maximum sum subarray of size ‘K’ (easy) Longest substring with ‘K’ distinct characters (medium) String anagrams (hard) 双指针 双指针主要是同时使用两个指针迭代遍历数据结构，直到其中一个或者两个指针达到特定状态。一般用于有序的数组或者链表，可以将原本的O(n^2)​的复杂度降低成​O(n)​。 双指针问题的标志 在有序数组或者链表中找到一系列满足特定条件的元素 这一系列元素一般成对(pair)、成三对(triplet)或者子数组(subarray) 常见问题 Squaring a sorted array (easy) Triplets that sum to zero (medium) Comparing strings that contain backspaces (medium) 快慢指针 又称Hare &amp; Tortoise algorithm，是一种使用不同行进速度的双指针的算法，经常用在处理环形链表的问题上。如果两个指针都在同一个环上，则快指针一定能和慢指针相遇。 快慢指针问题的标志 一般是带环的链表或者数组 需要知道特定元素的位置，或者整个链表的长度 一般不用在单项链表等无法回头的结构中 主要问题 Linked List Cycle (easy) Palindrome Linked List (medium) Cycle in a Circular Array (hard) 区间的合并 区间合并主要是用来处理相互重叠的区间问题的，主要有以下六种情况： 区间合并问题的标志 需要产生只包含互斥区间的数组 看到“overlapping intervals”的时候 主要问题 Intervals Intersection (medium) Maximum CPU Load (hard) 循环排序 主要处理数组中的数值限定在一定的区间的问题。 循环排序问题的标志 涉及到排序好的数组，而且数值满足于一定的区间 需要在排好序/翻转过的数组中，寻找丢失的/重复的/最小的元素 主要问题 Find the Missing Number (easy) Find the Smallest Missing Positive Number (medium) 原地链表翻转 原地链表翻转就是要利用提供的链表的空间来对链表进行翻转操作，一般需要多个变量： current指向当前遍历到的节点 previous指向上一个处理好的节点 原地链表翻转的标志 被要求不使用格外空间进行链表的翻转 主要问题 Reverse a Sub-list (medium) Reverse every K-element Sub-list (medium) 树BFS 在树上使用BFS 树BFS的标志 需要一层一层的遍历树的时候 主要问题 Binary Tree Level Order Traversal (easy) Zigzag Traversal (medium) 树DFS 在树上使用DFS 树DFS的标志 需要按前中后序遍历树的时候 需要搜索的节点离叶节点更近的时候 主要问题 Sum of Path Numbers (medium) All Paths for a Sum (medium) 双堆 双堆，即一个最大堆一个最小堆，各存放数组的一般的内容 双堆问题的标志 优先队列或者scheduling相关的问题 找一组数中的最大/最小/中间的数 具有二叉树结构的时候 主要问题 Find the Median of a Number Stream (medium) 子集问题模式 子集问题模式的标志 需要找数字的排列或者组合 主要问题 Subsets With Duplicates (easy) String Permutations by changing case (medium) 二分 主要问题 Order-agnostic Binary Search (easy) Search in a Sorted Infinite Array (medium) 前k大的元素 主要用于求解前k大/小的元素，一般采用最大堆或者最小堆的方式 topK的标志 需要求解最大/最小/最频繁的元素 通过排序定位特定元素 主要问题 Top ‘K’ Numbers (easy) Top ‘K’ Frequent Numbers (medium) K路归并 主要涉及到k个有序数组的合并 K路归并的标志 输入是排好序的数字，链表或者矩阵 需要合并多个排好序的数组，或者是找到这些数组中的最小数 主要问题 Merge K Sorted Lists (medium) K Pairs with Largest Sums (Hard) 拓扑排序 初始化 a) 借助于HashMap将图保存成邻接表形式。 b) 找到所有的起点，用HashMap来帮助记录每个节点的入度 创建图，找到每个节点的入度 a) 利用输入，把图建好，然后遍历一下图，将入度信息记录在HashMap中 找所有的起点 a) 所有入度为0的节点，都是有效的起点，而且我们讲他们都加入到一个队列中 排序 a) 对每个起点，执行以下步骤 —i) 把它加到结果的顺序中 — ii)将其在图中的孩子节点取到 — iii)将其孩子的入度减少1 — iv)如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中 b) 重复（a）过程，直到起点队列为空。 拓扑排序的主要标志 需要处理的图是无环图 需要以一定的顺序更新节点 需要处理的数据输入遵循某种规律 主要问题 Task scheduling (medium) Minimum height of a tree (hard) 参考 关于算法的一点总结 | 一亩三分地 14 Patterns to Ace Any Coding Interview Question","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Topological Sort","slug":"Topological-Sort","date":"2020-05-27T02:59:46.000Z","updated":"2020-05-27T22:59:59.432Z","comments":true,"path":"Topological-Sort/","link":"","permalink":"http://yoursite.com/Topological-Sort/","excerpt":"","text":"LC207 Course Schedule Problem There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: 1234Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: 12345Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. 1 &lt;= numCourses &lt;= 10^5 Think 拓扑排序 vector存放所有的edges，inDegree &amp; outNodes； 建立一个queue存放所有的入度=0的节点； 当该队列不为空的时候，取出一个节点，cnt++，将这个节点的所有outNode的inDegree-1，如果这之后outNode的inDegree=0，则加入队列； 判断cnt是否等于节点的数目。 Code 1234567891011121314151617181920212223242526272829303132333435363738class Node&#123;public: int val; int inDegree; vector&lt;Node*&gt; outNodes; Node(int value)&#123; val = value; inDegree = 0; outNodes = vector&lt;Node*&gt;(); &#125;&#125;;bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;Node*&gt; nodes(numCourses); for(int i = 0; i &lt; numCourses; i++)&#123; nodes[i] = new Node(i); &#125; for(auto edge: prerequisites)&#123; nodes[edge[1]]-&gt;outNodes.push_back(nodes[edge[0]]); nodes[edge[0]]-&gt;inDegree++; &#125; queue&lt;Node*&gt; q; for(auto n: nodes)&#123; if(n-&gt;inDegree == 0) q.push(n); &#125; int cnt = 0; while(!q.empty())&#123; Node* cur = q.front(); q.pop(); cnt++; for(auto next: cur-&gt;outNodes)&#123; next-&gt;inDegree--; if(next-&gt;inDegree == 0)&#123; q.push(next); &#125; &#125; &#125; return cnt == numCourses;&#125; LC210 Course Schedule II Problem There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: 1234Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2: 12345Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Think 在上一题的基础上，计算cnt++的时候将pop出的点放到结果数组里即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243class Node&#123;public: int val; int inDegree; vector&lt;Node*&gt; outNodes; Node(int value)&#123; val = value; inDegree = 0; outNodes = vector&lt;Node*&gt;(); &#125;&#125;;class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; res(numCourses, -1); vector&lt;Node*&gt; nodes(numCourses); for(int i = 0; i &lt; numCourses; i++)&#123; nodes[i] = new Node(i); &#125; for(auto edge: prerequisites)&#123; nodes[edge[1]]-&gt;outNodes.push_back(nodes[edge[0]]); nodes[edge[0]]-&gt;inDegree++; &#125; queue&lt;Node*&gt; q; for(auto n: nodes)&#123; if(n-&gt;inDegree == 0) q.push(n); &#125; int cnt = 0; while(!q.empty())&#123; Node* cur = q.front(); q.pop(); res[cnt++] = cur-&gt;val; for(auto next: cur-&gt;outNodes)&#123; next-&gt;inDegree--; if(next-&gt;inDegree == 0)&#123; q.push(next); &#125; &#125; &#125; if(cnt == numCourses) return res; else return &#123;&#125;; &#125;&#125;; LC329 Longest Increasing Path in a Matrix Problem Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: 12345678Input: nums &#x3D; [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2: 12345678Input: nums &#x3D; [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. Think 拓扑结构为，每一个节点只能向上下左右四个节点的位置进行遍历，因此只需要判断当前节点的上下左右四个节点满足： 比当前节点的值小 outDegree=0 相当于从叶节点开始向根节点遍历，所以在求解outDegree数组的时候，需要计算的是周围所有满足值比当前节点大的节点（相当于是求解下一层的节点）。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; vector&lt;int&gt; dx = &#123;0, 1, 0, -1&#125;, dy = &#123;1, 0, -1, 0&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 2, vector&lt;int&gt;(n + 2, 0)); for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; dp[i][j] = matrix[i - 1][j - 1]; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; outDegree(m + 2, vector&lt;int&gt;(n + 2, 0)); for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; for(int k = 0; k &lt; 4; k++)&#123; if(dp[i][j] &lt; dp[i + dx[k]][j + dy[k]])&#123; outDegree[i][j]++; &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; q; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(outDegree[i][j] == 0)&#123; q.push_back(&#123;i, j&#125;); &#125; &#125; &#125; int res = 0; while(!q.empty())&#123; res++; vector&lt;vector&lt;int&gt;&gt; newQ; for(auto cur: q)&#123; for(int i = 0; i &lt; 4; i++)&#123; if(dp[cur[0]][cur[1]] &gt; dp[cur[0] + dx[i]][cur[1] + dy[i]])&#123; if(--outDegree[cur[0] + dx[i]][cur[1] + dy[i]] == 0)&#123; newQ.push_back(&#123;cur[0] + dx[i], cur[1] + dy[i]&#125;); &#125; &#125; &#125; &#125; q = newQ; &#125; return res;&#125; Review 拓扑排序是一类比较特殊的遍历问题，其特殊性在于如何确定下一个要遍历的节点的方式。一般的BFS或者DFS是通过加入子节点的方式，而拓扑排序则是通过加入当前入度为0的点来实现的，也就是说对于一个拓扑排序的场景来说，我们必须要找到一个有序性，即有向无环图(DAG)，从而确定每一个点的入度。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"http://yoursite.com/tags/Topological-Sort/"}]},{"title":"Breadth First Search(1)","slug":"Breadth-First-Search-1","date":"2020-05-24T12:28:19.000Z","updated":"2020-05-27T07:06:23.797Z","comments":true,"path":"Breadth-First-Search-1/","link":"","permalink":"http://yoursite.com/Breadth-First-Search-1/","excerpt":"","text":"LC107 Binary Tree Level Order Traversal II Problem Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] Think 层序遍历，然后翻转数组 Code 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if(!root) return &#123;&#125;; queue&lt;TreeNode*&gt; s; s.push(root); vector&lt;vector&lt;int&gt;&gt; res; while(!s.empty())&#123; int len = s.size(); vector&lt;int&gt; cur; for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = s.front(); cur.push_back(node-&gt;val); s.pop(); if(node-&gt;left) s.push(node-&gt;left); if(node-&gt;right) s.push(node-&gt;right); &#125; res.push_back(cur); &#125; reverse(res.begin(), res.end()); return res;&#125; LC111 Minimum Depth of Binary Tree Problem Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its minimum depth = 2. Think Approach 1 递归，分别判断无左右子节点，只有左子节点，只有右子节点和有左右子节点 Approach 2 层序遍历BFS Code Approach 1 1234567int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; if(root-&gt;left &amp;&amp; !root-&gt;right) return minDepth(root-&gt;left) + 1; if(!root-&gt;left &amp;&amp; root-&gt;right) return minDepth(root-&gt;right) + 1; return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;&#125; Approach 2 123456789101112131415161718int minDepth(TreeNode* root) &#123; if(!root) return 0; queue&lt;TreeNode*&gt; q; q.push(root); int res = 1; while(!q.empty())&#123; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = q.front(); q.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) return res; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res++; &#125; return 0;&#125; LC126 Word Ladder II Problem Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 12345678910Input:beginWord &#x3D; &quot;hit&quot;,endWord &#x3D; &quot;cog&quot;,wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] Example 2: 12345678Input:beginWord &#x3D; &quot;hit&quot;endWord &#x3D; &quot;cog&quot;wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: []Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. Think 使用BFS遍历所有可能的路径path组成的paths队列。 首先初始化paths队列，将初始word所构成的路径放入； 当队列paths不为空时： 取出最前的一个路径； 如果该路径长度超过当前的level值，也就是当前应当遍历到第几层，则说明wordList中存在一些word已经出现在当前路径中，这些词不能再次出现在接下来的路径中，所以直接在wordList中删除这些词，并将level置为当前路径的长度；如果当前路径长度已经大于minLevel，则说明后面的所有路径都只会更长而不会更短，因此直接break； 取出当前路径的最后一个word，并以这个word作为起始word向后遍历，修改其中的一个字符，如果修改后的word存在于当前的wordList中，则将它加入当前路径；判断是否已经到达endWord，如果到达的话就直接加入res并更新minLevel值，否则加入paths中进行下一次的循环。 Code 123456789101112131415161718192021222324252627282930313233343536373839vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; vector&lt;vector&lt;string&gt;&gt; res; unordered_set&lt;string&gt; wordDict(wordList.begin(), wordList.end()); vector&lt;string&gt; p = &#123;beginWord&#125;; queue&lt;vector&lt;string&gt;&gt; q; q.push(p); int level = 1, minLevel = INT_MAX; unordered_set&lt;string&gt; words; while(!q.empty())&#123; vector&lt;string&gt; t = q.front(); q.pop(); if(t.size() &gt; level)&#123; for(auto word: words) wordDict.erase(word); words.clear(); level = t.size(); if(level &gt; minLevel) break; &#125; string cur = t.back(); for(int i = 0; i &lt; cur.size(); i++)&#123; string next = cur; for(char c = 'a'; c &lt;= 'z'; c++)&#123; next[i] = c; if(!wordDict.count(next)) continue; words.insert(next); vector&lt;string&gt; curPath = t; curPath.push_back(next); if(next == endWord)&#123; res.push_back(curPath); minLevel = level; &#125; else&#123; q.push(curPath); &#125; &#125; &#125; &#125; return res;&#125; LC127 Word Ladder Problem Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord &#x3D; &quot;hit&quot;,endWord &#x3D; &quot;cog&quot;,wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord &#x3D; &quot;hit&quot;endWord &#x3D; &quot;cog&quot;wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. Think 基础的BFS，注意遇到这种题要严格按照BFS的运行方式来思考，比如求最短路径之类的，要注意不要往Back Tracing上靠！！！ Code 12345678910111213141516171819202122232425262728293031int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; unordered_set&lt;string&gt; wordDict(wordList.begin(), wordList.end()); if(!wordDict.count(endWord)) return 0; queue&lt;string&gt; q; q.push(beginWord); unordered_set&lt;string&gt; visited; int level = 1, res = INT_MAX; while(!q.empty())&#123; int len = q.size(); level++; for(int i = 0; i &lt; len; i++)&#123; string word = q.front(); q.pop(); for(int i = 0; i &lt; word.size(); i++)&#123; string newWord = word; for(char c = 'a'; c &lt;= 'z'; c++)&#123; newWord[i] = c; if(newWord == word) continue; if(!wordDict.count(newWord)) continue; if(visited.count(newWord)) continue; if(newWord == endWord)&#123; return level; &#125; q.push(newWord); visited.insert(newWord); &#125; &#125; &#125; &#125; return 0;&#125; LC130 Surrounded Regions Problem Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Think 从每一条边上为O的地点出发，BFS或者DFS找到所有和这个O相连的O，将它们改成E（一方面标识哪些O是符合条件的，一方面作为visited数组使用），最后将所有的O改成X，E改成O。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if(board.empty() || board[0].empty()) return; int m = board.size(), n = board[0].size(); // four borders // left border for(int i = 0; i &lt; m; i++)&#123; BFS(board, i, 0); &#125; // right border for(int i = 0; i &lt; m; i++)&#123; BFS(board, i, n - 1); &#125; // up border for(int i = 1; i &lt; n - 1; i++)&#123; BFS(board, 0, i); &#125; // bottom border for(int i = 1; i &lt; n - 1; i++)&#123; BFS(board, m - 1, i); &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(board[i][j] == 'E')&#123; board[i][j] = 'O'; &#125; else if(board[i][j] == 'O')&#123; board[i][j] = 'X'; &#125; &#125; &#125;&#125;void BFS(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col)&#123; if(board[row][col] != 'O') return; int m = board.size(), n = board[0].size(); int left[] = &#123;-1, 0, 1, 0&#125;, right[] = &#123;0, -1, 0, 1&#125;; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;row, col&#125;); while(!q.empty())&#123; pair&lt;int, int&gt; cur = q.front(); q.pop(); if(cur.first &lt; 0 || cur.first &gt;= m || cur.second &lt; 0 || cur.second &gt;= n) continue; if(board[cur.first][cur.second] != 'O') continue; board[cur.first][cur.second] = 'E'; for(int i = 0; i &lt; 4; i++)&#123; q.push(&#123;cur.first + left[i], cur.second + right[i]&#125;); &#125; &#125;&#125; LC133 Clone Graph Problem Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; Test case format: For simplicity sake, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val = 1, the second node with val = 2, and so on. The graph is represented in the test case using an adjacency list. Adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1: 1234567Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3). Example 2: 123Input: adjList &#x3D; [[]]Output: [[]]Explanation: Note that the input contains one empty list. The graph consists of only one node with val &#x3D; 1 and it does not have any neighbors. Example 3: 123Input: adjList &#x3D; []Output: []Explanation: This an empty graph, it does not have any nodes. Example 4: 12Input: adjList &#x3D; [[2],[1]]Output: [[2],[1]] Constraints: 1 &lt;= Node.val &lt;= 100 Node.val is unique for each node. Number of Nodes will not exceed 100. There is no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node. Think BFS配合unordered_map，存放所有的节点对，最后返回根节点对应的节点即可。 Code 12345678910111213141516171819Node* cloneGraph(Node* node) &#123; if(!node) return NULL; unordered_map&lt;Node*, Node*&gt; visited; queue&lt;Node*&gt; q; q.push(node); visited[node] = new Node(node-&gt;val); while(!q.empty())&#123; Node* tmp = q.front(); q.pop(); for(Node* next: tmp-&gt;neighbors)&#123; if(!visited.count(next))&#123; visited[next] = new Node(next-&gt;val); q.push(next); &#125; visited[tmp]-&gt;neighbors.push_back(visited[next]); &#125; &#125; return visited[node];&#125; LC199 Binary Tree Right Side View Problem Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- &#x2F; \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Think 树的BFS&amp;层序，可以不用visited Code 1234567891011121314151617vector&lt;int&gt; rightSideView(TreeNode* root) &#123; if(!root) return &#123;&#125;; queue&lt;TreeNode*&gt; q; vector&lt;int&gt; res; q.push(root); while(!q.empty())&#123; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = q.front(); q.pop(); if(i == len - 1) res.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return res;&#125; LC279 Perfect Squares Problem Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: 123Input: n &#x3D; 12Output: 3 Explanation: 12 &#x3D; 4 + 4 + 4. Example 2: 123Input: n &#x3D; 13Output: 2Explanation: 13 &#x3D; 4 + 9. Think DP，dp[i] = min(dp[i - j * j] + 1), for all j 满足j * j &lt;= n Code 12345678910111213int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 0; dp[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; int mx = sqrt(i); dp[i] = i; for(int j = 1; j &lt;= mx; j++)&#123; dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n];&#125; LC301 Remove Invalid Parentheses Problem Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: 12Input: &quot;()())()&quot;Output: [&quot;()()()&quot;, &quot;(())()&quot;] Example 2: 12Input: &quot;(a)())()&quot;Output: [&quot;(a)()()&quot;, &quot;(a())()&quot;] Example 3: 12Input: &quot;)(&quot;Output: [&quot;&quot;] Think BFS，遍历每一种可能的删减 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243vector&lt;string&gt; removeInvalidParentheses(string s) &#123; // if(isValid(s)) return &#123;s&#125;; queue&lt;string&gt; q; q.push(s); unordered_set&lt;string&gt; visited; while(!q.empty())&#123; int len = q.size(); vector&lt;string&gt; res; for(int i = 0; i &lt; len; i++)&#123; string str = q.front(); q.pop(); if(isValid(str))&#123; res.push_back(str); &#125; for(int j = 0; j &lt; str.size(); j++)&#123; if(str[j] != '(' &amp;&amp; str[j] != ')') continue; string newString = str.substr(0, j) + str.substr(j + 1); if(!visited.count(newString))&#123; q.push(newString); visited.insert(newString); &#125; &#125; &#125; if(!res.empty())&#123; // vector&lt;string&gt; ret(res.begin(), res.end()); return res; &#125; &#125; return &#123;s&#125;;&#125;bool isValid(string s)&#123; int idx = 0; for(char c: s)&#123; if(c == '(')&#123; idx++; &#125; else if(c ==')')&#123; if(idx == 0) return false; idx--; &#125; &#125; return idx == 0;&#125; LC310 Minimum Height Trees Problem For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : 123456789Input: n &#x3D; 4, edges &#x3D; [[1, 0], [1, 2], [1, 3]] 0 | 1 &#x2F; \\ 2 3 Output: [1] Example 2 : 1234567891011Input: n &#x3D; 6, edges &#x3D; [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \\ | &#x2F; 3 | 4 | 5 Output: [3, 4] Note: According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Think BFS，但是这一题的BFS不是从根节点开始，而是从所有的叶节点开始遍历，然后每次都将这些叶节点从图中删去（也就是将连接到它们的边的另一个端的节点处的记录删去），从而实现从下到上每次都删去一层叶节点的操作，最终剩下的1个或者两个节点就是我们要求解的结果。 Code 123456789101112131415161718192021222324252627282930vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; if(n == 1) return &#123;0&#125;; vector&lt;unordered_set&lt;int&gt;&gt; adj(n); queue&lt;int&gt; q; for(auto e: edges)&#123; adj[e[0]].insert(e[1]); adj[e[1]].insert(e[0]); &#125; for(int i = 0; i &lt; n; i++)&#123; if(adj[i].size() == 1) q.push(i); &#125; while(n &gt; 2)&#123; int len = q.size(); n -= len; for(int i = 0; i &lt; len; i++)&#123; int cur = q.front(); q.pop(); for(auto next: adj[cur])&#123; adj[next].erase(cur); if(adj[next].size() == 1) q.push(next); &#125; &#125; &#125; vector&lt;int&gt; res; while(!q.empty())&#123; res.push_back(q.front()); q.pop(); &#125; return res;&#125; LC417 Pacific Atlantic Water Flow Problem Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges. Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Note: The order of returned grid coordinates does not matter. Both m and n are less than 150. Example: 12345678910111213Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). Think BFS，首先分别将两个边的节点加入队列中，然后对两个队列进行BFS，只push数值变大的节点即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;int&gt; dx&#123;-1, 0, 1, 0&#125;;vector&lt;int&gt; dy&#123;0, -1, 0, 1&#125;;vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); // four borders unordered_set&lt;int&gt; res1; unordered_set&lt;int&gt; res2; queue&lt;vector&lt;int&gt;&gt; q1; queue&lt;vector&lt;int&gt;&gt; q2; // left border for(int i = 0; i &lt; m; i++) q1.push(&#123;i, 0&#125;); // up border for(int i = 1; i &lt; n; i++) q1.push(&#123;0, i&#125;); // right border for(int i = 0; i &lt; m - 1; i++) q2.push(&#123;i, n - 1&#125;); // bottom border for(int i = 0; i &lt; n; i++) q2.push(&#123;m - 1, i&#125;); BFS(res1, matrix, q1); BFS(res2, matrix, q2); vector&lt;vector&lt;int&gt;&gt; res; for(auto r1: res1)&#123; if(res2.count(r1)) res.push_back(&#123;r1 / n, r1 % n&#125;); &#125; return res;&#125;void BFS(unordered_set&lt;int&gt;&amp; res, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, queue&lt;vector&lt;int&gt;&gt;&amp; q)&#123; int m = matrix.size(), n = matrix[0].size(); unordered_set&lt;int&gt; visited; while(!q.empty())&#123; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; vector&lt;int&gt; cur = q.front(); q.pop(); res.insert(cur[0] * n + cur[1]); int curValue = matrix[cur[0]][cur[1]]; for(int j = 0; j &lt; 4; j++)&#123; if((cur[0] + dx[j]) &gt;= 0 &amp;&amp; (cur[0] + dx[j]) &lt; m &amp;&amp; (cur[1] + dy[j]) &gt;= 0 &amp;&amp; (cur[1] + dy[j]) &lt; n)&#123; int next = matrix[cur[0] + dx[j]][cur[1] + dy[j]]; if(next &gt;= curValue &amp;&amp; !visited.count((cur[0] + dx[j]) * n + cur[1] + dy[j]))&#123; q.push(&#123;cur[0] + dx[j], cur[1] + dy[j]&#125;); visited.insert((cur[0] + dx[j]) * n + cur[1] + dy[j]); &#125; &#125; &#125; &#125; &#125;&#125; LC513 Find Bottom Left Tree Value Problem Given a binary tree, find the leftmost value in the last row of the tree. Example 1: 12345678Input: 2 &#x2F; \\ 1 3Output:1 Example 2: 123456789101112Input: 1 &#x2F; \\ 2 3 &#x2F; &#x2F; \\ 4 5 6 &#x2F; 7Output:7 Note: You may assume the tree (i.e., the given root node) is not NULL. Think BFS，但是在每一层上先加入右子节点，再加入左子节点，这样最后一次从queue里pop出来的就是要求的最底下一层的最左边的点。 Code 123456789101112int findBottomLeftValue(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); TreeNode* node; while(!q.empty())&#123; node = q.front(); q.pop(); if(node-&gt;right) q.push(node-&gt;right); if(node-&gt;left) q.push(node-&gt;left); &#125; return node-&gt;val;&#125; LC515 Find Largest Value in Each Tree Row Problem You need to find the largest value in each row of a binary tree. Example: 123456789Input: 1 &#x2F; \\ 3 2 &#x2F; \\ \\ 5 3 9 Output: [1, 3, 9] Think BFS+层序遍历，每层求最大值即可 Code 12345678910111213141516171819vector&lt;int&gt; largestValues(TreeNode* root) &#123; if(!root) return &#123;&#125;; vector&lt;int&gt; res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int len = q.size(); int cur = INT_MIN; for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = q.front(); q.pop(); cur = max(cur, node-&gt;val); if(node-&gt;right) q.push(node-&gt;right); if(node-&gt;left) q.push(node-&gt;left); &#125; res.push_back(cur); &#125; return res;&#125; LC529 Minesweeper Problem Let’s play the minesweeper game (Wikipedia, online game)! You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine. Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules: If a mine (‘M’) is revealed, then the game is over - change it to ‘X’. If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively. If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines. Return the board when no more squares will be revealed. Example 1: 123456789101112131415Input: [[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;], [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]Click : [3,0]Output: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]] Example 2: 123456789101112131415Input: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]Click : [1,2]Output: [[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;], [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]] Note: The range of the input matrix’s height and width is [1,50]. The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square. The input board won’t be a stage when game is over (some mines have been revealed). For simplicity, not mentioned rules should be ignored in this problem. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares. Think BFS，首先判断click处是否为M，是的话则改为X，然后直接返回 否则从click处bfs遍历整个图，对于遍历到的点，首先判断改点周围是否有M，有的话改为数字，否则改为B，并将周围八个点加入q Code 1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123; vector&lt;vector&lt;char&gt;&gt; res = board; if(board[click[0]][click[1]] == 'M')&#123; res[click[0]][click[1]] = 'X'; return res; &#125; int m = board.size(), n = board[0].size(); vector&lt;int&gt; dx = &#123;-1, -1, -1, 0, 0, 1, 1, 1&#125;; vector&lt;int&gt; dy = &#123;-1, 0, 1, -1, 1, -1, 0, 1&#125;; queue&lt;vector&lt;int&gt;&gt; q; unordered_set&lt;int&gt; visited; q.push(click); while(!q.empty())&#123; vector&lt;int&gt; cur = q.front(); q.pop(); if(board[cur[0]][cur[1]] == 'E')&#123; int cnt = 0; for(int i = 0; i &lt; 8; i++)&#123; if(cur[0] + dx[i] &gt;= 0 &amp;&amp; cur[0] + dx[i] &lt; m &amp;&amp; cur[1] + dy[i] &gt;= 0 &amp;&amp; cur[1] + dy[i] &lt; n)&#123; if(board[cur[0] + dx[i]][cur[1] + dy[i]] == 'M') cnt++; &#125; &#125; if(cnt == 0)&#123; res[cur[0]][cur[1]] = 'B'; for(int i = 0; i &lt; 8; i++)&#123; if(cur[0] + dx[i] &gt;= 0 &amp;&amp; cur[0] + dx[i] &lt; m &amp;&amp; cur[1] + dy[i] &gt;= 0 &amp;&amp; cur[1] + dy[i] &lt; n)&#123; if(board[cur[0] + dx[i]][cur[1] + dy[i]] == 'E')&#123; if(!visited.count((cur[0] + dx[i]) * n + cur[1] + dy[i]))&#123; visited.insert((cur[0] + dx[i]) * n + cur[1] + dy[i]); q.push(&#123;cur[0] + dx[i], cur[1] + dy[i]&#125;); &#125; &#125; &#125; &#125; &#125; else res[cur[0]][cur[1]] = (char)(cnt + '0'); &#125; &#125; return res;&#125; LC542 01 Matrix Problem Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Example 1: 123456789Input:[[0,0,0], [0,1,0], [0,0,0]]Output:[[0,0,0], [0,1,0], [0,0,0]] Example 2: 123456789Input:[[0,0,0], [0,1,0], [1,1,1]]Output:[[0,0,0], [0,1,0], [1,2,1]] Note: The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right. Think Approach 1 BFS，首先将所有的0的位置加入队列，从这些0开始遍历matrix，如果遍历到的1处的值大于当前得到的路径的长度，则更新，并将该点加入队列。 Approach 2 两次DP，分别从左上角和右下角出发 左上角：dp[i, j] = min(dp[i, j - 1] + 1, dp[i - 1, j] + 1) 右下角：dp[i, j] = min(dp[i, j + 1] + 1, dp[i + 1, j] + 1) 注意在初始化结果数组的时候，res中的每个值都必须初始化成INT_MAX - 10000，因为在第一次遍历过程中可能存在INT_MAX + 1的操作，而最长路径不可能超过10000（题目中说matrix的边长最大为10000）。 Code Approach 1 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return matrix; int m = matrix.size(), n = matrix[0].size(); queue&lt;vector&lt;int&gt;&gt; q; vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n, INT_MAX)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(matrix[i][j] == 0)&#123; res[i][j] = 0; q.push(&#123;i, j&#125;); &#125; &#125; &#125; vector&lt;int&gt; dx = &#123;0, 1, 0, -1&#125;, dy = &#123;1, 0, -1, 0&#125;; while(!q.empty())&#123; vector&lt;int&gt; cur = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++)&#123; if(cur[0] + dx[i] &gt;= 0 &amp;&amp; cur[0] + dx[i] &lt; m &amp;&amp; cur[1] + dy[i] &gt;= 0 &amp;&amp; cur[1] + dy[i] &lt; n)&#123; if(res[cur[0] + dx[i]][cur[1] + dy[i]] &gt; res[cur[0]][cur[1]] + 1)&#123; res[cur[0] + dx[i]][cur[1] + dy[i]] = res[cur[0]][cur[1]] + 1; q.push(&#123;cur[0] + dx[i], cur[1] + dy[i]&#125;); &#125; &#125; &#125; &#125; return res;&#125; Approach 2 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return matrix; int m = matrix.size(), n = matrix[0].size(); queue&lt;vector&lt;int&gt;&gt; q; vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n, INT_MAX - 10000)); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(matrix[i][j] == 0)&#123; res[i][j] = 0; &#125; else&#123; if(i &gt; 0) res[i][j] = min(res[i][j], res[i - 1][j] + 1); if(j &gt; 0) res[i][j] = min(res[i][j], res[i][j - 1] + 1); &#125; &#125; &#125; for(int i = m - 1; i &gt;= 0; i--)&#123; for(int j = n - 1; j &gt;= 0; j--)&#123; if(i &lt; m - 1) res[i][j] = min(res[i][j], res[i + 1][j] + 1); if(j &lt; n - 1) res[i][j] = min(res[i][j], res[i][j + 1] + 1); &#125; &#125; return res;&#125; Review BFS主要适用于求解最短路径，最短长度等一类最短问题，多和层序遍历配合使用，以达到可以求解路径长度的作用。需要注意如下： 起始节点不一定只有一个，可能是原数组或者图中的一类节点； 不一定非要从根节点出发来进行BFS，任意节点都可以作为BFS的出发的节点； visited数组：在添加子节点进queue的同时添加进visited数组； BFS可以进行层的删除，通过一层一层的删除叶节点来得到最终的中心点； ！！！！千万不要写成back tracing，回溯一般是用在要求得所有结果的情况下，类似DFS。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}]},{"title":"Binary Search(1)","slug":"Binary-Search-1","date":"2020-05-21T12:55:17.000Z","updated":"2020-06-08T14:39:07.951Z","comments":true,"path":"Binary-Search-1/","link":"","permalink":"http://yoursite.com/Binary-Search-1/","excerpt":"","text":"LC4 Median of Two Sorted Arrays Problem There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]The median is 2.0 Example 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]The median is (2 + 3)&#x2F;2 &#x3D; 2.5 Think 由于nums1和nums2都是有序的，所以对这两个数组，一定存在一个分割，使得在分割左半边的nums1和nums2的长度等于右边，且满足左边的最大值小于右边的最小值。 设nums1分割位于nums1[i - 1]和nums1[i]之间，nums2分割位于nums2[j - 1]和nums2[j]之间，且有 {nums1[i−1]&lt;nums2[j]nums2[j−1]&lt;nums1[i]i+j==m−i+n−j,if m+n is eveni+j==m−i+n−j+1,if m+n is odd\\begin{cases}nums1[i - 1] &lt; nums2[j]\\\\nums2[j - 1] &lt; nums1[i]\\\\i + j == m-i+n-j,if\\ m+n\\ is\\ even\\\\i + j == m-i+n-j+1,if\\ m+n\\ is\\ odd\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​nums1[i−1]&lt;nums2[j]nums2[j−1]&lt;nums1[i]i+j==m−i+n−j,if m+n is eveni+j==m−i+n−j+1,if m+n is odd​ 设left和right来对nums1进行二分，二分的条件即为上述关系式1&amp;2。 最后根据m+n的奇偶情况判断应该返回maxLeft还是(maxLeft + minRight) / 2。 Code 1234567891011121314151617181920212223242526272829double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); if(m &gt; n) return findMedianSortedArrays(nums2, nums1); int left = 0, right = m, halfLen = (m + n + 1) / 2; while(left &lt;= right)&#123; int i = left + (right - left) / 2; int j = halfLen - i; if(i &gt; left &amp;&amp; nums1[i - 1] &gt; nums2[j])&#123; right = i - 1; &#125; else if(i &lt; right &amp;&amp; nums2[j - 1] &gt; nums1[i])&#123; left = i + 1; &#125; else&#123; int maxLeft = 0; if(i == 0) maxLeft = nums2[j - 1]; else if(j == 0) maxLeft = nums1[i - 1]; else maxLeft = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2 == 1) return maxLeft; int minRight = 0; if(i == m) minRight = nums2[j]; else if(j == n) minRight = nums1[i]; else minRight = min(nums2[j], nums1[i]); return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0;&#125; LC29 Divide Two Integers Problem Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: 123Input: dividend &#x3D; 10, divisor &#x3D; 3Output: 3Explanation: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; 3. Example 2: 123Input: dividend &#x3D; 7, divisor &#x3D; -3Output: -2Explanation: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2. Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Think Approach 1 设被除数为dividend，除数为divisor，初始化结果res=0 当dividend &gt;= divisor的时候，找到当前最大的n满足divisor∗2n&lt;=dividenddivisor * 2^n &lt;= dividenddivisor∗2n&lt;=dividend，res += n，然后在dividend上减去divisor∗2ndivisor * 2^ndivisor∗2n，进行下一次循环； 由于int的范围为[−231,231][-2^{31}, 2^{31}][−231,231]，如果一正一负，可能会导致一开始的结果溢出，所以需要将被除数和除数都转化为负数，然后再进行上述计算。 Approach 2 在Approach 1的基础上，首先将除数的所有小于被除数的2的幂次乘积存储在数组里，然后直接去读取数组即可。 Code Approach 1 12345678910111213141516171819202122232425262728int HALF_INT_MIN = -1073741824;int divide(int dividend, int divisor) &#123; if(dividend == INT_MIN &amp;&amp; divisor == -1)&#123; return INT_MAX; &#125; int negatives = 2; if(dividend &gt; 0)&#123; dividend = -dividend; negatives--; &#125; if(divisor &gt; 0)&#123; divisor = -divisor; negatives--; &#125; int res = 0; while(dividend &lt;= divisor)&#123; int powerOfTwo = -1; int value = divisor; while(value &gt;= HALF_INT_MIN &amp;&amp; value + value &gt;= dividend) &#123; value += value; powerOfTwo += powerOfTwo; &#125; res += powerOfTwo; dividend -= value; &#125; return negatives != 1 ? -res: res;&#125; Approach 2 1234567891011121314151617181920212223242526272829303132333435int HALF_INT_MIN = -1073741824;int divide(int dividend, int divisor) &#123; if(dividend == INT_MIN &amp;&amp; divisor == -1)&#123; return INT_MAX; &#125; int negatives = 2; if(dividend &gt; 0)&#123; dividend = -dividend; negatives--; &#125; if(divisor &gt; 0)&#123; divisor = -divisor; negatives--; &#125; int tmp = -1; vector&lt;int&gt; dou; vector&lt;int&gt; powerOfTwo; while(divisor &gt;= dividend)&#123; dou.push_back(divisor); powerOfTwo.push_back(tmp); if(divisor &lt; HALF_INT_MIN)&#123; break; &#125; divisor += divisor; tmp += tmp; &#125; int res = 0; for(int i = dou.size() - 1; i &gt;= 0; i--)&#123; if(dou[i] &gt;= dividend)&#123; dividend -= dou[i]; res += powerOfTwo[i]; &#125; &#125; return negatives != 1 ? -res: res;&#125; LC33 Search in Rotated Sorted Array Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0Output: 4 Example 2: 12Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3Output: -1 Think 二分，初始化left=0，right=n - 1 当left &lt; right的时候， 如果nums[mid] == target，则直接返回mid， 如果nums[mid] &lt; taget，通过和nums[left]比较来判断mid当前是在左上升区间还是右上升区间 如果nums[mid] &gt; taget，通过和nums[left]比较来判断mid当前是在左上升区间还是右上升区间 Code 12345678910111213141516171819202122232425262728293031323334353637int search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.empty()) return -1; int left = 0, right = nums.size() - 1; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if(nums[mid] &lt; target)&#123; if(nums[mid] &lt; nums[left])&#123; if(target &lt; nums[left])&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; else&#123; left = mid + 1; &#125; &#125; else&#123; if(nums[mid] &gt;= nums[left])&#123; if(target &lt; nums[left])&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; else&#123; right = mid - 1; &#125; &#125; &#125; return nums[left] == target ? left : -1;&#125; LC34 Find First and Last Position of Element in Sorted Array Problem Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: 12Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8Output: [3,4] Example 2: 12Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6Output: [-1,-1] Think 分两次二分查找，分别查找左端点和右端点 Code 1234567891011121314151617181920212223vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res = &#123;-1, -1&#125;; int left = findRange(nums, target, true); if(left == nums.size() || nums[left] != target)&#123; return res; &#125; res[0] = left; res[1] = findRange(nums, target, false) - 1; return res;&#125;int findRange(vector&lt;int&gt;&amp; nums, int target, bool leftOrRight)&#123; int left = 0, right = nums.size(); while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] &gt; target || (leftOrRight &amp;&amp; nums[mid] == target))&#123; right = mid; &#125; else&#123; left = mid + 1; &#125; &#125; return left;&#125; LC35 Search Insert Position Problem Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 Think 普通的二分，如果不在数组里，则插入的位置恰好就是最终left = right的位置。 Code 12345678910111213141516int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size(); while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if(nums[mid] &gt; target)&#123; right = mid; &#125; else&#123; left = mid + 1; &#125; &#125; return left;&#125; LC50 Pow(x, n) Problem Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] Think 二分，注意INT_MIN在变成正数时会溢出，需要先+1处理一下 Code 123456789101112131415double myPow(double x, int n) &#123; if(n &lt; 0)&#123; return (1 / myPow(x, -(n + 1))) / x; &#125; while(n)&#123; double tmp = myPow(x, n / 2); if(n % 2 == 1)&#123; return x * tmp * tmp; &#125; else&#123; return tmp * tmp; &#125; &#125; return 1;&#125; LC69 Sqrt(x) Problem Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: 12Input: 4Output: 2 Example 2: 1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Think 二分法，设置left和right，表示结果在[left, right]内 如果mid*mid=target则直接返回，如果mid*mid&lt;target，说明结果应该在[mid+1, right]内，否则结果应该在[left, mid-1]内。 Code 123456789101112131415161718int mySqrt(int x) &#123; if(x == 0) return 0; if(x == 1) return 1; int left = 0, right = x; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(mid == x / mid &amp;&amp; x % mid == 0)&#123; return mid; &#125; else if(mid &gt; x / mid)&#123; right = mid; &#125; else&#123; left = mid + 1; &#125; &#125; return left - 1;&#125; LC74 Search a 2D Matrix Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: 12345678Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 3Output: true Example 2: 12345678Input:matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target &#x3D; 13Output: false Think 二分，初始left=0，right=m * n即可。 Code 1234567891011121314bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int left = 0, right = m * n; while(left &lt; right)&#123; int mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(matrix[row][col] &lt; target) left = mid + 1; else right = mid; &#125; return false;&#125; LC81 Search in Rotated Sorted Array II Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: 12Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0Output: true Example 2: 12Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? Think 在LC33-Search-in-Rotated-Sorted-Array的基础上，注意判断一下当前nums[mid]=num等于nums[left]的时候，这个时候mid可能在左上升区间也可能在右上升区间，所以此时只能将left+1，相当于跳过最左端的部分。 Code 12345678910111213141516171819202122232425262728bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.empty()) return false; int left = 0, right = nums.size(); while(left &lt; right)&#123; int mid = left + (right - left) / 2; int num = nums[mid]; if(num == target) return true; else if(num &lt; target)&#123; if(num == nums[left]) left += 1; else if(num &gt; nums[left]) left = mid + 1; else&#123; if(target == nums[left]) return true; else if(target &gt; nums[left]) right = mid; else left = mid + 1; &#125; &#125; else&#123; if(num == nums[left]) left += 1; else if(num &gt; nums[left])&#123; if(target == nums[left]) return true; else if(target &gt; nums[left]) right = mid; else left = mid + 1; &#125; else right = mid; &#125; &#125; return false;&#125; LC153 Find Minimum in Rotated Sorted Array Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12Input: [3,4,5,1,2] Output: 1 Example 2: 12Input: [4,5,6,7,0,1,2]Output: 0 Think 二分，设置left和right，我们要找的分界点的特点是大于其右边的值，范围为[left, right]，因此有： 当nums[mid] &lt; nums[right]的时候，说明mid在右上升区间，因此right = mid； 当nums[mid] &gt; nums[right]的时候，说明mid在左上升区间，因此left = mid + 1； 注意这里只能和nums[right]比较，因为nums[right]一定在右上升区间上，但是left可能不在左上升区间上。 Code 12345678910111213int findMin(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125; else&#123; left = mid + 1; &#125; &#125; return nums[left];&#125; LC154 Find Minimum in Rotated Sorted Array II Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12Input: [1,3,5]Output: 1 Example 2: 12Input: [2,2,2,0,1]Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? Think 二分法，在LC153 Find Minimum in Rotated Sorted Array的基础上，当nums[mid] == nums[right]的时候，根据上题分析，left可能不在左上升区间上，此时left即为要求的结果，而right必定不可能为要求解的结果，因此此处将right -= 1即可，而不可以left += 1. Code 12345678910111213141516int findMin(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125; else if(nums[mid] &gt; nums[right])&#123; left = mid + 1; &#125; else&#123; right -= 1; &#125; &#125; return nums[left];&#125; LC167 Two Sum II - Input array is sorted Problem Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2. Think Approach 1 二分，确定一个找另一个 Approach 2 双指针，nums[left]+nums[right] &gt; target的时候right–，&lt; target的时候left++； Code Approach 1 1234567891011121314151617181920212223242526vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int n = numbers.size(); for(int i = 0; i &lt; n &amp;&amp; numbers[i] &lt;= target / 2; i++)&#123; int index = findTarget(numbers, i, target - numbers[i]); if(index != -1)&#123; return &#123;min(i + 1, index + 1), max(i + 1, index + 1)&#125;; &#125; &#125; return &#123;-1, -1&#125;;&#125;int findTarget(vector&lt;int&gt;&amp; numbers, int start, int target)&#123; int left = start + 1, right = numbers.size() - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(numbers[mid] == target)&#123; return mid; &#125; else if(numbers[mid] &gt; target)&#123; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; return -1;&#125; Approach 2 1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0, right = n - 1; while(left &lt; right)&#123; int tmp = nums[left] + nums[right]; if(tmp &lt; target)&#123; left++; &#125; else if(tmp &gt; target)&#123; right--; &#125; else&#123; return &#123;left + 1, right + 1&#125;; &#125; &#125; return &#123;-1, -1&#125;;&#125; Review 对于二分搜索的题目来说，最重要的是 确定left和right的初值； 确定我们要求的值是在[left, right]还是[left, right)； 内部分至少三种情况，f(mid) == target，f(mid) &lt; target，f(mid) &gt; target，注意这里就算f(mid) == target也不一定代表可以直接返回结果，因为可能存在相同值的情况； 循环结束，如果循环的条件是left &lt;= right，则循环 结束代表没有找到需要的值；如果循环的条件是left &lt; right，则需要单独判断一下left=right处的值是否符合条件。","categories":[],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://yoursite.com/tags/Binary-Search/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"二分法的总结","slug":"二分法的总结","date":"2020-05-19T16:00:46.000Z","updated":"2020-05-20T18:03:21.998Z","comments":true,"path":"二分法的总结/","link":"","permalink":"http://yoursite.com/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"二分法的主要用途 二分法主要是通过左右逼近的方式，向目标值靠拢，并且取得对数复杂度的算法。 二分法的分类 查找和目标值相等的元素 给定有序数组nums，寻找元素target 写法一 12345678910111213# n: nums数组的大小# left: 左界限，初始化为0# right: 右界限，初始化为n - 1# target: 要寻找的值while left &lt;= right: # 说明要找的值当前在[left, right] mid = int(left + (right - left) / 2) if nums[mid] == target: return mid elif nums[mid] &lt; target: # 说明要找的target在[mid + 1, right] left = mid + 1 else: # nums[mid] &gt; target，说明要找的target在[left, mid - 1] right = mid - 1return -1 # 表示没找到 写法二 12345678910111213# n: nums数组的大小# left: 左界限，初始化为0# right: 右界限，初始化为n# target: 要寻找的值while left &lt; right: # 说明要找的值当前在[left, right) mid = int(left + (right - left) / 2) if nums[mid] == target: return mid elif nums[mid] &lt; target: # 说明要找的target在[mid + 1, right) left = mid + 1 else: # nums[mid] &gt; target，说明要找的target在[left, mid) right = midreturn -1 # 表示没找到 查找第一个不小于目标值的数(可变形为查找最后一个小于目标值的数) 这种情况就是对第一种情况的改进，主要是取消判断nums[mid] == target 1234567891011int find(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size(); while (left &lt; right) &#123; // 说明要找的值在[left, right]里，等于n表面不存在这样的值 int mid = left + (right - left) / 2; if (nums[mid] &lt; target) left = mid + 1; // 说明要找的值在[mid + 1, right]中 else right = mid; // 说明要找的值在[left, mid]中 &#125; return right; // 这里right对应的是第一个不小于目标值的数的下标 // 如果要求解最后一个小于目标值的数，则返回right - 1&#125; C++的STL中有两个函数，upper_bound和lower_bound： 在从小到大排列的数组nums中： lower_bound(nums.begin(), nums.end(), target) 从nums数组的begin位置到end - 1位置二分查找第一个大于或等于target的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标； upper_bound(nums.begin(), nums.end(), target) 从nums数组的begin位置到end - 1位置二分查找第一个大于target的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标； 在从大到小排列的数组nums中： lower_bound(nums.begin(), nums.end(), target, greater()) 从nums数组的begin位置到end - 1位置二分查找第一个小于或等于target的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去)始地址begin,得到找到数字在数组中的下标； upper_bound(nums.begin(), nums.end(), target, greater()) 从nums数组的begin位置到end - 1位置二分查找第一个小于target的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标； 查找第一个大于目标值的数(可变形为查找最后一个不大于目标值的数） 类似上一种情况，只不过对于nums[mid] == target的情况，需要找的结果在[mid + 1, right]中 1234567891011int find(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size(); while (left &lt; right) &#123; // 说明要找的值在[left, right]里，等于n表面不存在这样的值 int mid = left + (right - left) / 2; if (nums[mid] &lt;= target) left = mid + 1; // 说明要找的值在[mid + 1, right]中 else right = mid; // 说明要找的值在[left, mid]中 &#125; return right; // 这里right对应的是第一个大于目标值的数的下标 // 如果要求解最后一个不大于目标值的数，则返回right - 1&#125; mid对应的值由某个函数计算得出 即在第一种情况的基础上，在比较大小的地方使用了子函数去计算大小关系 12345678910int find(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (EQUAL(nums[mid], target)) return mid; else if (SMALLER(nums[mid], target)) left = mid + 1; else right = mid - 1; &#125; return -1;&#125; target值不固定 target的值可能随mid变化，比如需要搜索局部峰值的时候，需要比较的是mid和两边的值，这个时候target就会根据mid所在位置的不同而产生变化。 总结 二分法主要的思想就是对在某种程度上有序的数组上寻找特定值或者特定范围的值，通过大小关系来判断应该选择左半段还是右半段继续进行迭代。注意要确定这里left或者right的取值的时候，需要通过判断具体值的范围，特别注意right值的初始值，为n的时候表示左闭右开，为n - 1的时候表示左闭右闭。 参考 https://www.cnblogs.com/grandyang/p/6854825.html","categories":[],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://yoursite.com/tags/Binary-Search/"}]},{"title":"KMP算法总结","slug":"KMP算法总结","date":"2020-05-18T04:23:09.000Z","updated":"2020-05-18T23:15:44.940Z","comments":true,"path":"KMP算法总结/","link":"","permalink":"http://yoursite.com/KMP%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"KMP算法的用途 KMP算法是一种字符串匹配算法。 设两个字符串s和p，s为文本串，p为待匹配串，s的长度为n，p的长度为n，则最常见的字符串匹配的暴力算法就是遍历字符串s，如果s[0] == p[0]，则继续向后比较，直到字符串匹配完成或者发现不匹配的字符，然后向后继续比较；这样的方法的时间复杂度是O(mn)；而KMP算法则可以将时间复杂度降低到O(m + n)。 KMP算法 KMP算法的主要过程如下： 假设s=“BBC_ABCDAB_ABCDABCDABDE”, p=“ABCDABD” 匹配过程1: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程2: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程3: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程4: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程5: BBC_ABCDAB_ABCDABCDABDE ABCDABD 在这一次匹配过程中，我们可以发现一直到最后一个字母才发生了不匹配的情况。如果是暴力法的话，这里应当继续将字符串p后移一位，来继续匹配过程。但是KMP算法是将字符串p后移4位，也就是移动到下一处AB的位置，得到下一次的匹配。此处失配时，模式串向右移动的距离 = 已匹配字符数 - 失配字符的上一位字符所对应的部分匹配表的值。 匹配过程6: BBC_ABCDAB_ABCDABCDABDE ABCDABD 此时按照和上面相同的方法进行之后匹配，也就是有： 匹配过程7: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程8: BBC_ABCDAB_ABCDABCDABDE ABCDABD 匹配过程9: BBC_ABCDAB_ABCDABCDABDE ABCDABD 至此匹配成功。 部分匹配表的计算 部分匹配表，也就是最大前缀后缀公共元素长度数组，主要通过递归的方式求解。 设部分匹配表为next数组，假设已知next[j] = k，也就是对于s[0, j]这个子串，如果我们在j处失配，则应当将p后移动j - next[j]，也就在是p[j]之前(p[0, j - 1])，我们所能匹配上的最长前缀应当为p[0, next[j] - 1]。 所以我们首先判断p[k]=p[next[j]]和p[j]是否相等。 如果p[k] == p[j]，则说明next[j + 1]只需要在next[j]的基础上向后延长一位即可，也就是next[j + 1] = next[j] + 1 = k + 1； 如果p[k] != p[j]，则需要重新找到最长匹配数组，令k=next[k]，直到k=0或者找到p[k] == p[j]； 改进 在p[k] == p[j]的情况下，延长一位之后，如果此时p[j] == p[k]依然成立，则在匹配过程中可知，当p[k]和s[i]不匹配的时候，p[j]也必然和s[i]不匹配，因此取next[j] = next[next[j]] = next[k]；否则直接取next[j] = k即可； 代码参考 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; getNext(string p)&#123; int n = p.size(); vector&lt;int&gt; next(n, -1); int k = -1, j = 0; while(j &lt; n - 1)&#123; if(k == -1 || p[j] == p[k])&#123; j++; k++; next[j] = (p[j] == p[k] ? next[k]: k); &#125; else&#123; k = next[k]; &#125; &#125; return next;&#125;int KMP(string s, string p)&#123; int n = s.size(), m = p.size(), i = 0, j = 0; vector&lt;int&gt; next = getNext(p); while(i &lt; n &amp;&amp; j &lt; m)&#123; if(j == -1 || s[i] == p[j])&#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; return j == m ? i - j : -1;&#125;int main ()&#123; string s = \"BBC_ABCDAB_ABCDABCDABDE\"; string p = \"ABCDABD\"; cout &lt;&lt; KMP(s, p) &lt;&lt; endl; // 输出15 return 0;&#125; 参考链接 https://blog.csdn.net/v_july_v/article/details/7041827","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"}]},{"title":"Palindrome总结","slug":"Palindrome总结","date":"2020-05-17T03:19:18.000Z","updated":"2020-09-19T02:20:04.289Z","comments":true,"path":"Palindrome总结/","link":"","permalink":"http://yoursite.com/Palindrome%E6%80%BB%E7%BB%93/","excerpt":"","text":"LC125 Valid Palindrome Problem Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2: 12Input: &quot;race a car&quot;Output: false Think 双指针，比较两个指针处的char值即可 Code 1234567891011121314151617181920212223242526272829303132bool isPalindrome(string s) &#123; int n = s.size(); int l = 0, r = n - 1; while(l &lt; r)&#123; char cl = change(s[l]); if(cl == '#')&#123; l++; continue; &#125; char cr = change(s[r]); if(cr == '#')&#123; r--; continue; &#125; if(cl != cr) return false; l++; r--; &#125; return true;&#125;char change(char c)&#123; if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')&#123; return (char)(c - 'A' + 'a'); &#125; else if((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9'))&#123; return c; &#125; else&#123; return '#'; &#125;&#125; LC214 Shortest Palindrome Problem Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. Example 1: 12Input: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot; Example 2: 12Input: &quot;abcd&quot;Output: &quot;dcbabcd&quot; Think 利用KMP算法中的部分匹配表的算法 Code 1234567891011121314151617181920string shortestPalindrome(string s) &#123; int n = s.size(); string revStr = s; reverse(revStr.begin(), revStr.end()); string newStr = s + \"#\" + revStr; int newN = 2 * n + 1; vector&lt;int&gt; f(newN, 0); for(int i = 1; i &lt; newN; i++)&#123; int t = f[i - 1]; while(t &gt; 0 &amp;&amp; newStr[i] != newStr[t])&#123; t = f[t - 1]; &#125; if(newStr[i] == newStr[t])&#123; t++; &#125; f[i] = t; &#125; return revStr.substr(0, n - f.back()) + s;&#125; LC409 Longest Palindrome Problem Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example &quot;Aa&quot; is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: 12345678Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7. Think 统计所有52个字母出现的次数，累计所有次数 / 2 = k，然后判断是否有奇数出现次数的字母，如果有则返回2 * ，否则返回2 * k + 1。 Code 123456789101112131415161718int longestPalindrome(string s) &#123; vector&lt;int&gt; m(52, 0); for(auto c: s)&#123; if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123; m[c - 'a']++; &#125; else if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')&#123; m[c - 'A' + 26]++; &#125; &#125; int res = 0, flag = false; for(int i = 0; i &lt; 52; i++)&#123; res += m[i] / 2; if(m[i] % 2 == 1)&#123; flag = true; &#125; &#125; return flag ? 2 * res + 1: 2 * res;&#125; LC131 Palindrome Partitioning Problem Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: 123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] Think DFS或者backtracing Code 12345678910111213141516171819202122232425vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; helper(s, 0, &#123;&#125;, res); return res;&#125;void helper(string s, int start, vector&lt;string&gt; partition, vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123; int n = s.size(); if(start == n)&#123; res.push_back(partition); &#125; for(int i = start; i &lt; n; i++)&#123; string str = s.substr(start, i - start + 1); if(isP(str))&#123; partition.push_back(str); helper(s, i + 1, partition, res); partition.pop_back(); &#125; &#125;&#125;bool isP(string s)&#123; string rev = s; reverse(rev.begin(), rev.end()); return s == rev;&#125; LC132 Palindrome Partitioning II Problem Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: 123Input: &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. Think DP，设置两个dp数组 dp[i, j]表示s[i, j]是否为回文串，res[i]表示s[i, n - 1]所需要的最小的cut数目； for i = n - 1 to 0，我们可以知道res[i]最大为n - i - 1，也就是每个字符都切割开来； 因此接下来需要判断往后的所有s[i, j]是否为回文串，如果为回文串，则res[i] = min(res[j + 1] + 1) (注意这里需要判断j是否已经到达最后一个字符，如果已经到达，则不需要切割，即res[i] = 0)。 Code 123456789101112131415161718192021int minCut(string s) &#123; if(s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; res(n, 0); for(int i = n - 1; i &gt;= 0; i--)&#123; res[i] = n - i - 1; for(int j = i; j &lt; n; j++)&#123; if(s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]))&#123; dp[i][j] = true; if(j == n - 1)&#123; res[i] = 0; &#125; else&#123; res[i] = min(res[i], res[j + 1] + 1); &#125; &#125; &#125; &#125; return res[0];&#125; LC9 Palindrome Number Problem Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? Think 解析出每一位数字，然后组合成倒装的数字再判断即可。 Code 1234567891011bool isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0 || x % 10 == 0) return false; long rev = 0; int pre = x; while(x &gt; 0)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return pre == (int)rev;&#125; LC680 Valid Palindrome II Problem Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. Example 1: 12Input: &quot;aba&quot;Output: True Example 2: 123Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character &#39;c&#39;. Note: The string will only contain lowercase characters a-z. The maximum length of the string is 50000. Think 贪心算法 + 双指针，一个从左边，一个从右边，当找到第一个不同的字符的时候，判断删掉左边或者右边的字符之后剩下的是不是回文串。 Code 12345678910111213141516171819bool validPalindrome(string s) &#123; int n = s.size(); int i = 0; while(i &lt; n / 2)&#123; if(s[i] != s[n - 1 - i])&#123; return isP(s, i, n - 2 - i) || isP(s, i + 1, n - 1 - i); &#125; i++; &#125; return true;&#125;bool isP(string s, int left, int right)&#123; while(left &lt; right)&#123; if(s[left++] != s[right--])&#123; return false; &#125; &#125; return true;&#125; LC234 Palindrome Linked List Problem Given a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up: Could you do it in O(n) time and O(1) space? Think 首先通过快慢指针找到中间点，如果是奇数个(2k+1)，则令指针指向第k+1个；如果是偶数个(2k)，也令指针指向第k+1个； 然后将后半段链表翻转，再比较这两段链表前面的公共部分是否相同即可。 Code 123456789101112131415161718192021222324252627282930313233bool isPalindrome(ListNode* head) &#123; ListNode* secondHalfHead = second(head); ListNode* rev = reverse(secondHalfHead); ListNode* n1 = head, *n2 = rev; while(n1 &amp;&amp; n2)&#123; if(n1-&gt;val != n2-&gt;val)&#123; return false; &#125; n1 = n1-&gt;next; n2 = n2-&gt;next; &#125; return true;&#125;ListNode* reverse(ListNode* head)&#123; ListNode* pre = NULL; ListNode* cur = head; while(cur)&#123; ListNode* node = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = node; &#125; return pre;&#125;ListNode* second(ListNode* head)&#123; ListNode* fast = head, *slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; LC336 Palindrome Pairs Problem Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1: 123Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;] Example 2: 123Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]Output: [[0,1],[1,0]] Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;] Think 分三种情况，设一组匹配的word为word1和word2 word1和word2一样长 word1比word2长 word1比word2短 Approach 1 前缀树，每一个前缀树的节点包括三部分： 当前节点是哪一个word的结束字符，如果不是结束字符，则赋-1； 当前节点的所有子节点，根据读到不同的字符来判断，因此需要一个hash表； 如果当前节点之后的剩余字符可以组成一个回文串，则将该回文串加上原有字符组成的word的id存储起来 构建前缀树的时候，需要注意，对每一个word，首先遍历word，将每一个字符挂载在树上，同时判断该word的剩余部分是不是回文串，如果是，则将id也挂载在当前节点的第三部分；最后将id放在最后一个节点的第一部分。 在判断的时候，首先确定其中一个word，也就是word1，去找word2。 在三种case中，case3的word2最短，case1其次，case2最长，因此按照case 3 1 2的顺序来判断即可。 Case3 -&gt; 当前读到字符是某一个单词的结尾字符，且word1的剩余字符是回文串 Case1 -&gt; 当前读到的字符是某一个单词的结尾字符，且和word1不是同一个字符 Case2 -&gt; 直接将word1的id和当前节点的第三部分中的所有值组合，放入res中。 Approach 2 还是分三种情况： Case1: word和reversedWord都在words中，直接返回两个id就可以； 对于case 2和case 3，设定当前遍历到的word为长的那一个。 Case2: 即当前word为word2，则应当有word2的某一个后缀等于word1的翻转，且word2的剩余部分为回文串，因此只需要遍历所有可能的后缀即可； Case3: 即当前word为word1，则应当有word1的某一个前缀等于word2的翻转，且word1的剩余部分为回文串，因此只需要遍历所有可能的前缀即可。 Code Approach 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class TrieNode&#123;public: int wordEnding = -1; unordered_map&lt;char, TrieNode*&gt; next; vector&lt;int&gt; palindromePrefixRemaining;&#125;;class Solution &#123;public: bool isPalindromeRemaining(string s, int j)&#123; int left = j; int right = s.size() - 1; while(left &lt; right)&#123; if(s[left] != s[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125; vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; TrieNode *trie = new TrieNode(); for(int i = 0; i &lt; words.size(); i++)&#123; string word = words[i]; string revWord = word; reverse(revWord.begin(), revWord.end()); TrieNode* cur = trie; for(int j = 0; j &lt; word.size(); j++)&#123; if(isPalindromeRemaining(revWord, j))&#123; cur-&gt;palindromePrefixRemaining.push_back(i); &#125; char c = revWord[j]; if(!cur-&gt;next.count(c))&#123; cur-&gt;next[c] = new TrieNode(); &#125; cur = cur-&gt;next[c]; &#125; cur-&gt;wordEnding = i; &#125; vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; words.size(); i++)&#123; string word = words[i]; TrieNode* cur = trie; // case3, word is longer for(int j = 0; j &lt; word.size(); j++)&#123; if(cur-&gt;wordEnding != -1 &amp;&amp; isPalindromeRemaining(word, j))&#123; res.push_back(&#123;i, cur-&gt;wordEnding&#125;); &#125; cur = cur-&gt;next[word[j]]; if(!cur) break; &#125; if(!cur) continue; // case 1, same word but reversed if(cur-&gt;wordEnding != -1 &amp;&amp; cur-&gt;wordEnding != i)&#123; res.push_back(&#123;i, cur-&gt;wordEnding&#125;); &#125; // case 2, word is shorter for(int id: cur-&gt;palindromePrefixRemaining)&#123; res.push_back(&#123;i, id&#125;); &#125; &#125; return res; &#125; &#125;; Approach 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool isPalindrome(string s, int i, int j)&#123; int left = i; int right = j; while(left &lt; right)&#123; if(s[left] != s[right])&#123; return false; &#125; left++; right--; &#125; return true;&#125;vector&lt;string&gt; allValidPrefixes(string s)&#123; int n = s.size(); vector&lt;string&gt; res; for(int i = 0; i &lt; n; i++)&#123; if(isPalindrome(s, i, n - 1))&#123; res.push_back(s.substr(0, i)); &#125; &#125; return res;&#125;vector&lt;string&gt; allValidSuffixes(string s)&#123; int n = s.size(); vector&lt;string&gt; res; for(int i = 0; i &lt; n; i++)&#123; if(isPalindrome(s, 0, i))&#123; res.push_back(s.substr(i + 1)); &#125; &#125; return res;&#125;vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; map; for(int i = 0; i &lt; words.size(); i++)&#123; map[words[i]] = i; &#125; vector&lt;vector&lt;int&gt;&gt; res; for(string word: words)&#123; int index = map[word]; string rev = word; reverse(rev.begin(), rev.end()); // case 1 if(map.count(rev) &amp;&amp; map[rev] != index)&#123; res.push_back(&#123;index, map[rev]&#125;); &#125; // case 2 for(string suffix: allValidSuffixes(word))&#123; reverse(suffix.begin(), suffix.end()); if(map.count(suffix))&#123; res.push_back(&#123;map[suffix], index&#125;); &#125; &#125; // case 3 for(string prefix: allValidPrefixes(word))&#123; reverse(prefix.begin(), prefix.end()); if(map.count(prefix))&#123; res.push_back(&#123;index, map[prefix]&#125;); &#125; &#125; &#125; return res;&#125; LC479 Largest Palindrome Product Problem Find the largest palindrome made from the product of two n-digit numbers. Since the result could be very large, you should return the largest palindrome mod 1337. Example: 123Input: 2Output: 987Explanation: 99 x 91 &#x3D; 9009, 9009 % 1337 &#x3D; 987 Note: The range of n is [1,8]. Think 两个n位的数字相乘，最大为2n位，所以可以先构造出可能为结果的数字，然后判断这个数字是否可以分解成两个n位的数字相乘。 Code 12345678910111213141516171819int largestPalindrome(int n) &#123; if(n == 1) return 9; int upper = pow(10, n) - 1; int lower = pow(10, n - 1); for(int i = upper; i &gt;= lower; i--)&#123; long cand = buildP(i); for(long j = upper; j * j &gt;= cand; j--)&#123; if(cand % j == 0 &amp;&amp; cand / j &lt;= upper)&#123; return cand % 1337; &#125; &#125; &#125; return -1;&#125;long buildP(int i)&#123; string s = to_string(i); reverse(s.begin(), s.end()); return stol(to_string(i) + s);&#125; LC516 Longest Palindromic Subsequence Problem Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1: Input: 1&quot;bbbab&quot; Output: 14 One possible longest palindromic subsequence is “bbbb”. Example 2: Input: 1&quot;cbbd&quot; Output: 12 One possible longest palindromic subsequence is “bb”. Think DP，dp[i, j]表示s[i, j]的最长回文子序列，所以有： dp[i,j]={1,i==jdp[i+1][j−1]+2,s[i]==s[j]max(dp[i][j−1],dp[i+1][j]),otherwisedp[i, j] = \\begin{cases}1, i==j\\\\dp[i+1][j-1]+2, s[i] == s[j]\\\\max(dp[i][j-1], dp[i+1][j]),otherwise\\end{cases}dp[i,j]=⎩⎪⎨⎪⎧​1,i==jdp[i+1][j−1]+2,s[i]==s[j]max(dp[i][j−1],dp[i+1][j]),otherwise​ Code 12345678910111213141516171819int longestPalindromeSubseq(string s) &#123; int n = s.size(); vector&lt;int&gt; dp(n, 0); int pre = 0; for(int i = n - 1; i &gt;= 0; i--)&#123; for(int j = i; j &lt; n; j++)&#123; int tmp = pre; pre = dp[j]; if(i == j) dp[j] = 1; else if(s[i] == s[j])&#123; dp[j] = tmp + 2; &#125; else&#123; dp[j] = max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[n - 1];&#125; LC647 Palindromic Substrings Problem Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: 123Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: 123Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. Note: The input string length won’t exceed 1000. Think 中心扩展法，首先确定一个中心，然后同时向左右扩展到最大，这样的中心有2n - 1个 Code 1234567891011121314int countSubstrings(string s) &#123; int n = s.size(); int res = 0; for(int i = 0; i &lt; 2 * n - 1; i++)&#123; int left = i / 2; int right = left + i % 2; while(left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123; res++; left--; right++; &#125; &#125; return res;&#125; LC730 Count Different Palindromic Subsequences Problem Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7. A subsequence of a string S is obtained by deleting 0 or more characters from S. A sequence is palindromic if it is equal to the sequence reversed. Two sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i. Example 1: 123456Input: S &#x3D; &#39;bccb&#39;Output: 6Explanation: The 6 different non-empty palindromic subsequences are &#39;b&#39;, &#39;c&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;bcb&#39;, &#39;bccb&#39;.Note that &#39;bcb&#39; is counted only once, even though it occurs twice. Example 2: 12345Input: S &#x3D; &#39;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&#39;Output: 104860361Explanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7. Note: The length of S will be in the range [1, 1000]. Each character S[i] will be in the set {'a', 'b', 'c', 'd'}. Think DP，三维数组dp[k, i, j]表示在s[i, j]内以字符k（‘a’ + k）为开头和结尾的回文串的数目，则有： dp[k,i,j]={1,i=j&amp;s[i]=char(k)0,i=j&amp;s[i]!=char(k)dp[k,i+1,j],s[i]!=char(k)&amp;i&lt;jdp[k,i,j+1],s[j]!=char(k)&amp;i&lt;j2+dp[0,i+1,j−1]+dp[1,i+1,j−1]+dp[2,i+1,j−1]+dp[3,i+1,j−1], s[i]=s[j]=char(k)&amp;i&lt;j0,otherwisedp[k, i, j]=\\begin{cases}1,i=j\\&amp;s[i]=char(k)\\\\0,i=j\\&amp;s[i]!=char(k)\\\\dp[k, i+1, j],s[i]!=char(k)\\&amp;i&lt;j\\\\dp[k, i, j+1],s[j]!=char(k)\\&amp;i&lt;j\\\\2+dp[0,i+1,j-1]+dp[1,i+1,j-1]+dp[2,i+1,j-1]+dp[3,i+1,j-1],\\\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ s[i]=s[j]=char(k)\\&amp;i&lt;j\\\\0,otherwise\\end{cases}dp[k,i,j]=⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​1,i=j&amp;s[i]=char(k)0,i=j&amp;s[i]!=char(k)dp[k,i+1,j],s[i]!=char(k)&amp;i&lt;jdp[k,i,j+1],s[j]!=char(k)&amp;i&lt;j2+dp[0,i+1,j−1]+dp[1,i+1,j−1]+dp[2,i+1,j−1]+dp[3,i+1,j−1], s[i]=s[j]=char(k)&amp;i&lt;j0,otherwise​ 这里第5种情况的2，表示当在dp[k, i + 1, j - 1]的外边框上加了字符char(k)之后，我们还需要额外添加c和cc这两个回文字符串（c = char(k)）。 最后返回dp[k, 0, n - 1]在k=0-3上的总和。 Code 12345678910111213141516171819202122232425262728293031323334353637int countPalindromicSubsequences(string S) &#123; int n = S.size(); int mod = 1000000007; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(4, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0))); for(int i = n - 1; i &gt;= 0; i--)&#123; for(int j = i; j &lt; n; j++)&#123; for(int k = 0; k &lt; 4; k++)&#123; char c = 'a' + k; if(i == j)&#123; if(S[i] == c) dp[k][i][j] = 1; else dp[k][i][j] = 0; &#125; else if(S[i] != c)&#123; dp[k][i][j] = dp[k][i + 1][j]; &#125; else if(S[j] != c)&#123; dp[k][i][j] = dp[k][i][j - 1]; &#125; else&#123; // S[i] = S[j] = c dp[k][i][j] = 2; for(int m = 0; m &lt; 4; m++)&#123; dp[k][i][j] += dp[m][i + 1][j - 1]; dp[k][i][j] %= mod; &#125; &#125; &#125; &#125; &#125; int res = 0; for(int i = 0; i &lt; 4; i++)&#123; res += dp[i][0][n - 1]; res %= mod; &#125; return res;&#125; Review 回文串相关的题目解法比较多样化，主要有： 双指针，主要用于可以分别从左右两处进行比较的情况，如判断是否为回文串； KMP算法中的部分匹配表的算法，主要用于计算可以和给定字符串构成最短回文串的字符串； DFS或者backtracking，主要用于求具体有哪些回文串的情况，如分割字符串成多个回文串，需要状态上的回调； DP，主要用于只需要求解个数的情况，一般dp[i, j]表示s[i, j]这个子字符串的情况，可以和双指针的思想结合使用，如求解分割字符串成多个回文串的方法个数； 中心扩展法，主要用于求解长度相关的问题，其高级版本为马拉车算法，如求解所有可能的回文子串； 贪心法，主要用于删除字符的问题； 分情况讨论，一般和上述方法结合使用。 P.S. 区分substring和subsequence，前者需要在原字符串内连续，后者不需要，但两者内部的顺序都和原字符串相符合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Palindrome","slug":"Palindrome","permalink":"http://yoursite.com/tags/Palindrome/"}]},{"title":"Dynamic-Programming(2)","slug":"Dynamic-Programming-2","date":"2020-05-15T08:21:58.000Z","updated":"2020-05-18T06:25:53.437Z","comments":true,"path":"Dynamic-Programming-2/","link":"","permalink":"http://yoursite.com/Dynamic-Programming-2/","excerpt":"","text":"LC64 Minimum Path Sum Problem Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 12345678Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. Think DP，直接在原数组上修改即可，grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]; Code 12345678910111213141516int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty() || grid[0].empty()) return 0; int m = grid.size(), n = grid[0].size(); for(int i = 1; i &lt; m; i++)&#123; grid[i][0] += grid[i - 1][0]; &#125; for(int i = 1; i &lt; n; i++)&#123; grid[0][i] += grid[0][i - 1]; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]; &#125; &#125; return grid.back().back();&#125; LC70 Climbing Stairs Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step Think Approach 1 DP，类似斐波那契数列即可，注意要使用long作为数据结构 Approach 2 由于我们可以知道这题就是求解斐波那契数列的第n项，因此有矩阵Q=[Fn+1FnFnFn−1]Q=\\begin{bmatrix} F_{n+1} &amp; F_{n} \\\\ F_{n} &amp; F_{n-1} \\end{bmatrix}Q=[Fn+1​Fn​​Fn​Fn−1​​] 初始值Q0=[1110]Q_0=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}Q0​=[11​10​]，则Q0n{Q_0}^nQ0​n的左上角的值即为我们要求的结果。 为减小计算次数，我们采用二分的方法进行计算，如果为奇数，则先计算B=A∗qB=A*qB=A∗q，再计算B∗BB*BB∗B Code Approach 1 123456789int climbStairs(int n) &#123; long dp0 = 1, dp1 = 1; while(n--)&#123; int tmp = dp1; dp1 = dp0 + dp1; dp0 = tmp; &#125; return static_cast&lt;int&gt;(dp0);&#125; Approach 2 1234567891011121314151617181920212223242526int climbStairs(int n) &#123; vector&lt;vector&lt;long&gt;&gt; q = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; vector&lt;vector&lt;long&gt;&gt; res = power(q, n); return static_cast&lt;int&gt;(res[0][0]);&#125;vector&lt;vector&lt;long&gt;&gt; power(vector&lt;vector&lt;long&gt;&gt; q, int n)&#123; vector&lt;vector&lt;long&gt;&gt; res = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; while(n &gt; 0)&#123; if ((n &amp; 1) == 1) &#123; res = multi(res, q); &#125; n &gt;&gt;= 1; q = multi(q, q); &#125; return res;&#125;vector&lt;vector&lt;long&gt;&gt; multi(vector&lt;vector&lt;long&gt;&gt; a, vector&lt;vector&lt;long&gt;&gt; b)&#123; vector&lt;vector&lt;long&gt;&gt; res = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; for(int i = 0; i &lt; 2; i++)&#123; for(int j = 0; j &lt; 2; j++)&#123; res[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; &#125; &#125; return res;&#125; LC72 Edit Distance Problem Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)rorse -&gt; rose (remove &#39;r&#39;)rose -&gt; ros (remove &#39;e&#39;) Example 2: 12345678Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#39;t&#39;)inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)exection -&gt; execution (insert &#39;u&#39;) Think DP，dp[i, j]表示长度为i的字符串word1和长度为j的字符串word2的编辑距离； 如果word1[i - 1] == word2[j - 1]，则dp[i, j] = dp[i - 1, j - 1]; 否则，dp[i, j] = 1 + min(dp[i - 1, j - 1], min(dp[i - 1, j], dp[i, j - 1])); 初始条件： dp[i, 0] = i; 对0 &lt;= i &lt;= m; dp[0, i] = i; 对0 &lt;= i &lt;= n; Code 1234567891011121314151617181920int minDistance(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for(int i = 0; i &lt;= m; i++)&#123; dp[i][0] = i; &#125; for(int i = 0; i &lt;= n; i++)&#123; dp[0][i] = i; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(word1[i - 1] == word2[j - 1])&#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])); &#125; &#125; &#125; return dp[m][n];&#125; LC87 Scramble String Problem Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great &#x2F; \\ gr eat &#x2F; \\ &#x2F; \\g r e at &#x2F; \\ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat &#x2F; \\ rg eat &#x2F; \\ &#x2F; \\r g e at &#x2F; \\ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae &#x2F; \\ rg tae &#x2F; \\ &#x2F; \\r g ta e &#x2F; \\ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 &#x3D; &quot;great&quot;, s2 &#x3D; &quot;rgeat&quot;Output: true Example 2: 12Input: s1 &#x3D; &quot;abcde&quot;, s2 &#x3D; &quot;caebd&quot;Output: false Think Approach 1 递归 s1[0, i - 1]和s2[0, i - 1]满足scramble，且s1[i, n - 1]和s2[i, n - 1]满足scramble； s1[0, i - 1]和s2[n - i, n - 1]满足scramble，且s1[i, n - 1]和s2[0, n - i - 1]满足scramble； Approach 2 DP，设三维数组dp[i, j, len]表示s1[i…i + len - 1]和s2[j…j + len - 1]是否scramble 则有当len == 1时，dp[i, j, 1] = s1[i] == s2[j]； 否则，判断是否可以将s1和s2分别分割成两段，使得这两段互相可以scramble，即： dp[i, j, len] = || ((dp[i + k, j + k, len - k] &amp;&amp; dp[i, j, k]) || (dp[i, j + len - k, k] &amp;&amp; dp[i + k, j, len - k])), 0 &lt; k &lt; len 即两种情况，一是s1和s2均取前k个字符，再取剩下的len - k个字符；二是s1取前k个字符，和s2取前len - k个字符进行比较，然后s1取剩下的len - k个字符和s2取剩下的k个字符进行比较。 Code Approach 1 1234567891011121314151617181920bool isScramble(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; string str1 = s1, str2 = s2; sort(str1.begin(), str1.end()); sort(str2.begin(), str2.end()); if(str1 != str2) return false; int n = s1.size(); for(int i = 1; i &lt; n; i++)&#123; string ss1 = s1.substr(0, i); string ss2 = s1.substr(i); string ss3 = s2.substr(0, i); string ss4 = s2.substr(i); if(isScramble(ss1, ss3) &amp;&amp; isScramble(ss2, ss4)) return true; ss3 = s2.substr(n - i); ss4 = s2.substr(0, n - i); if(isScramble(ss1, ss3) &amp;&amp; isScramble(ss2, ss4)) return true; &#125; return false;&#125; Approach 2 1234567891011121314151617181920212223242526bool isScramble(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; string str1 = s1, str2 = s2; sort(str1.begin(), str1.end()); sort(str2.begin(), str2.end()); if(str1 != str2) return false; int n = s1.size(); vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; dp(n, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n + 1, false))); for(int len = 1; len &lt;= n; len++)&#123; for(int i = 0; i &lt;= n - len; i++)&#123; for(int j = 0; j &lt;= n - len; j++)&#123; if(len == 1) dp[i][j][len] = (s1[i] == s2[j]); else&#123; for(int k = 1; k &lt; len; k++)&#123; if((dp[i + k][j + k][len - k] &amp;&amp; dp[i][j][k]) || (dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k]))&#123; dp[i][j][len] = true; break; &#125; &#125; &#125; &#125; &#125; &#125; return dp[0][0][n];&#125; LC91 Decode Ways Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&#39;A&#39; -&gt; 1&#39;B&#39; -&gt; 2...&#39;Z&#39; -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: 123Input: &quot;12&quot;Output: 2Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). Example 2: 123Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). Think DP，dp[i]表示s中前i个字符构成的字符串能组成多少个结果 如果s[i - 1]可以被翻译成字母，则dp[i] += dp[i - 1]; 如果s[i - 1, i]可以被翻译成字母，则dp[i] += dp[i - 2]; 初始条件为dp[0] = 1, dp[1] 为s[0]是否可以翻译成字母。 Code 12345678910111213141516171819202122232425262728293031323334bool isValid(string s)&#123; if(s.size() &gt; 2) return false; if(s.size() == 1)&#123; return s[0] &gt;= '1' &amp;&amp; s[0] &lt;= '9'; &#125; else&#123; if(s[0] == '1')&#123; return s[1] &gt;= '0' &amp;&amp; s[1] &lt;= '9'; &#125; else if(s[0] == '2')&#123; return s[1] &gt;= '0' &amp;&amp; s[1] &lt;= '6'; &#125; else&#123; return false; &#125; &#125;&#125;int numDecodings(string s) &#123; int n = s.size(); if(n == 0) return 0; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; dp[1] = isValid(s.substr(0, 1)) ? 1 : 0; if(n == 1) return dp[1]; for(int i = 2; i &lt;= n; i++)&#123; if(isValid(s.substr(i - 1, 1))) dp[i] += dp[i - 1]; if(isValid(s.substr(i - 2, 2)))&#123; dp[i] += dp[i - 2]; &#125; &#125; return dp.back();&#125; LC97 Interleaving String Problem Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;Output: false Think DP，使用二维数组dp[i, j]表示长度为i的s1和长度为j的s2能否组成s3； dp[i, j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1, j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i, j - 1]); 初始条件即为s1和s2分别为0的时候 Code 1234567891011121314151617bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(); if(s3.size() != m + n) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for(int i = 1; i &lt;= m; i++)&#123; dp[i][0] = dp[i - 1][0] &amp;&amp; s1[i - 1] == s3[i - 1]; &#125; for(int i = 1; i &lt;= n; i++)&#123; dp[0][i] = dp[0][i - 1] &amp;&amp; s2[i - 1] == s3[i - 1]; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; dp[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]); &#125; &#125; return dp[m][n]; LC115 Distinct Subsequences Problem Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not). It’s guaranteed the answer fits on a 32-bit signed integer. Example 1: 123456789101112Input: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ Example 2: 12345678910111213141516Input: S &#x3D; &quot;babgbag&quot;, T &#x3D; &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.(The caret symbol ^ means the chosen letters)babgbag^^ ^babgbag^^ ^babgbag^ ^^babgbag ^ ^^babgbag ^^^ Think DP，dp[i ,j]表示从后往前长度分别为m-i和n-j的字符串所能匹配出来的数目； dp[i, j] = dp[i + 1, j] + dp[i + 1, j + 1] * (s[i] == t[j]) 注意初始条件是从右下角开始的，因此需要先设置所有的dp[i, n]和dp[m, j]； Code 123456789101112131415161718192021int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); if(m &lt; n) return 0; vector&lt;vector&lt;long&gt;&gt; dp(m + 1, vector&lt;long&gt;(n + 1, 0)); dp[m][n] = 1; for(int i = m - 1; i &gt;= 0; i--)&#123; dp[i][n] = 1; &#125; for(int i = n - 1; i &gt;= 0; i--)&#123; dp[m][i] = 0; &#125; for(int i = m - 1; i &gt;= 0; i--)&#123; for(int j = n - 1; j &gt;= 0; j--)&#123; dp[i][j] = dp[i + 1][j]; if(s[i] == t[j])&#123; dp[i][j] += dp[i + 1][j + 1]; &#125; &#125; &#125; return (int)dp[0][0];&#125; LC120 Triangle Problem Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Think DP，dp[i, j]表示到达第i行第j列的时候的最短路径，则有 dp[i,j]={dp[i−1][j]+triangle[i][j],j=0dp[i−1][j−1]+triangle[i][j],j=imin(triangle[i−1][j],triangle[i−1][j−1])+triangle[i][j],otherwisedp[i, j] =\\begin{cases}dp[i - 1][j] + triangle[i][j], j = 0\\\\dp[i - 1][j - 1] + triangle[i][j], j = i\\\\min(triangle[i - 1][j], triangle[i - 1][j - 1]) + triangle[i][j], otherwise\\end{cases}dp[i,j]=⎩⎪⎨⎪⎧​dp[i−1][j]+triangle[i][j],j=0dp[i−1][j−1]+triangle[i][j],j=imin(triangle[i−1][j],triangle[i−1][j−1])+triangle[i][j],otherwise​ 可以直接用triangle数组来代替dp数组 Code 123456789101112131415161718192021int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.back().size(); for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; if(j == 0)&#123; triangle[i][j] = triangle[i - 1][j] + triangle[i][j]; &#125; else if(j == i)&#123; triangle[i][j] = triangle[i - 1][j - 1] + triangle[i][j]; &#125; else&#123; triangle[i][j] = min(triangle[i - 1][j] + triangle[i][j], triangle[i - 1][j - 1] + triangle[i][j]); &#125; &#125; &#125; int res = INT_MAX; for(int i = 0; i &lt; n; i++)&#123; res = min(res, triangle.back()[i]); &#125; return res;&#125; LC139 Word Break Problem Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 123Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: 1234Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3: 12Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false Think DP，设dp[i]表示长度为i的字符串s能否满足条件，则有： dp[i] = dp[j] &amp;&amp; isWord(s.substr(j, i - j)), for 0 &lt;= j &lt;= i - 1，注意这里只要有一个j满足要求，则dp[i]就等于true isWord函数可以用哈希表来代替 Code 123456789101112131415161718bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); vector&lt;bool&gt; dp(n + 1, false); unordered_map&lt;string, int&gt; m; for(string str: wordDict)&#123; m[str] = 1; &#125; dp[0] = true; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= i - 1; j++)&#123; if(dp[j] &amp;&amp; m.count(s.substr(j, i - j)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp.back();&#125; LC140 Word Break II Problem Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 12345678Input:s &#x3D; &quot;catsanddog&quot;wordDict &#x3D; [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] Example 2: 12345678910Input:s &#x3D; &quot;pineapplepenapple&quot;wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3: 12345Input:s &#x3D; &quot;catsandog&quot;wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output:[] Think DFS，带记忆数组 DP会超时 Code 123456789101112131415161718192021vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; return helper(s, wordDict, m);&#125;vector&lt;string&gt; helper(string s, vector&lt;string&gt;&amp; wordDict, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; m)&#123; if(m.count(s)) return m[s]; if(s.empty())&#123; return &#123;\"\"&#125;; &#125; vector&lt;string&gt; res; for(auto word: wordDict)&#123; if(s.substr(0, word.size()) == word)&#123; vector&lt;string&gt; tmp = helper(s.substr(word.size()), wordDict, m); for(auto str: tmp)&#123; res.push_back(word + (str == \"\" ? \"\" : \" \") + str); &#125; &#125; &#125; m[s] = res; return res;&#125; LC152 Maximum Product Subarray Problem Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Think DP，分别计算[0, i]的最大累乘值和最小累乘值，因为可能有负数，所以最大值和最小值都有可能在下一次变成最小值和最大值，因此两个都需要计算。 Code 1234567891011int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), res = nums[0]; int minValue = 1, maxValue = 1; for(auto num: nums)&#123; int tmp1 = minValue, tmp2 = maxValue; minValue = min(num, min(num * tmp1, num * tmp2)); maxValue = max(num, max(num * tmp1, num * tmp2)); res = max(res, maxValue); &#125; return res;&#125; LC174 Dungeon Game Problem The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3 -5 -10 1 10 30 -5 § Note: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Think DP，设dp[i, j]表示在(i, j)这个位置出发，到最右下角所需要的最小生命值。从这个点出发有两种可以走的路径： 一是向右，即有health1 = max(1, dp[i, j + 1] - dungeon[i, j]) 二是向下，即有health2 = max(1, dp[i + 1, j] - dungeon[i, j]) 注意此处首先要判断能不能向右或者向下走，其次要注意与比较大小，如果比1大则说明需要更多的生命值，如果比1小，则说明就算在这个地方没有生命值了也可以继续走到最后，但是由于在每个点处至少要有1点生命值，因此至少要为1； 然后取两者里较小的那一个赋给dp[i, j]，此处需要判断，如果求出来的值为INT_MAX，则说明这一个点处既不可以向右也不可以向下，也就是最右下角的那一个点，需要单独求值。 Code 1234567891011121314151617181920212223int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int m = dungeon.size(), n = dungeon[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, INT_MAX)); for(int i = m - 1; i &gt;= 0; i--)&#123; for(int j = n - 1; j &gt;= 0; j--)&#123; int rightHealth = INT_MAX, downHealth = INT_MAX; if(j != n - 1)&#123; rightHealth = max(1, dp[i][j + 1] - dungeon[i][j]); &#125; if(i != m - 1)&#123; downHealth = max(1, dp[i + 1][j] - dungeon[i][j]); &#125; int nextHealth = min(rightHealth, downHealth); if(nextHealth == INT_MAX)&#123; dp[i][j] = (dungeon[i][j] &gt;= 0 ? 1 : 1 - dungeon[i][j]); &#125; else&#123; dp[i][j] = nextHealth; &#125; &#125; &#125; return dp[0][0];&#125; LC213 House Robber II Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses. Example 2: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3). Total amount you can rob &#x3D; 1 + 3 &#x3D; 4. Think DP，分两种情况，一种是只偷0 - n-2户，一种是只偷1 - n-1户的，最后比较终值。 注意特殊情况。 Code 12345678910111213141516171819int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 0) return 0; if(n == 1) return nums[0]; if(n == 2) return max(nums[0], nums[1]); vector&lt;int&gt; dp1(n, 0), dp2(n, 0); dp1[0] = nums[0]; dp1[1] = max(nums[0], nums[1]); dp1[2] = max(dp1[1], dp1[0] + nums[2]); dp2[1] = nums[1]; dp2[2] = max(nums[1], nums[2]); for(int i = 2; i &lt; n - 1; i++)&#123; dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]); dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i]); &#125; dp2[n - 1] = max(dp2[n - 2], dp2[n - 3] + nums[n - 1]); return max(dp1[n - 2], dp2[n - 1]);&#125; LC221 Maximal Square Problem Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 Think DP，二维数组dp[i, j]表示以在(i, j)处的点为右下角的点的时候的最大边长，则有 dp[i, j] = min(dp[i, j - 1], dp[i - 1, j], dp[i - 1, j - 1]) + 1, if matrix[i, j] == 1 可以简化成一维数组的DP Code 123456789101112131415161718192021222324int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); int res = 0; vector&lt;int&gt; dp(n, 0); for(int i = 0; i &lt; m; i++)&#123; int pre = dp[0]; dp[0] = matrix[i][0] == '1' ? 1: 0; res = max(res, dp[0]); for(int j = 1; j &lt; n; j++)&#123; int tmp = dp[j]; if(matrix[i][j] == '1')&#123; dp[j] = min(pre, min(dp[j], dp[j - 1])) + 1; res = max(res, dp[j]); &#125; else&#123; dp[j] = 0; &#125; pre = tmp; &#125; &#125; return res * res;&#125; LC264 Ugly Number II Problem Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n &#x3D; 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Think 类似三指针和堆结合的做法，相当于每一次取2 3 5对应的倍数堆里的最小值 Code 12345678910111213int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 0); dp[0] = 1; int res, i2 = 0, i3 = 0, i5 = 0; for(int i = 1; i &lt; n; i++)&#123; res = min(dp[i2] * 2, min(dp[i3] * 3, dp[i5] * 5)); dp[i] = res; if(res == dp[i2] * 2) i2++; if(res == dp[i3] * 3) i3++; if(res == dp[i5] * 5) i5++; &#125; return dp.back();&#125; Review DP的方向性，想不出来的时候可以从前后两个方向去考虑（二维数组则是四个角落的方向）； DP数组中的参数有的时候会采用原数组的下标，而有的时候会使用长度作为变量，而且大多数时候是用在字符串相关的问题中； DP数组的状态转化的时候有可能会需要遍历[0, i - 1]或者[i + 1, n - 1]的部分取寻找符合要求的子数组；","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://yoursite.com/tags/Dynamic-Programming/"}]},{"title":"Unity(C#)和Golang通过HTTP传输图片文件","slug":"Unity-C-和Golang通过HTTP传输图片文件","date":"2020-05-14T14:20:45.000Z","updated":"2020-05-15T17:21:16.391Z","comments":true,"path":"Unity-C-和Golang通过HTTP传输图片文件/","link":"","permalink":"http://yoursite.com/Unity-C-%E5%92%8CGolang%E9%80%9A%E8%BF%87HTTP%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6/","excerpt":"","text":"问题 在使用beego构建带有database的Http server的时候遇到如下问题 需要从前端(Unity)处传输一个png格式的图片到后端，并将其存储在数据库里； 前端向后端发送HTTP GET请求的时候，需要同时传输一个json和多张png格式的图片 调研 C#读取PNG文件，并通过HTTP POST请求上传到服务器 1234567891011121314var fileAddress &#x3D; Path.Combine(Application.streamingAssetsPath, &quot;Screenshots&#x2F;Screenshot.png&quot;);FileInfo fInfo0 &#x3D; new FileInfo(fileAddress);if (fInfo0.Exists)&#123; var content &#x3D; new MultipartFormDataContent(); content.Add(new ByteArrayContent(File.ReadAllBytes(fileAddress)), &quot;screenshot&quot;, &quot;Screenshot.png&quot;); HttpResponseMessage response &#x3D; await client.PostAsync(backendUrl, content); string responseString &#x3D; await response.Content.ReadAsStringAsync();&#125;else&#123; Debug.Log(&quot;No&quot;); return;&#125; 关键函数 File.ReadAllBytes(fileAddress)): fileAddress是文件的地址，返回值为byte数组； content.Add(new ByteArrayContent(byte[], &quot;file&quot;, &quot;filename&quot;): 该函数用于将文件贴进http request body，其中第一个参数为文件的字节流，第二个参数相当于文件的一个唯一标志，在接受的时候也需要用该参数进行接受(在后面使用golang接收文件的时候有所体现)，第三个参数表示接收到文件的时候的文件名； client.PostAsync(backendUrl, content): 该函数用于发起post请求，client为HttpClient类型的对象，第一个参数为URL，第二个参数为HttpContent，包含了所有类型的request body Unity设置Image组件的背景图片 1ImageComponent.sprite &#x3D; Resources.Load&lt;Sprite&gt;(&quot;filename&quot;); ImageComponet即为Image组件，Resources.Load加载的资源均位于文件夹&quot;Asserts/Resources&quot;下 Golang接收Post请求传过来的文件 1234567file, _, err := ctrl.GetFile(\"screenshot\")if err != nil &#123; fmt.Print(\"File retrieval failure\")&#125; else&#123; defer file.Close() _ = ctrl.SaveToFile(\"screenshot\", \"Screenshot.png\")&#125; 关键函数 GetFile: 该函数用于获取Post所带的文件，注意这里的参数就是上文C#中content.Add函数的第二个参数； SaveToFile: 该函数用于存储文件，第一个参数是上文C#中content.Add函数的第二个参数，第二个参数表示文件存储位置和名称，基础位置为项目文件夹的根目录； 解决方法 根据Beego的特性，其无法直接向数据库中存储BLOB格式的二进制数据，所以最终考虑直接存储在服务器端，采用唯一数字标识图片。在Get请求的传输过程中，采用将图片转化成byte数组，和之前的数据json合并，然后再传输过去，这样就只需要在客户端处处理byte数组，将起转化为图片即可。 1234Texture2D texture &#x3D; new Texture2D(1024, 1024);texture.LoadImage(byteArray);Sprite prite &#x3D; Sprite.Create(texture, new Rect(0, 0, 800, 531), new Vector2(0.5f, 0.5f));ImageComponent.sprite &#x3D; prite; 此处并不需要先将byte数组转化成图片保存下来，再load进image组件；我们只需要将byte数组读进Texture2D，然后转化成Sprite对象即可。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"},{"name":"Beego","slug":"Beego","permalink":"http://yoursite.com/tags/Beego/"}]},{"title":"Tree(1)","slug":"Tree-1","date":"2020-05-11T08:50:12.000Z","updated":"2020-05-15T22:24:08.475Z","comments":true,"path":"Tree-1/","link":"","permalink":"http://yoursite.com/Tree-1/","excerpt":"","text":"LC94 Binary Tree Inorder Traversal Problem Given a binary tree, return the inorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 &#x2F; 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Think 中序遍历，两种方法：递归法和迭代法 Code Approach 1 12345678910111213vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res;&#125;void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(!root)&#123; return; &#125; helper(root-&gt;left, res); res.push_back(root-&gt;val); helper(root-&gt;right, res);&#125; Approach 2 123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while(!s.empty() || p)&#123; if(p)&#123; s.push(p); p = p-&gt;left; &#125; else&#123; TreeNode *t = s.top(); s.pop(); res.push_back(t-&gt;val); p = t-&gt;right; &#125; &#125; return res;&#125; LC95 Unique Binary Search Trees II Problem Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&#39;s shown below: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 Think 递归，选择所有可能的根节点i，然后将left ～ i - 1的部分用递归的方式构成左子树，将i + 1 ～ right的部分用递归的方式构成右子树，最后将所有可能的左右子树和根节点拼接起来，就可以得到所有可能的树的构成 Code 1234567891011121314151617181920212223242526vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n == 0)&#123; return &#123;&#125;; &#125; return helper(1, n);&#125;vector&lt;TreeNode*&gt; helper(int left, int right)&#123; vector&lt;TreeNode*&gt; res; if(left &gt; right)&#123; res.push_back(NULL); return res; &#125; for(int i = left; i &lt;= right; i++)&#123; vector&lt;TreeNode*&gt; lTree = helper(left, i - 1); vector&lt;TreeNode*&gt; rTree = helper(i + 1, right); for(auto l: lTree)&#123; for(auto r: rTree)&#123; TreeNode* tr = new TreeNode(i); tr-&gt;left = l; tr-&gt;right = r; res.push_back(tr); &#125; &#125; &#125; return res;&#125; LC96 Unique Binary Search Trees Problem Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n &#x3D; 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 Think DP，对于长度i，取j为中心点，则dp[i] += dp[j - 1] * dp[i - j]，1 &lt;= j &lt;= i Code 1234567891011int numTrees(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= i; j++)&#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp.back();&#125; LC98 Validate Binary Search Tree Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456 2 &#x2F; \\ 1 3Input: [2,1,3]Output: true Example 2: 123456789 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&#39;s value is 5 but its right child&#39;s value is 4. Think 递归，函数输入当前节点应该在的范围，如果节点不在这个范围内则返回false；然后递归判断左右子树即可 Code 12345678910111213bool isValidBST(TreeNode* root) &#123; return helper(root, NULL, NULL);&#125;bool helper(TreeNode* root, TreeNode* lower, TreeNode* upper)&#123; if(!root) return true; if(lower &amp;&amp; root-&gt;val &lt;= lower-&gt;val) return false; if(upper &amp;&amp; root-&gt;val &gt;= upper-&gt;val) return false; if(!helper(root-&gt;left, lower, root)) return false; if(!helper(root-&gt;right, root, upper)) return false; return true;&#125; LC99 Recover Binary Search Tree Problem Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 &#x2F; 3 \\ 2Output: [3,1,null,null,2] 3 &#x2F; 1 \\ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 &#x2F; \\1 4 &#x2F; 2Output: [2,1,4,null,null,3] 2 &#x2F; \\1 4 &#x2F; 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Think 类似线索二叉树的方法，每次到子树的最右边的那个节点的时候就添加一个指针指向下一个应该遍历的节点 Code 1234567891011121314151617181920212223242526272829303132333435363738void swap(TreeNode* x, TreeNode* y)&#123; int tmp = x-&gt;val; x-&gt;val = y-&gt;val; y-&gt;val = tmp;&#125;void recoverTree(TreeNode* root) &#123; TreeNode *x = NULL, *y = NULL, *pred = NULL, *predecessor = NULL; while(root)&#123; if(root-&gt;left)&#123; predecessor = root-&gt;left; while(predecessor-&gt;right &amp;&amp; predecessor-&gt;right != root)&#123; predecessor = predecessor-&gt;right; &#125; if(!predecessor-&gt;right)&#123; predecessor-&gt;right = root; root = root-&gt;left; &#125; else&#123; if(pred &amp;&amp; root-&gt;val &lt; pred-&gt;val)&#123; y = root; if(x == NULL) x = pred; &#125; pred = root; predecessor-&gt;right = NULL; root = root-&gt;right; &#125; &#125; else&#123; if(pred &amp;&amp; root-&gt;val &lt; pred-&gt;val)&#123; y = root; if(x == NULL) x = pred; &#125; pred = root; root = root-&gt;right; &#125; &#125; swap(x, y);&#125; LC100 Same Tree Problem Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 &#x2F; \\ &#x2F; \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 &#x2F; \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 &#x2F; \\ &#x2F; \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false Think 递归判断左右子树即可 Code 12345bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(!p &amp;&amp; !q) return true; if(!p || !q) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) &amp;&amp; p-&gt;val == q-&gt;val;&#125; LC102 Binary Tree Level Order Traversal Problem Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] Think 层序遍历，用队列即可 Code 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if(!root) return &#123;&#125;; queue&lt;TreeNode*&gt; s; s.push(root); vector&lt;vector&lt;int&gt;&gt; res; while(!s.empty())&#123; int len = s.size(); vector&lt;int&gt; cur; for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = s.front(); cur.push_back(node-&gt;val); s.pop(); if(node-&gt;left) s.push(node-&gt;left); if(node-&gt;right) s.push(node-&gt;right); &#125; res.push_back(cur); &#125; return res;&#125; LC103 Binary Tree Zigzag Level Order Traversal Problem Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] Think 层序遍历，用队列即可，然后加上一个flag表示这一层需不需要翻转 Code 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; if(!root) return &#123;&#125;; queue&lt;TreeNode*&gt; s; s.push(root); vector&lt;vector&lt;int&gt;&gt; res; int flag = 0; while(!s.empty())&#123; int len = s.size(); vector&lt;int&gt; cur; for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = s.front(); cur.push_back(node-&gt;val); s.pop(); if(node-&gt;left) s.push(node-&gt;left); if(node-&gt;right) s.push(node-&gt;right); &#125; if(flag == 1)&#123; reverse(cur.begin(), cur.end()); &#125; flag = 1 - flag; res.push_back(cur); &#125; return res;&#125; Review Tree最长用的方法主要有： 递归，主要是根据树的结构特性，使得我们很容易找到和树的整体结构类似的子树（大多数时候就是左右子树） 使用栈或者队列进行迭代，主要是利用BST的前序中序后续和层序遍历 动态规划","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Two Pointer(1)","slug":"Two-Pointer-1","date":"2020-05-09T05:14:07.000Z","updated":"2020-05-11T23:49:25.845Z","comments":true,"path":"Two-Pointer-1/","link":"","permalink":"http://yoursite.com/Two-Pointer-1/","excerpt":"","text":"LC3 Longest Substring Without Repeating Characters Problem Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Think 滑动窗口法，设窗口为(i, j]，则遍历字符串，设置一个hashmap保存所有字符出现的位置 假如当前字符出现过，则需要将窗口的左边界移到上一次出现的位置； 然后更新res = max(res, j - i)，并将当前字符和位置保存到hashmap里 Code 12345678910111213int lengthOfLongestSubstring(string s) &#123; int n = s.size(); int i = -1, res = 0; unordered_map&lt;char, int&gt; map; for(int j = 0; j &lt; n; j++)&#123; if(map.count(s[j]))&#123; i = max(i, map[s[j]]); &#125; res = max(res, j - i); map[s[j]] = j; &#125; return res;&#125; LC15 3Sum Problem Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Think 主要的想法是固定一个，求另外两个。为确保不重复，首先对数组排序，假设a最小，则a只能出现在&lt;=0的部分； 剩下部分即为用双指针求解b+c=-a的所有b和c（对每一个可能的a），注意判断重复值 Code 1234567891011121314151617181920212223242526vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; n &amp;&amp; nums[i] &lt;= 0; i++)&#123; if(i == 0 || nums[i] != nums[i - 1])&#123; helper(nums, i, res); &#125; &#125; return res;&#125;void helper(vector&lt;int&gt;&amp; nums, int i, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; int l = i + 1, r = nums.size() - 1; while(l &lt; r)&#123; int sum = nums[i] + nums[l] + nums[r]; if(sum &lt; 0 || (l &gt; i + 1 &amp;&amp; nums[l] == nums[l - 1]))&#123; l++; &#125; else if(sum &gt; 0 || (r &lt; nums.size() - 1 &amp;&amp; nums[r] == nums[r + 1]))&#123; r--; &#125; else&#123; res.push_back(&#123;nums[i], nums[l++], nums[r--]&#125;); &#125; &#125;&#125; LC16 3Sum Closest Problem Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums &#x3D; [-1, 2, 1, -4], and target &#x3D; 1.The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2). Think 和上一题3Sum的想法类似，使用的也是固定一个，求另外两个的方法 Code 123456789101112131415161718192021222324int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n &lt; 3) return 0; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int first = 0; first &lt; n - 2; first++)&#123; int second = first + 1; int third = n - 1; while(second &lt; third)&#123; int sum = nums[first] + nums[second] + nums[third]; if(sum == target) return target; if(abs(target - sum) &lt; abs(target - res)) &#123; res = sum; &#125; if(sum &lt; target)&#123; second++; &#125; else&#123; third--; &#125; &#125; &#125; return res;&#125; LC18 4Sum Problem Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Think 依然是和3Sum类似的想法，先固定一个，然后对剩下的数组用3Sum的算法即可；注意剪枝条件。 Code 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; n - 3; i++)&#123; if(nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) break; if(nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) continue; for(int j = i + 1; j &lt; n - 2; j++)&#123; if(nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) break; if(nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) continue; if((i == 0 || nums[i] != nums[i - 1]) &amp;&amp; (j == i + 1 || nums[j] != nums[j - 1]))&#123; helper(nums, i, j, res, target); &#125; &#125; &#125; return res;&#125;void helper(vector&lt;int&gt;&amp; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; res, int target)&#123; int l = j + 1, r = nums.size() - 1; while(l &lt; r)&#123; int sum = nums[i] + nums[j] + nums[l] + nums[r]; if(sum &lt; target || (l &gt; j + 1 &amp;&amp; nums[l] == nums[l - 1]))&#123; l++; &#125; else if(sum &gt; target || (r &lt; nums.size() - 1 &amp;&amp; nums[r] == nums[r + 1]))&#123; r--; &#125; else&#123; res.push_back(&#123;nums[i], nums[j], nums[l++], nums[r--]&#125;); &#125; &#125;&#125; LC19 Remove Nth Node From End of List Problem Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Think 双指针 快指针先走n步，然后快慢指针同步向后走，直到快指针到达链表的尾端 Code 123456789101112131415ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* tmp = new ListNode(0); tmp-&gt;next = head; ListNode* first = tmp; ListNode* second = tmp; for(int i = 0; i &lt;= n; i++)&#123; first = first-&gt;next; &#125; while(first != NULL)&#123; first = first-&gt;next; second = second-&gt;next; &#125; second-&gt;next = second-&gt;next-&gt;next; return tmp-&gt;next;&#125; LC26 Remove Duplicates from Sorted Array Problem Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums &#x3D; [1,1,2],Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.It doesn&#39;t matter what you leave beyond the returned length. Example 2: 12345Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&#39;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; any modification to nums in your function would be known by the caller.&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Think 设置offset，当读到相同的数字的时候offset自增，然后将nums[i]处的数字放在nums[i - offset]处； 最后返回长度为n-offset。 Code 123456789101112int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int offset = 0, n = nums.size(); int i = 1; while(i &lt; n)&#123; if(nums[i] == nums[i - 1])&#123; offset++; &#125; nums[i - offset] = nums[i]; i++; &#125; return n - offset;&#125; LC27 Remove Element Problem Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 12345Given nums &#x3D; [3,2,2,3], val &#x3D; 3,Your function should return length &#x3D; 2, with the first two elements of nums being 2.It doesn&#39;t matter what you leave beyond the returned length. Example 2: 1234567Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&#39;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; any modification to nums in your function would be known by the caller.&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Think 类似上一题，但是注意当值不相等时才写入，相等则不写入 Code 1234567891011121314int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int offset = 0, n = nums.size(); int i = 0; while(i &lt; n)&#123; if(nums[i] == val)&#123; offset++; &#125; else&#123; nums[i - offset] = nums[i]; &#125; i++; &#125; return n - offset;&#125; Review 双指针一般是两种情况： 两个指针之间存在差值关系或者倍数关系，一般这种关系正是题目中的核心要求； 两个指针分别从数组的一头一尾进行遍历，直到两者相遇，一般这种情况多出现在有序数组，或者存在某种逻辑关系（一般不会直接给出）使得我可以选择是左边的指针右移还是右边的指针左移","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Two Pointer","slug":"Two-Pointer","permalink":"http://yoursite.com/tags/Two-Pointer/"}]},{"title":"LeetCode股票类问题研究","slug":"LeetCode股票类问题研究","date":"2020-05-06T10:26:59.000Z","updated":"2020-05-15T05:46:19.485Z","comments":true,"path":"LeetCode股票类问题研究/","link":"","permalink":"http://yoursite.com/LeetCode%E8%82%A1%E7%A5%A8%E7%B1%BB%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6/","excerpt":"","text":"LeetCode上的股票类问题一共有6道，121 122 123 188 309 714 LC121 Best Time to Buy and Sell Stock Description Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5. Not 7-1 &#x3D; 6, as selling price needs to be larger than buying price. Example 2: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Think 该问题即为求解在前i个元素的最小值处买入，在prices[i]处卖出，遍历数组求最大利润。 Code 1234567891011121314int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int maxProfit = 0; int minPrice = INT_MAX; for(int i = 0; i &lt; n; i++)&#123; if(prices[i] &lt; minPrice)&#123; minPrice = min(minPrice, prices[i]); &#125; if(maxProfit &lt; prices[i] - minPrice)&#123; maxProfit = prices[i] - minPrice; &#125; &#125; return maxProfit;&#125; LC122 Best Time to Buy and Sell Stock II Description Say you have an array prices for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4. Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3. Example 2: 12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Think 为了获得最大利润，我可以在每一个有利可图的时候买入再卖出，也就是只要prices[i] &gt; prices[i - 1]我就进行一次买入卖出的操作 Code 123456789int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 1; i &lt; prices.size(); i++)&#123; if(prices[i] &gt; prices[i - 1])&#123; res += prices[i] - prices[i - 1]; &#125; &#125; return res;&#125; LC123 Best Time to Buy and Sell Stock III Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most twotransactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3. Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3. Example 2: 12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Think 两次买卖，遍历prices数组，当遍历到第i个元素时，可以用lc121的方法求得前i个元素用一次买卖得到的最大利润，假设从这个元素之后开始第二次买卖，则也可以用上述方法求得第二次买卖的最大利润，其中每一次的买入价格从prices[i]变为prices[i] - maxProfit1 Code 1234567891011int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int minPrice1 = INT_MAX, minPrice2 = INT_MAX; int maxProfit1 = 0, maxProfit2 = 0; for(int p: prices)&#123; minPrice1 = min(minPrice1, p); maxProfit1 = max(maxProfit1, p - minPrice1); minPrice2 = min(minPrice2, p - maxProfit1); maxProfit2 = max(maxProfit2, p - minPrice2); &#125; return maxProfit2;&#125; LC188 Best Time to Buy and Sell Stock IV Description Say you have an array for which the *i-*th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: 123Input: [2,4,1], k &#x3D; 2Output: 2Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2. Example 2: 1234Input: [3,2,6,5,0,3], k &#x3D; 2Output: 7Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3. Think 类似买卖股票问题3的想法，只要在前一次买卖的基础上有利可图就买入。 p.s. 当k比prices数组的长度大的时候，应该采用买卖股票2的方式解决，这样只需要O(n)的复杂度。 Code 123456789101112131415161718192021int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k == 0) return 0; if (k &gt;= prices.size()) return solveMaxProfit(prices); vector&lt;int&gt; minPrice(k, INT_MAX), maxProfit(k, 0); for(int p: prices)&#123; for(int i = 0; i &lt; k; i++)&#123; minPrice[i] = min(minPrice[i], i == 0 ? p : p - maxProfit[i - 1]); maxProfit[i] = max(maxProfit[i], p - minPrice[i]); &#125; &#125; return maxProfit.back();&#125;int solveMaxProfit(vector&lt;int&gt;&amp; prices)&#123; int res = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; if (prices[i] - prices[i - 1] &gt; 0) &#123; res += prices[i] - prices[i - 1]; &#125; &#125; return res;&#125; LC309 Best Time to Buy and Sell Stock with Cooldown Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: 123Input: [1,2,3,0,2]Output: 3 Explanation: transactions &#x3D; [buy, sell, cooldown, buy, sell] Think Approach 1 DP，dp[i]表示prices[i…n]的最大利润，dp[i] = max(dp[i + 1], max(dp[j + 2] + prices[j] - prices[i]))，for all j &gt; i Approach 2 ![image-20200509113416293](/Users/chenyiming/Library/Application Support/typora-user-images/image-20200509113416293.png) DP + 自动机 Sold = held + price held = max(held, reset - price) Reset = max(reset, sold) Code Approach 1 12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;int&gt; dp(n + 2, 0); for(int i = n - 1; i &gt;=0; i--)&#123; int c1 = 0; for(int j = i + 1; j &lt; n; j++)&#123; c1 = max(c1, dp[j + 2] + prices[j] - prices[i]); &#125; int c2 = dp[i + 1]; dp[i] = max(c1, c2); &#125; return dp[0];&#125; Approach 2 12345678910int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sold = INT_MIN, held = INT_MIN, reset = 0; for(int p: prices)&#123; int pre = sold; sold = held + p; held = max(reset - p, held); reset = max(pre, reset); &#125; return max(sold, reset);&#125; LC714 Best Time to Buy and Sell Stock with Transaction Fee Description Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 1234Input: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] &#x3D; 1Selling at prices[3] &#x3D; 8Buying at prices[4] &#x3D; 4Selling at prices[5] &#x3D; 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8. Think 类似上一题的做法，但是只有两个状态，sold和held sold = max(sold, held + prices[i] - fee) held = max(held, sold - prices[i]) 注意此处初始化的时候，sold = 0，而held应该赋值为-prices[0]，相当于表示在i=0处的sold和held值的情况，也就是在i=0时已经卖出股票，则收益为0；在i=0时持有股票，则只能是买入了prices[0]的股票，因此收益为-prices[0]；所有的fee均在卖出股票时候计算，因为最终手里的股票必须要全部卖出才是最划算的情况。 Code 123456789int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); int sold = 0, held = -prices[0]; for(int i = 1; i &lt; n; i++)&#123; sold = max(held + prices[i] - fee, sold); held = max(sold - prices[i], held); &#125; return sold;&#125; Review 股票类问题一共有六题，主要使用的方法是DP 如果有交易费用和cooldown的话，记得要使用带状态的自动机来模拟买卖过程，从而降低时间复杂度","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Greedy(1)","slug":"Greedy-1","date":"2020-05-05T12:50:46.000Z","updated":"2020-05-06T23:11:48.031Z","comments":true,"path":"Greedy-1/","link":"","permalink":"http://yoursite.com/Greedy-1/","excerpt":"","text":"LC376 Wiggle Subsequence Problem A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: 123Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Example 2: 123Input: [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Example 3: 12Input: [1,2,3,4,5,6,7,8,9]Output: 2 Follow up: Can you do it in O(n) time? Think Approach 1 DP up[i]表示以第i个元素作为结尾的最长摇摆数组，且结尾处为上扬； down[i]表示以第i个元素作为结尾的最长摇摆数组，且结尾处为下降； 若nums[j] &lt; nums[i]，则up[i] = max(down[j] + 1)； 若nums[j] &gt; nums[i]，则down[i] = max(up[j] + 1)； 最终返回max(up.back(), down.back()) + 1 Approach 2 DP改进版 up[i]表示前i个元素的最长摇摆数组，且结尾处为上扬； down[i]表示前i个元素的最长摇摆数组，且结尾处为下降； 若nums[i - 1] &lt; nums[i]，则up[i] = down[i - 1] + 1, down[i] = down[i - 1]； 若nums[i - 1] &gt; nums[i]，则up[i] = up[i - 1], down[i] = up[i - 1] + 1； 否则up[i] = up[i - 1]，down[i] = down[i - 1]； 最后返回max(up.back(), down.back()) Approach 3 Greedy 设置preDiff记录上一次的相邻两个数字的差值，如果preDiff &gt;= 0则需要找下一组diff &lt; 0的相邻数字，如果preDiff &lt;= 0则需要找下一组diff &gt; 0的相邻数字；找到距离最近的一组，然后置preDiff = diff，直至运行到数组尾端。 Code Approach 1 1234567891011121314151617int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; vector&lt;int&gt; up(n, 0); vector&lt;int&gt; down(n, 0); for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; up[i] = max(up[i], down[j] + 1); &#125; else if(nums[i] &lt; nums[j])&#123; down[i] = max(down[i], up[j] + 1); &#125; &#125; &#125; return max(up.back(), down.back()) + 1;&#125; Approach 2 123456789101112131415161718192021int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; vector&lt;int&gt; up(n, 1); vector&lt;int&gt; down(n, 1); for(int i = 1; i &lt; n; i++)&#123; if(nums[i - 1] &lt; nums[i])&#123; up[i] = down[i - 1] + 1; down[i] = down[i - 1]; &#125; else if(nums[i - 1] &gt; nums[i])&#123; up[i] = up[i - 1]; down[i] = up[i - 1] + 1; &#125; else&#123; up[i] = up[i - 1]; down[i] = down[i - 1]; &#125; &#125; return max(up.back(), down.back());&#125; Approach 3 1234567891011121314int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; int prevDiff = nums[1] - nums[0]; int count = prevDiff ? 2 : 1; for(int i = 2; i &lt; n; i++)&#123; int diff = nums[i] - nums[i - 1]; if((diff &gt; 0 &amp;&amp; prevDiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevDiff &gt;= 0))&#123; count += 1; prevDiff = diff; &#125; &#125; return count;&#125; LC55 Jump Game Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: nums &#x3D; [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 123Input: nums &#x3D; [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 0 &lt;= nums[i][j] &lt;= 10^5 Think Approach 1 DP，dp[i]表示从第i个元素开始能否跳到最后一个位置处 从i处所能跳到的位置范围为[i + 1, min(i + nums[i], n - 1)]，因此遍历这个范围内的每一个数字j，如果存在dp[j] = true，则dp[i] = true。 Approach 2 Greedy 设置最后可以跳到的位置为lastPos，初始化为n - 1。从后向前遍历数组的每一个元素nums[i]，如果nums[i] + i &gt;= lastPos，说明在i这个位置可以跳到lastPos，因此将lastPos设置为i。最后判断lastPos是否等于0即可。 Code Approach 1 123456789101112131415bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;bool&gt; dp(n, false); dp[n - 1] = true; for(int i = n - 2; i &gt;= 0; i--)&#123; int maxStep = min(n - 1, nums[i] + i); for(int j = i + 1; j &lt;= maxStep; j++)&#123; if(dp[j])&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[0];&#125; Approach 2 12345678910bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int lastPos = n - 1; for(int i = n - 1; i &gt;= 0; i--)&#123; if(i + nums[i] &gt;= lastPos)&#123; lastPos = i; &#125; &#125; return lastPos == 0;&#125; LC45 Jump Game II Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: 1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. Think Greedy 设置两个变量maxPos和maxSteps，maxPos表示当前可以到达的最远的位置，maxSteps表示使用当前步数res可以达到的最远的位置。遍历数组，当发现maxSteps &lt; i，即使用当前步数res到不了i的时候，就需要新的步数，也就是res++，并将maxSteps设为maxPos；同时更新maxPos为当前可以到达的最远位置max(maxPos, i + nums[i])。 Code 1234567891011121314int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return 0; int maxPos = nums[0], maxSteps = nums[0]; int res = 1; for(int i = 0; i &lt; n; i++)&#123; if(maxSteps &lt; i)&#123; res++; maxSteps = maxPos; &#125; maxPos = max(maxPos, i + nums[i]); &#125; return res;&#125; LC134 Gas Station Problem There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: 1234567891011121314Input: gas &#x3D; [1,2,3,4,5]cost &#x3D; [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 12345678910111213Input: gas &#x3D; [2,3,4]cost &#x3D; [3,4,3]Output: -1Explanation:You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can&#39;t travel around the circuit once no matter where you start. Think Greedy 设total_tank为总的gas[i] - cost[i]的和，curr_tank为从start_station到当前station的gas[i] - cost[i]的和，若curr_station &lt; 0，则说明从start_station到当前位置是不可以实现的，因此将start_station置为i + 1，curr_tank重置为0。 最后若总的total_tank &lt; 0，则说明整个环是不可能实现的，因此返回-1，否则返回start_station。 Code 1234567891011121314int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); int total_tank = 0, curr_tank = 0; int start_station = 0; for(int i = 0; i &lt; n; i++)&#123; total_tank += gas[i] - cost[i]; curr_tank += gas[i] - cost[i]; if(curr_tank &lt; 0)&#123; start_station = i + 1; curr_tank = 0; &#125; &#125; return total_tank &gt;= 0 ? start_station : -1;&#125; LC135 Candy Problem There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: 123Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: 1234Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. Think Approach 1 双数组法，left2right表示只关注每一个人左边的那个人的rating所求得的每个人的糖果数目的数组，right2left表示只关注每一个人右边的那个人的rating所求得的每个人的糖果数目的数组。 如果ratings[i] &gt; ratings[i - 1]，则left2right[i] = left2right[i - 1] + 1，否则重置为1； 如果ratings[i] &gt; ratings[i + 1]，则right2left[i] = right2left[i - 1] + 1，否则重置为1； 由于最终既要满足左边的rating的要求又要满足右边rating的要求，我们设置的糖果的数目只能多不能少，因此最终每个人的糖果的数目应当为max(left2right[i], right2left[i])。 Approach 2 Greedy 设置candies表示总共需要的糖果数目，up表示连续上升的rating的数目，down表示连续下降的rating的数目。 遍历数组，首先求得rating数组中当前元素与前一个元素的大小关系，设为new_slope。 如果old_slope &gt; 0且new_slope = 0，或者old_slope &lt; 0且new_slope &gt;= 0，即表示如下两种情况： 1）之前的数组是上升的，而当前元素与前置元素相等 2）之前的数组是下降的，而当前元素大于等于前置元素 则可以计算这一部分的总糖果数目为(up * (up + 1)) / 2 + (down * (down + 1)) / 2 + max(up, down)，即计算1）中的前面的所有连续上升元素的总和，或是2）中前面先连续上升再连续下降的元素的总和 再根据new_slope的大小确定up++或者down++或者candies++； 最后加上最后一次的糖果数目，即(up * (up + 1)) / 2 + (down * (down + 1)) / 2 + max(up, down) + 1； Code Approach 1 12345678910111213141516171819202122232425int candy(vector&lt;int&gt;&amp; ratings) &#123; int res = 0; int n = ratings.size(); vector&lt;int&gt; left2right(n, 1), right2left(n, 1); for(int i = 1; i &lt; n; i++)&#123; if(ratings[i] &gt; ratings[i - 1])&#123; left2right[i] = left2right[i - 1] + 1; &#125; else&#123; left2right[i] = 1; &#125; &#125; for(int i = n - 2; i &gt;= 0; i--)&#123; if(ratings[i] &gt; ratings[i + 1])&#123; right2left[i] = right2left[i + 1] + 1; &#125; else&#123; right2left[i] = 1; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; res += max(left2right[i], right2left[i]); &#125; return res;&#125; Approach 2 12345678910111213141516171819202122232425262728293031int candy(vector&lt;int&gt;&amp; ratings) &#123; if(ratings.size() &lt;= 1)&#123; return ratings.size(); &#125; int candies = 0; int up = 0, down = 0, old_slope = 0; for(int i = 1; i &lt; ratings.size(); i++)&#123; int new_slope = 0; if(ratings[i] &lt; ratings[i - 1]) new_slope = -1; else if(ratings[i] &gt; ratings[i - 1]) new_slope = 1; if((old_slope &gt; 0 &amp;&amp; new_slope == 0) || (old_slope &lt; 0 &amp;&amp; new_slope &gt;= 0))&#123; candies += (up * (up + 1)) / 2 + (down * (down + 1)) / 2 + max(up, down); up = 0; down = 0; &#125; if(new_slope &gt; 0)&#123; up++; &#125; else if(new_slope &lt; 0)&#123; down++; &#125; else&#123; candies++; &#125; old_slope = new_slope; &#125; candies += (up * (up + 1)) / 2 + (down * (down + 1)) / 2 + max(up, down) + 1; return candies;&#125; Review 对于可以用贪心算法解决的问题，主要有两种方式： 1）当前元素和前一个元素的大小关系可以引申出不同的处理方式； 2）当前元素和前面某一个元素的大小关系可以引申出不同的处理方式； 一般情况下只需要遍历一遍数组就可以解决（前向或者后向）。 不能用贪心算法的情况： 1）中间结果会影响到最终的结果，而且不能通过跳过的方式解决； 2）无法使用中间某一次的结果去计算后面的结果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Greedy","slug":"Greedy","permalink":"http://yoursite.com/tags/Greedy/"}]},{"title":"Dynamic Programming(1)","slug":"Dynamic-Programming-1","date":"2020-05-04T10:22:50.000Z","updated":"2020-06-08T03:05:57.343Z","comments":true,"path":"Dynamic-Programming-1/","link":"","permalink":"http://yoursite.com/Dynamic-Programming-1/","excerpt":"","text":"LC5 Longest Palindromic Substring Problem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad” Output: “bab” Note: “aba” is also a valid answer. Example 2: Input: “cbbd” Output: “bb” Think Approach 1 Use two dimension dp vector and dp[i, j] denotes if s[i…j] is palindromic string. When s[i…j] is palindromic substring, dp[i, j] = true, otherwise dp[i, j] = false. Initial conditions are: dp[i, i] = true; when s[i] == s[i + 1], dp[i, i + 1] = true, otherwise false. dp[i, j] = dp[i + 1, j - 1] &amp;&amp; s[i] == s[j] Approach 2 Expand around center. A palindromic string mirrors around its center. Such a string s could have 2n - 1 center. Approach 3 马拉车算法 首先做预处理，在每一个间隔处加上#，开头加上$符号如 noon -&gt; $#n#o#o#n# 这样处理过后的字符串的长度一定是奇数，设为字符串t。设p[i]表示以t[i]为中心的最长回文串的半径，则原字符串s中以t[i]字符为中心的最长回文串的长度为p[i] - 1，该回文串在s中的起始位置为(i - p[i]) / 2。 计算p[i]数组，两个辅助变量：mx表示回文串能延伸到的最右边的位置，id为mx对应的回文串的中心点位置 12p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;然后继续一个字符一个字符进行匹配 Code Approach 1 12345678910111213141516string longestPalindrome(string s) &#123; if (s.empty()) return \"\"; int n = s.size(), left = 0, len = 1; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; ++i) &#123; dp[i][i] = 1; for (int j = 0; j &lt; i; ++j) &#123; dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1])); if (dp[j][i] &amp;&amp; len &lt; i - j + 1) &#123; len = i - j + 1; left = j; &#125; &#125; &#125; return s.substr(left, len);&#125; Approach 2 123456789101112131415161718192021string longestPalindrome(string s) &#123; if(s.empty()) return \"\"; if(s.size() &lt; 2) return s; int n = s.size(), left = 0, maxLen = 0; for(int i = 0; i &lt; n - 1; i++)&#123; helper(s, i, i, left, maxLen); helper(s, i, i + 1, left, maxLen); &#125; return s.substr(left, maxLen);&#125;void helper(string s, int start, int end, int &amp;left, int &amp;maxLen)&#123; int n = s.size(); while(start &gt;= 0 &amp;&amp; end &lt;= n - 1 &amp;&amp; s[start] == s[end])&#123; start--; end++; &#125; if(end - start - 1 &gt; maxLen)&#123; maxLen = end - start - 1; left = start + 1; &#125;&#125; Approach 3 1234567891011121314151617181920212223string longestPalindrome(string s) &#123; string t = \"$#\"; for(auto c: s)&#123; t.push_back(c); t.push_back('#'); &#125; int n = t.size(); vector&lt;int&gt; p(n, 0); int mx = 0, id = 0, resCenter = 0, maxLen = 0; for(int i = 1; i &lt; n; i++)&#123; p[i] = mx &gt; i ? min(mx - i, p[2 * id - i]): 1; while(t[i - p[i]] == t[i + p[i]]) p[i]++; if(mx &lt; i + p[i])&#123; mx = i + p[i]; id = i; &#125; if(maxLen &lt; p[i])&#123; resCenter = i; maxLen = p[i]; &#125; &#125; return s.substr((resCenter - maxLen) / 2, maxLen - 1);&#125; LC10 Regular Expression Matching Problem Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. 12&#39;.&#39; Matches any single character.&#39;*&#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s &#x3D; &quot;aa&quot;p &#x3D; &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s &#x3D; &quot;aa&quot;p &#x3D; &quot;a*&quot;Output: trueExplanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s &#x3D; &quot;ab&quot;p &#x3D; &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s &#x3D; &quot;aab&quot;p &#x3D; &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;. Example 5: 1234Input:s &#x3D; &quot;mississippi&quot;p &#x3D; &quot;mis*is*p*.&quot;Output: false Think Approach 1 递归 若p为空，判断s是否为空，s为空则返回true，否则返回false； 判断s和p的第一个字符是否匹配，即s不为空，且s[0] == p[0] || p[0] == '.'时匹配成功； 若p的长度大于等于2，且第二个字符为*，则判断s和p[2:]是否匹配，或者在第一个字符匹配的情况下判断s[1:]和p是否匹配； 否则判断在第一个字符匹配的情况下s[1:]和p[1:]是否匹配。 Approach 2 DP dp[i, j]表示判断s[i:]和p[j:]是否匹配 在求dp[i, j]时，首先判断s[i]和p[j]是否匹配，设值为first_match； 若j+1位在p的范围内，且p[j+1] == ‘*’，则dp[i, j] = dp[i, j + 2] || (first_match &amp;&amp; dp[i + 1, j]); 否则，dp[i, j] = first_match &amp;&amp; dp[i + 1, j + 1]; Code Approach 1 12345678910bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); bool first_match = (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.')); if(p.size() &gt;= 2 &amp;&amp; p[1] == '*')&#123; return isMatch(s, p.substr(2)) || (first_match &amp;&amp; isMatch(s.substr(1), p)); &#125; else&#123; return first_match &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125; Approach 2 1234567891011121314151617bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[m][n] = true; for(int i = m; i &gt;= 0; i--)&#123; for(int j = n - 1; j &gt;= 0; j--)&#123; bool first_match = i &lt; m &amp;&amp; (s[i] == p[j] || p[j] == '.'); if(j + 1 &lt; n &amp;&amp; p[j + 1] == '*')&#123; dp[i][j] = dp[i][j + 2] || (first_match &amp;&amp; dp[i + 1][j]); &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1]; &#125; &#125; &#125; return dp[0][0];&#125; LC32 Longest Valid Parentheses Problem Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: 123Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; Think Approach 1 DP，以右括号为基准进行判断，dp[i]表示以s[i]为结尾的最长的符合要求的字符串的长度； 当s[i] == ')'时： 若s[i - 1] == ‘(’，dp[i] = dp[i - 2] + 2； 若s[i - 1] == ‘)’，若s[i - dp[i - 1] - 1] == ‘(’，则dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2； Approach 2 stack，初始放入-1，读到左括号时将下标放入stack中； 读到右括号时pop栈顶元素： 若此时栈为空，则将当前下标放入栈中，表示当前可匹配的最前字符； 否则求i - stack.top()和maxLen的大小关系 Approach 3 分别从左右两边遍历字符串，设left = right = 0; 左遍历：当读到左括号的时候left++，读到右括号的时候right++；若left=right说明可以匹配，求最大值；若left&lt;right说明左括号不够匹配右括号，则将left和right归零； 右遍历：当读到左括号的时候left++，读到右括号的时候right++；若left=right说明可以匹配，求最大值；若left&gt;right说明右括号不够匹配左括号，则将left和right归零； Code Approach 1 12345678910111213141516171819202122int longestValidParentheses(string s) &#123; int n = s.size(); vector&lt;int&gt; dp(n, 0); int maxLen = 0; for(int i = 1; i &lt; n; i++)&#123; if(s[i] == ')')&#123; if(s[i - 1] == '(')&#123; dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; &#125; else&#123; if(i - dp[i - 1] &gt;= 1 &amp;&amp; s[i - dp[i - 1] - 1] == '(')&#123; if(i - dp[i - 1] - 2 &gt;= 0) dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2; else dp[i] = dp[i - 1] + 2; &#125; &#125; &#125; maxLen = max(maxLen, dp[i]); &#125; return maxLen;&#125; Approach 2 123456789101112131415161718192021int longestValidParentheses(string s) &#123; int n = s.size(); int maxLen = 0; stack&lt;int&gt; st; st.push(-1); for(int i = 0; i &lt; n; i++)&#123; if(s[i] == '(')&#123; st.push(i); &#125; else&#123; st.pop(); if(st.empty())&#123; st.push(i); &#125; else&#123; maxLen = max(maxLen, i - st.top()); &#125; &#125; &#125; return maxLen;&#125; Approach 3 1234567891011121314151617181920212223242526272829303132333435363738int longestValidParentheses(string s) &#123; int n = s.size(); int maxLen = 0; int left = 0, right = 0; for(int i = 0; i &lt; n; i++)&#123; if(s[i] == '(')&#123; left++; &#125; else&#123; right++; &#125; if(left == right)&#123; maxLen = max(maxLen, 2 * right); &#125; if(left &lt; right)&#123; left = 0; right = 0; &#125; &#125; left = 0; right = 0; for(int i = n - 1; i &gt;= 0; i--)&#123; if(s[i] == ')')&#123; right++; &#125; else&#123; left++; &#125; if(left == right)&#123; maxLen = max(maxLen, 2 * right); &#125; if(left &gt; right)&#123; left = 0; right = 0; &#125; &#125; return maxLen;&#125; LC44 Wildcard Matching Problem Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. 12&#39;?&#39; Matches any single character.&#39;*&#39; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: 12345Input:s &#x3D; &quot;aa&quot;p &#x3D; &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s &#x3D; &quot;aa&quot;p &#x3D; &quot;*&quot;Output: trueExplanation: &#39;*&#39; matches any sequence. Example 3: 12345Input:s &#x3D; &quot;cb&quot;p &#x3D; &quot;?a&quot;Output: falseExplanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;. Example 4: 12345Input:s &#x3D; &quot;adceb&quot;p &#x3D; &quot;*a*b&quot;Output: trueExplanation: The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;. Example 5: 1234Input:s &#x3D; &quot;acdcb&quot;p &#x3D; &quot;a*c?b&quot;Output: false Think DP，设dp[i, j]为s的前i个字符和p的前j个字符的匹配结果，则有 若s[i]和p[j]匹配，则dp[i, j] = dp[i - 1, j - 1]； 否则若p[j] == ‘*’，则dp[i, j] = dp[i - 1, j - 1] || dp[i - 1, j] || dp[i, j - 1]； 否则dp[i, j] = false； 初始条件： s和p均为空的时候，dp[0, 0] = true； s为空，p必须全部为’*’，dp[0, i]= dp[0, i - 1] &amp;&amp; p[i - 1] == ‘*’; p为空的时候，dp[i, 0] = false; Code 12345678910111213141516171819202122232425bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for(int i = 1; i &lt;= m; i++)&#123; dp[i][0] = false; &#125; for(int i = 1; i &lt;= n; i++)&#123; dp[0][i] = dp[0][i - 1] &amp;&amp; p[i - 1] == '*'; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(s[i - 1] == p[j - 1] || p[j - 1] == '?')&#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if(p[j - 1] == '*')&#123; dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j]; &#125; else&#123; dp[i][j] = false; &#125; &#125; &#125; return dp[m][n];&#125; LC62 Unique Paths Problem A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Example 1: 1234567Input: m &#x3D; 3, n &#x3D; 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m &#x3D; 7, n &#x3D; 3Output: 28 Think DP，dp[i, j] = dp[i - 1, j] + dp[i, j - 1]； 初始情况：dp[0, i] = dp[j, 0] = 1 可以转成一维数组：dp[i]表示一行的情况，dp[i] = dp[i - 1] + dp[i]; Code 123456789101112int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n, 0); for(int i = 0; i &lt; n; i++)&#123; dp[i] = 1; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[j] = dp[j - 1] + dp[j]; &#125; &#125; return dp.back();&#125; LC63 Unique Paths II Problem A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: 123456789101112Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2&gt;Explanation:There is one obstacle in the middle of the 3x3 grid above.&gt;There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right Think 类似LC62的做法，使用二维DP即可 Code 123456789101112131415161718192021222324int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;long&gt;&gt; dp(m, vector&lt;long&gt;(n, 0)); if(obstacleGrid[0][0] == 1) return 0; for(int i = 0; i &lt; m; i++)&#123; if(obstacleGrid[i][0] == 0) dp[i][0] = 1; else&#123; break; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(obstacleGrid[0][i] == 0) dp[0][i] = 1; else&#123; break; &#125; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if(obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1];&#125; Review DP问题最大的特点：最优子结构，所以当发现某一个问题是具有一定的递归性的，可以考虑用DP解决 在确定DP的递推公式的时候，第一要尝试对当前状态的相邻状态的递推转化，第二要尝试对可以从当前状态到达的状态或者可以到达当前状态的状态进行转化 注意边界条件，一般是某一个维度为0的时候","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://yoursite.com/tags/Dynamic-Programming/"}]},{"title":"First Blog And Records","slug":"First-Blog","date":"2020-05-04T09:52:27.000Z","updated":"2020-08-25T16:15:10.060Z","comments":true,"path":"First-Blog/","link":"","permalink":"http://yoursite.com/First-Blog/","excerpt":"","text":"Overview This is my first blog. In this blog website, I want to update some my Leetcode training process, my learning experience and some other problems I met in practical environment. By doing this, I want to improve my skills of programming and find a great job with effort and fortune. Wish me luck! Planning During this summer, my plan is: Finish Leetcode problems with 12-score everyday. Easy 3-score Medium 5-score Hard 7-score Polish the Sokoban Game and push it to the App Store. To-Do List LeetCode的14种模式-知乎 LeetCode总结 LC题目总结 Recording 5.4 LC5, LC10 5.5 LC32, LC44, LC62, LC63, LC376 5.6 LC55, LC45, LC134, LC135 5.8 LC121, LC122, LC123, LC188 5.9 LC309, LC714, LC3 5.10 LC15, LC16, LC18 5.11 LC19, LC26, LC27, LC94 5.14 LC95, LC96, LC98, LC99 5.15 LC100, LC102, LC103 5.16 LC64, LC70, LC72, LC87, LC91, LC97, LC 115 5.17 LC120, LC139, LC140, LC152, LC174, LC213, LC221, LC264 5.18 LC125, LC214, LC409 5.19 LC131, LC132, LC9, LC680, LC234 5.20 LC336, LC479, LC516, LC647, LC730 5.21 LC4 5.22 LC29, LC33, LC34, LC35, LC50 5.23 LC69, LC74,LC81, LC153, LC154, LC167 5.24 LC107, LC111, LC126, LC127 5.25 LC130, LC133, LC199, LC279, LC301, LC310, LC417 5.26 LC513, LC515, LC529, LC542 5.27 LC207, LC210, LC329 6.1 LC315, LC321, LC330, LC392, LC402, LC406, LC435 6.2 LC452, LC455, LC502, LC621 6.3 LC105, LC106, LC108, LC109, LC112, LC113, LC114 6.4 LC116, LC117, LC124, LC129, LC257, LC332, LC337, LC394 6.5 LC1, LC30, LC36 6.6 LC76, LC138, LC149 6.7 LC166, LC187, LC204, LC205, LC217, LC219, LC242, LC274 6.10 LC23, LC169, LC218, LC240, LC241 6.11 LC282, LC312, LC315, LC327, LC493 6.12 LC239, LC424, LC480, LC567 6.13 LC1020, LC1034, LC1037, LC1138, LC1145 6.15 LC78, LC190, LC191, LC201, LC231, LC268, LC318 6.16 LC338, LC342, LC371, LC389 6.17 LC209, LC230, LC275, LC278 6.18 LC300, LC349, LC350 6.19 LC352, LC354 6.20 LC363, LC28, LC61, LC75, LC80 6.22 LC86, LC88, LC141 6.23 LC142, LC344, LC345, LC457 6.24 LC524 6.26 LC128, LC399 6.27 LC547 7.4 LC675, LC690, LC744","categories":[],"tags":[{"name":"Try New Things","slug":"Try-New-Things","permalink":"http://yoursite.com/tags/Try-New-Things/"}]}],"categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://yoursite.com/tags/RunLoop/"},{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"},{"name":"Runtime","slug":"Runtime","permalink":"http://yoursite.com/tags/Runtime/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://yoursite.com/tags/Union-Find/"},{"name":"Two Pointer","slug":"Two-Pointer","permalink":"http://yoursite.com/tags/Two-Pointer/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://yoursite.com/tags/Binary-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://yoursite.com/tags/Bit-Manipulation/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://yoursite.com/tags/Sliding-Window/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://yoursite.com/tags/Divide-and-Conquer/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Greedy","slug":"Greedy","permalink":"http://yoursite.com/tags/Greedy/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"http://yoursite.com/tags/Topological-Sort/"},{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"},{"name":"Palindrome","slug":"Palindrome","permalink":"http://yoursite.com/tags/Palindrome/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://yoursite.com/tags/Dynamic-Programming/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"},{"name":"Beego","slug":"Beego","permalink":"http://yoursite.com/tags/Beego/"},{"name":"Try New Things","slug":"Try-New-Things","permalink":"http://yoursite.com/tags/Try-New-Things/"}]}